Disassembly Listing for solid_fuel_boiler
Generated From:
D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/solid_fuel_boiler.X/dist/default/debug/solid_fuel_boiler.X.debug.cof
15 бер. 2020 18:58:18

---  E:/3.46/pic18-lt/cxx-framework/src/traditional/stdclib/memset.asm  ---------------------------------
3634  0EFE     MOVLW 0xFE
3636  CFE3     MOVFF PLUSW1, FSR0
3638  FFE9     NOP
363A  0EFF     MOVLW 0xFF
363C  CFE3     MOVFF PLUSW1, FSR0H
363E  FFEA     NOP
3640  CFE9     MOVFF FSR0, PROD
3642  FFF3     NOP
3644  CFEA     MOVFF FSR0H, PRODH
3646  FFF4     NOP
3648  0EFB     MOVLW 0xFB
364A  50E3     MOVF PLUSW1, W, ACCESS
364C  E103     BNZ _2jContinue
364E  0EFC     MOVLW 0xFC
3650  50E3     MOVF PLUSW1, W, ACCESS
3652  E009     BZ jEnd
3654  0EFB     MOVLW 0xFB
3656  06E3     DECF PLUSW1, F, ACCESS
3658  E202     BC _3jEnd
365A  0EFC     MOVLW 0xFC
365C  06E3     DECF PLUSW1, F, ACCESS
365E  0EFD     MOVLW 0xFD
3660  50E3     MOVF PLUSW1, W, ACCESS
3662  6EEE     MOVWF POSTINC0, ACCESS
3664  D7F1     BRA jLoop
3666  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/stdclib/__init.c  -----------------------------------
3812  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/startup/c018i.c  ------------------------------------
0000  EFAA     GOTO 0x3754
0002  F01B     NOP
0004  0012     RETURN 0
3754  EE1D     LFSR 1, 0xD00
3756  F000     NOP
3758  EE2D     LFSR 2, 0xD00
375A  F000     NOP
375C  6AF8     CLRF TBLPTRU, ACCESS
375E  9C1F     BCF 0x1F, 6, ACCESS
3760  ECF8     CALL 0x31F0, 0
3762  F018     NOP
3764  EC09     CALL 0x3812, 0
3766  F01C     NOP
3768  EC0A     CALL 0x3014, 0
376A  F018     NOP
376C  D7FB     BRA 0x3764
376E  0012     RETURN 0
31F0  0E0E     MOVLW 0xE
31F2  6EF6     MOVWF TBLPTR, ACCESS
31F4  0E00     MOVLW 0x0
31F6  6EF7     MOVWF TBLPTRH, ACCESS
31F8  0E00     MOVLW 0x0
31FA  6EF8     MOVWF TBLPTRU, ACCESS
31FC  0101     MOVLB 0x1
31FE  0009     TBLRD*+
3200  50F5     MOVF TABLAT, W, ACCESS
3202  6F13     MOVWF 0x13, BANKED
3204  0009     TBLRD*+
3206  50F5     MOVF TABLAT, W, ACCESS
3208  6F14     MOVWF 0x14, BANKED
320A  E103     BNZ 0x3212
320C  6713     TSTFSZ 0x13, BANKED
320E  D001     BRA 0x3212
3210  D03D     BRA 0x328C
3212  0009     TBLRD*+
3214  50F5     MOVF TABLAT, W, ACCESS
3216  6F0E     MOVWF 0xE, BANKED
3218  0009     TBLRD*+
321A  50F5     MOVF TABLAT, W, ACCESS
321C  6F0F     MOVWF 0xF, BANKED
321E  0009     TBLRD*+
3220  50F5     MOVF TABLAT, W, ACCESS
3222  6F10     MOVWF 0x10, BANKED
3224  0009     TBLRD*+
3226  0009     TBLRD*+
3228  50F5     MOVF TABLAT, W, ACCESS
322A  6EE9     MOVWF FSR0, ACCESS
322C  0009     TBLRD*+
322E  50F5     MOVF TABLAT, W, ACCESS
3230  6EEA     MOVWF FSR0H, ACCESS
3232  0009     TBLRD*+
3234  0009     TBLRD*+
3236  0009     TBLRD*+
3238  50F5     MOVF TABLAT, W, ACCESS
323A  6F11     MOVWF 0x11, BANKED
323C  0009     TBLRD*+
323E  50F5     MOVF TABLAT, W, ACCESS
3240  6F12     MOVWF 0x12, BANKED
3242  0009     TBLRD*+
3244  0009     TBLRD*+
3246  CFF6     MOVFF TBLPTR, 0x115
3248  F115     NOP
324A  CFF7     MOVFF TBLPTRH, 0x116
324C  F116     NOP
324E  CFF8     MOVFF TBLPTRU, 0x117
3250  F117     NOP
3252  C10E     MOVFF 0x10E, TBLPTR
3254  FFF6     NOP
3256  C10F     MOVFF 0x10F, TBLPTRH
3258  FFF7     NOP
325A  C110     MOVFF 0x110, TBLPTRU
325C  FFF8     NOP
325E  0101     MOVLB 0x1
3260  5311     MOVF 0x11, F, BANKED
3262  E102     BNZ 0x3268
3264  5312     MOVF 0x12, F, BANKED
3266  E007     BZ 0x3276
3268  0009     TBLRD*+
326A  50F5     MOVF TABLAT, W, ACCESS
326C  6EEE     MOVWF POSTINC0, ACCESS
326E  0711     DECF 0x11, F, BANKED
3270  E2F8     BC 0x3262
3272  0712     DECF 0x12, F, BANKED
3274  D7F9     BRA 0x3268
3276  C115     MOVFF 0x115, TBLPTR
3278  FFF6     NOP
327A  C116     MOVFF 0x116, TBLPTRH
327C  FFF7     NOP
327E  C117     MOVFF 0x117, TBLPTRU
3280  FFF8     NOP
3282  0101     MOVLB 0x1
3284  0713     DECF 0x13, F, BANKED
3286  0E00     MOVLW 0x0
3288  5B14     SUBWFB 0x14, F, BANKED
328A  D7BF     BRA 0x320A
328C  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/proc/p18f87j50.asm  ---------------------------------
3734  0E40     MOVLW 0x40
3736  6EF3     MOVWF PROD, ACCESS
3738  EE00     LFSR 0, 0x0
373A  F000     NOP
373C  0E0F     MOVLW 0xF
373E  D801     RCALL zero_block
3740  0012     RETURN 0
3742  60EA     CPFSLT FSR0H, ACCESS
3744  D002     BRA compare_l
3746  6AEE     CLRF POSTINC0, ACCESS
3748  D7FC     BRA zero_block
374A  50F3     MOVF PROD, W, ACCESS
374C  60E9     CPFSLT FSR0, ACCESS
374E  0012     RETURN 0
3750  6AEE     CLRF POSTINC0, ACCESS
3752  D7FC     BRA loop_l
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/math/fxm1616u.asm  ----------------------------------
3588  C026     MOVFF 0x26, 0x30
358A  F030     NOP
358C  5026     MOVF 0x26, W, ACCESS
358E  022B     MULWF 0x2B, ACCESS
3590  CFF4     MOVFF PRODH, 0x25
3592  F025     NOP
3594  CFF3     MOVFF PROD, 0x24
3596  F024     NOP
3598  5027     MOVF 0x27, W, ACCESS
359A  022C     MULWF 0x2C, ACCESS
359C  CFF4     MOVFF PRODH, 0x27
359E  F027     NOP
35A0  CFF3     MOVFF PROD, 0x26
35A2  F026     NOP
35A4  022B     MULWF 0x2B, ACCESS
35A6  50F3     MOVF PROD, W, ACCESS
35A8  2625     ADDWF 0x25, F, ACCESS
35AA  50F4     MOVF PRODH, W, ACCESS
35AC  2226     ADDWFC 0x26, F, ACCESS
35AE  6AE8     CLRF WREG, ACCESS
35B0  2227     ADDWFC 0x27, F, ACCESS
35B2  5030     MOVF 0x30, W, ACCESS
35B4  022C     MULWF 0x2C, ACCESS
35B6  50F3     MOVF PROD, W, ACCESS
35B8  2625     ADDWF 0x25, F, ACCESS
35BA  50F4     MOVF PRODH, W, ACCESS
35BC  2226     ADDWFC 0x26, F, ACCESS
35BE  6AE8     CLRF WREG, ACCESS
35C0  2227     ADDWFC 0x27, F, ACCESS
35C2  0C00     RETLW 0x0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/math/fxd1616u.c  ------------------------------------
36C6  6A23     CLRF 0x23, ACCESS
36C8  6A22     CLRF 0x22, ACCESS
36CA  0E10     MOVLW 0x10
36CC  6EE7     MOVWF INDF1, ACCESS
36CE  90D8     BCF STATUS, 0, ACCESS
36D0  3626     RLCF 0x26, F, ACCESS
36D2  3627     RLCF 0x27, F, ACCESS
36D4  3622     RLCF 0x22, F, ACCESS
36D6  3623     RLCF 0x23, F, ACCESS
36D8  502B     MOVF 0x2B, W, ACCESS
36DA  5C22     SUBWF 0x22, W, ACCESS
36DC  502C     MOVF 0x2C, W, ACCESS
36DE  5823     SUBWFB 0x23, W, ACCESS
36E0  E305     BNC 0x36EC
36E2  502B     MOVF 0x2B, W, ACCESS
36E4  5E22     SUBWF 0x22, F, ACCESS
36E6  502C     MOVF 0x2C, W, ACCESS
36E8  5A23     SUBWFB 0x23, F, ACCESS
36EA  2A26     INCF 0x26, F, ACCESS
36EC  2EE7     DECFSZ INDF1, F, ACCESS
36EE  D7F0     BRA 0x36D0
36F0  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/delays/d1ktcyx.asm  ---------------------------------
3714  0EFF     MOVLW 0xFF
3716  50E3     MOVF PLUSW1, W, ACCESS
3718  6E42     MOVWF DelayCounter1, ACCESS
371A  0E48     MOVLW 0x48
371C  D001     BRA D1K_1
371E  0E4C     MOVLW 0x4C
3720  6EE7     MOVWF INDF1, ACCESS
3722  2EE7     DECFSZ INDF1, F, ACCESS
3724  D7FE     BRA 0x3722
3726  6AE7     CLRF INDF1, ACCESS
3728  2EE7     DECFSZ INDF1, F, ACCESS
372A  D7FE     BRA 0x3728
372C  2E42     DECFSZ DelayCounter1, F, ACCESS
372E  D7F7     BRA D1Kx
3730  0000     NOP
3732  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/delays/d10tcyx.asm  ---------------------------------
37D8  0EFF     MOVLW 0xFF
37DA  50E3     MOVF PLUSW1, W, ACCESS
37DC  4EE8     DCFSNZ WREG, F, ACCESS
37DE  0012     RETURN 0
37E0  0000     NOP
37E2  D000     BRA _D10TCYXCODE_000C
37E4  D000     BRA _D10TCYXCODE_000E
37E6  D000     BRA D10_1
37E8  2EE8     DECFSZ WREG, F, ACCESS
37EA  D7FA     BRA D10x
37EC  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/delays/d10ktcyx.asm  --------------------------------
3698  0EFF     MOVLW 0xFF
369A  50E3     MOVF PLUSW1, W, ACCESS
369C  6E42     MOVWF DelayCounter1, ACCESS
369E  0EEF     MOVLW 0xEF
36A0  D001     BRA D10K_1
36A2  0EF3     MOVLW 0xF3
36A4  6EE7     MOVWF INDF1, ACCESS
36A6  2EE7     DECFSZ INDF1, F, ACCESS
36A8  EF53     GOTO 0x36A6
36AA  F01B     NOP
36AC  0E0C     MOVLW 0xC
36AE  6E41     MOVWF DelayCounter2, ACCESS
36B0  6AE7     CLRF INDF1, ACCESS
36B2  2EE7     DECFSZ INDF1, F, ACCESS
36B4  EF59     GOTO 0x36B2
36B6  F01B     NOP
36B8  2E41     DECFSZ DelayCounter2, F, ACCESS
36BA  EF58     GOTO 0x36B0
36BC  F01B     NOP
36BE  2E42     DECFSZ DelayCounter1, F, ACCESS
36C0  EF51     GOTO 0x36A2
36C2  F01B     NOP
36C4  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcsetch.c  --------------------------------------
3668  CFD9     MOVFF FSR2, POSTINC1
366A  FFE6     NOP
366C  CFDA     MOVFF FSR2H, POSTINC1
366E  FFE6     NOP
3670  CFE1     MOVFF FSR1, FSR2
3672  FFD9     NOP
3674  CFE2     MOVFF FSR1H, FSR2H
3676  FFDA     NOP
3678  98C0     BCF WDTCON, 4, ACCESS
3680  0EFD     MOVLW 0xFD
3682  40DB     RRNCF PLUSW2, W, ACCESS
3684  0B7F     ANDLW 0x7F
3686  0B3C     ANDLW 0x3C
367A  0EC3     MOVLW 0xC3
367C  14C2     ANDWF ADCON0, W, ACCESS
367E  6E32     MOVWF __tmp_0, ACCESS
3688  1032     IORWF __tmp_0, W, ACCESS
368A  6EC2     MOVWF ADCON0, ACCESS
368C  52E5     MOVF POSTDEC1, F, ACCESS
368E  CFE5     MOVFF POSTDEC1, FSR2H
3690  FFDA     NOP
3692  CFE7     MOVFF INDF1, FSR2
3694  FFD9     NOP
3696  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcread.c  ---------------------------------------
37EE  50C4     MOVF ADRESH, W, ACCESS
37F0  6E35     MOVWF 0x35, ACCESS
37F2  6A34     CLRF 0x34, ACCESS
37F4  50C3     MOVF ADRES, W, ACCESS
37F6  1034     IORWF 0x34, W, ACCESS
37F8  6EF3     MOVWF PROD, ACCESS
37FA  C035     MOVFF 0x35, PRODH
37FC  FFF4     NOP
37FE  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcopen.c  ---------------------------------------
33B2  CFD9     MOVFF FSR2, POSTINC1
33B4  FFE6     NOP
33B6  CFDA     MOVFF FSR2H, POSTINC1
33B8  FFE6     NOP
33BA  CFE1     MOVFF FSR1, FSR2
33BC  FFD9     NOP
33BE  CFE2     MOVFF FSR1H, FSR2H
33C0  FFDA     NOP
33C2  98C0     BCF WDTCON, 4, ACCESS
33C4  6AC2     CLRF ADCON0, ACCESS
33C6  6AC1     CLRF ADCON1, ACCESS
33D4  0EFC     MOVLW 0xFC
33D6  40DB     RRNCF PLUSW2, W, ACCESS
33D8  0B7F     ANDLW 0x7F
33DA  0B3C     ANDLW 0x3C
33C8  0EFC     MOVLW 0xFC
33CA  50DB     MOVF PLUSW2, W, ACCESS
33CC  0D40     MULLW 0x40
33CE  50F3     MOVF PROD, W, ACCESS
33D0  0BC0     ANDLW 0xC0
33D2  6E32     MOVWF __tmp_0, ACCESS
33DC  1032     IORWF __tmp_0, W, ACCESS
33DE  6EC2     MOVWF ADCON0, ACCESS
33F6  0EFD     MOVLW 0xFD
33F8  50DB     MOVF PLUSW2, W, ACCESS
33FA  0B80     ANDLW 0x80
33EC  0EFD     MOVLW 0xFD
33EE  38DB     SWAPF PLUSW2, W, ACCESS
33F0  0B0F     ANDLW 0xF
33F2  0B07     ANDLW 0x7
33F4  6E32     MOVWF __tmp_0, ACCESS
33FC  1032     IORWF __tmp_0, W, ACCESS
33E0  0EFD     MOVLW 0xFD
33E2  50DB     MOVF PLUSW2, W, ACCESS
33E4  0D04     MULLW 0x4
33E6  50F3     MOVF PROD, W, ACCESS
33E8  0B38     ANDLW 0x38
33EA  6E33     MOVWF 0x33, ACCESS
33FE  1033     IORWF 0x33, W, ACCESS
3400  6EC1     MOVWF ADCON1, ACCESS
3402  88C0     BSF WDTCON, 4, ACCESS
3404  0EFA     MOVLW 0xFA
3406  50DB     MOVF PLUSW2, W, ACCESS
3408  6EC1     MOVWF ADCON1, ACCESS
340A  0EFA     MOVLW 0xFA
340C  CFDB     MOVFF PLUSW2, __tmp_0
340E  F032     NOP
3410  0EFB     MOVLW 0xFB
3412  CFDB     MOVFF PLUSW2, 0x33
3414  F033     NOP
3416  C033     MOVFF 0x33, __tmp_0
3418  F032     NOP
341A  6A33     CLRF 0x33, ACCESS
341C  5032     MOVF __tmp_0, W, ACCESS
341E  6EC2     MOVWF ADCON0, ACCESS
3420  98C0     BCF WDTCON, 4, ACCESS
3422  0EFC     MOVLW 0xFC
3424  AEDB     BTFSS PLUSW2, 7, ACCESS
3426  D003     BRA 0x342E
3428  9C9E     BCF PIR1, 6, ACCESS
342A  8C9D     BSF PIE1, 6, ACCESS
342C  8CF2     BSF INTCON, 6, ACCESS
342E  80C2     BSF ADCON0, 0, ACCESS
3430  52E5     MOVF POSTDEC1, F, ACCESS
3432  CFE5     MOVFF POSTDEC1, FSR2H
3434  FFDA     NOP
3436  CFE7     MOVFF INDF1, FSR2
3438  FFD9     NOP
343A  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcconv.c  ---------------------------------------
380C  98C0     BCF WDTCON, 4, ACCESS
380E  82C2     BSF ADCON0, 1, ACCESS
3810  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcbusy.c  ---------------------------------------
3800  98C0     BCF WDTCON, 4, ACCESS
3802  50C2     MOVF ADCON0, W, ACCESS
3804  0B02     ANDLW 0x2
3806  E001     BZ 0x380A
3808  0E01     MOVLW 0x1
380A  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Task_outs/task_outs.c  ---------------------------
1:             #include "module_indication.h"
2:             #include "module_fan.h"
3:             #include "module_sound.h"
4:             #include "OSA.h"
5:             #include "task_outs.h"
6:             #include <p18cxxx.h>
7:             
8:             /*
9:             Задача управления логическими выходами
10:            Работают алгоритмы управления индикацией, вентилятором, звуком
11:            */
12:            
13:            
14:            void Task_Outs(void)
15:            {
16:            	for (;;) 
3710  D7F0     BRA Task_Outs
17:            	{ 
18:            		
19:            		M_Ind_Run();
36F2  EC9D     CALL 0xF3A, 0
36F4  F007     NOP
20:            		M_fan_run();
36F6  EC71     CALL 0x2EE2, 0
36F8  F017     NOP
21:            		M_Sound_run();
36FA  EC9E     CALL 0x313C, 0
36FC  F018     NOP
22:            		ClrWdt();
36FE  0004     CLRWDT
23:                    OS_Delay(TIMEOUT_TASK_OUTS);
3700  0E01     MOVLW 0x1
3702  6EE6     MOVWF POSTINC1, ACCESS
3704  EC6B     CALL 0x28D6, 0
3706  F014     NOP
3708  52E5     MOVF POSTDEC1, F, ACCESS
370A  EC3D     CALL 0x287A, 0
370C  F014     NOP
370E  0000     NOP
24:            	}
25:            }
3712  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Task_motors/task_motors.c  -----------------------
1:             #include "OSA.h"
2:             #include "task_motors.h"
3:             #include "module_motor.h"
4:             #include <p18cxxx.h>
5:             
6:             void Task_Motors(void)
7:             {
8:             	for (;;) 
3786  D7F4     BRA Task_Motors
9:             	{ 
10:            		
11:            		M_Motor_Run();
3770  EC42     CALL 0x484, 0
3772  F002     NOP
12:            		ClrWdt();
3774  0004     CLRWDT
13:                    OS_Delay(TIMEOUT_TASK_MOTORS);
3776  0E01     MOVLW 0x1
3778  6EE6     MOVWF POSTINC1, ACCESS
377A  EC6B     CALL 0x28D6, 0
377C  F014     NOP
377E  52E5     MOVF POSTDEC1, F, ACCESS
3780  EC3D     CALL 0x287A, 0
3782  F014     NOP
3784  0000     NOP
14:            	}
15:            }
3788  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Task_management/task_management.c  ---------------
1:             #include "module_management.h"
2:             #include "task_management.h"
3:             #include "module_motor.h"
4:             #include "OSA.h"
5:             #include <p18cxxx.h>
6:             
7:             void Task_Management(void)
8:             {
9:             	for (;;) 
37A0  D7F4     BRA Task_Management
10:            	{ 
11:                    M_Mngm_Run ();
378A  ECB2     CALL 0x1764, 0
378C  F00B     NOP
12:            		ClrWdt();
378E  0004     CLRWDT
13:                    OS_Delay(TIMEOUT_TASK_MANAGEMENT);
3790  0E64     MOVLW 0x64
3792  6EE6     MOVWF POSTINC1, ACCESS
3794  EC6B     CALL 0x28D6, 0
3796  F014     NOP
3798  52E5     MOVF POSTDEC1, F, ACCESS
379A  EC3D     CALL 0x287A, 0
379C  F014     NOP
379E  0000     NOP
14:            	}
15:            }
37A2  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Task_logic_inputs/task_logic_inputs.c  -----------
1:             #include "task_logic_inputs.h"
2:             #include "module_logic_inputs.h"
3:             #include "OSA.h"
4:             #include <p18cxxx.h>
5:             
6:             void Task_Logic_Inputs(void)
7:             {
8:             	for (;;) 
37BA  D7F4     BRA Task_Logic_Inputs
9:             	{ 
10:            		
11:            		M_LI_Run();
37A4  EC07     CALL 0x280E, 0
37A6  F014     NOP
12:            		ClrWdt();
37A8  0004     CLRWDT
13:                    OS_Delay(TIMEOUT_TASK_LOGIC_INPUTS);
37AA  0E01     MOVLW 0x1
37AC  6EE6     MOVWF POSTINC1, ACCESS
37AE  EC6B     CALL 0x28D6, 0
37B0  F014     NOP
37B2  52E5     MOVF POSTDEC1, F, ACCESS
37B4  EC3D     CALL 0x287A, 0
37B6  F014     NOP
37B8  0000     NOP
14:            	}
15:            }
37BC  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Task_analog_inputs/task_analog_inputs.c  ---------
1:             #include "task_analog_inputs.h"
2:             #include "module_analog_inputs.h"
3:             #include "OSA.h"
4:             #include <p18cxxx.h>
5:             
6:             void Task_Analog_Inputs(void)
7:             {
8:             	for (;;) 
37D4  D7F4     BRA Task_Analog_Inputs
9:             	{ 
10:            			
11:            		M_AI_Run();
37BE  ECEE     CALL 0x23DC, 0
37C0  F011     NOP
12:            		ClrWdt();
37C2  0004     CLRWDT
13:                    OS_Delay(TIMEOUT_TASK_ANALOG_INPUTS);
37C4  0E01     MOVLW 0x1
37C6  6EE6     MOVWF POSTINC1, ACCESS
37C8  EC6B     CALL 0x28D6, 0
37CA  F014     NOP
37CC  52E5     MOVF POSTDEC1, F, ACCESS
37CE  EC3D     CALL 0x287A, 0
37D0  F014     NOP
37D2  0000     NOP
14:            	}
15:            }
37D6  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/OSA/port/pic18/osa_pic18_mplabc.c  ---------------
1:             /*
2:              ************************************************************************************************
3:              *
4:              *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8
5:              *
6:              *  OSA is distributed under BSD license (see license.txt)
7:              *
8:              *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro
9:              *
10:             *----------------------------------------------------------------------------------------------
11:             *
12:             *  File:           osa_pic18_mplabc.c
13:             *
14:             *  Compilers:      Mplab C18
15:             *
16:             *  Programmer:     Timofeev Victor
17:             *                  osa@pic24.ru, testerplus@mail.ru
18:             *
19:             *  Description:    MPLABC18 specific functions definition
20:             *                  This file directly included in osa.c
21:             *
22:             *  History:        10.09.2010 -    File updated
23:             *
24:             ************************************************************************************************
25:             */
26:            
27:            
28:            
29:            
30:            #define _OS_INIT_PROC_SPEC()      // Empty macro for MCC18
31:            
32:            
33:            
34:            
35:            
36:            
37:            /************************************************************************************************
38:             *                                                                                              *
39:             *                           K E R N E L   F U N C T I O N S                                    *
40:             *                                                                                              *
41:             ************************************************************************************************/
42:            
43:            
44:            void _OS_ClrReadySetClrCanContinue (void);  /* see description below    */
45:            
46:            
47:            
48:            void _OS_JumpToTask (void)
49:            {
50:                _OS_SET_FSR_CUR_TASK_W(OS_CODE_POINTER_SIZE + _OS_TASK_POINTER_OFFSET);
2858  0E03     MOVLW 0x3
285A  D839     RCALL __OS_SET_FSR_CUR_TASK_W
51:            
52:                if (_indf)
285C  50EF     MOVF INDF0, W, ACCESS
285E  E004     BZ 0x2868
53:                {
54:                    _indf1 = _fsr2l;
2860  50D9     MOVF FSR2, W, ACCESS
2862  6EE7     MOVWF INDF1, ACCESS
55:                    _fsr2l = _fsr1l + 1;
2864  28E1     INCF FSR1, W, ACCESS
2866  6ED9     MOVWF FSR2, ACCESS
56:                }
57:                _OS_TempH = _fsr1l;
2868  50E1     MOVF FSR1, W, ACCESS
286A  6E3C     MOVWF _OS_TempH, ACCESS
58:                _fsr1l += _postdec;
286C  50ED     MOVF POSTDEC0, W, ACCESS
286E  26E1     ADDWF FSR1, F, ACCESS
59:                _OS_SET_PC();
2870  50ED     MOVF POSTDEC0, W, ACCESS
2872  6EFA     MOVWF PCLATH, ACCESS
2874  50ED     MOVF POSTDEC0, W, ACCESS
2876  6EF9     MOVWF PCL, ACCESS
60:                /* Now FSR points to OS_CurTask->State    */
61:            }
2878  0012     RETURN 0
62:            
63:            
64:            
65:            
66:            
67:            /*
68:             ********************************************************************************
69:             *
70:             *  void _OS_ReturnSave (void)
71:             *
72:             *------------------------------------------------------------------------------
73:             *
74:             *  description:    Return to sheduler with saving current task return point
75:             *
76:             *  parameters:     none
77:             *
78:             *  on return:      none
79:             *
80:             ********************************************************************************
81:             */
82:            
83:            void _OS_ReturnSave (void)
84:            {
85:                _OS_SET_FSR_CUR_TASK_W(OS_CODE_POINTER_SIZE + _OS_TASK_POINTER_OFFSET);
287A  0E03     MOVLW 0x3
287C  D828     RCALL __OS_SET_FSR_CUR_TASK_W
86:                _postdec = _fsr1l - _OS_TempH;
287E  503C     MOVF _OS_TempH, W, ACCESS
2880  5CE1     SUBWF FSR1, W, ACCESS
2882  6EED     MOVWF POSTDEC0, ACCESS
87:            
88:                _OS_SAVE_PC();
2884  50FE     MOVF TOSH, W, ACCESS
2886  6EED     MOVWF POSTDEC0, ACCESS
2888  50FD     MOVF TOS, W, ACCESS
288A  6EED     MOVWF POSTDEC0, ACCESS
89:            
90:                _OS_bTaskReady = 1;
288C  86EF     BSF INDF0, 3, ACCESS
91:            
92:                _OS_POP();
288E  0006     POP
93:            }
2890  0012     RETURN 0
94:            
95:            
96:            
97:            /*
98:             ********************************************************************************
99:             *
100:            *  void _OS_ReturnNoSave (void)
101:            *
102:            *------------------------------------------------------------------------------
103:            *
104:            *  description:    Return to scheduler without saving context
105:            *
106:            *  parameters:     none
107:            *
108:            *  on return:      none
109:            *
110:            ********************************************************************************
111:            */
112:           
113:           void _OS_ReturnNoSave (void)
114:           {
115:               _OS_POP();
2892  0006     POP
116:           }
2894  0012     RETURN 0
117:           
118:           
119:           /*
120:            ********************************************************************************
121:            *
122:            *  void __OS_EnterWaitMode (void)
123:            *
124:            *------------------------------------------------------------------------------
125:            *
126:            *  description:    Clear bReady flag and return to the sheduler with seaving
127:            *                  task return point
128:            *
129:            *  parameters:     none
130:            *
131:            *  on return:      none
132:            *
133:            *
134:            ********************************************************************************
135:            */
136:           
137:           void _OS_EnterWaitMode (void)
138:           {
139:               _OS_Temp = 0;
2896  6A3B     CLRF _OS_Temp, ACCESS
140:               _asm    goto    _OS_ClrReadySetClrCanContinue   _endasm
2898  EF53     GOTO 0x28A6
289A  F014     NOP
141:           }
289C  0012     RETURN 0
142:           
143:           
144:           /*
145:            ********************************************************************************
146:            *
147:            *  void __OS_EnterWaitModeTO (void)
148:            *
149:            *------------------------------------------------------------------------------
150:            *
151:            *  description:    Clear bReady flag, set bCanContinue flag and return to the
152:            *                  sheduler with seaving task return point
153:            *
154:            *  parameters:     none
155:            *
156:            *  on return:      none
157:            *
158:            *
159:            ********************************************************************************
160:            */
161:           
162:           void _OS_EnterWaitModeTO (void)
163:           {
164:               _OS_Temp = 0xFF;
289E  683B     SETF _OS_Temp, ACCESS
165:               _asm    goto    _OS_ClrReadySetClrCanContinue   _endasm
28A0  EF53     GOTO 0x28A6
28A2  F014     NOP
166:           }
28A4  0012     RETURN 0
167:           
168:           
169:           /*
170:            ********************************************************************************
171:            *
172:            *  void _OS_ClrReadySetClrCanContinue (void)
173:            *
174:            *------------------------------------------------------------------------------
175:            *
176:            *  description:    Addition function. Called only by GOTO from:
177:            *                      _OS_EnterWaitMode()
178:            *                      _OS_EnterWaitModeTO()
179:            *                  Stack has pointer of task who called theese services.
180:            *
181:            *  parameters:     none
182:            *
183:            *  on return:      none
184:            *
185:            ********************************************************************************
186:            */
187:           
188:           void _OS_ClrReadySetClrCanContinue (void)
189:           {
190:           
191:           
192:               _OS_Flags.bEventError = 0;
28A6  903A     BCF _OS_Flags, 0, ACCESS
193:           
194:               _OS_SET_FSR_CUR_TASK_W(OS_CODE_POINTER_SIZE + _OS_TASK_POINTER_OFFSET);
28A8  0E03     MOVLW 0x3
28AA  D811     RCALL __OS_SET_FSR_CUR_TASK_W
195:               _postdec = _fsr1l - _OS_TempH;
28AC  503C     MOVF _OS_TempH, W, ACCESS
28AE  5CE1     SUBWF FSR1, W, ACCESS
28B0  6EED     MOVWF POSTDEC0, ACCESS
196:               _OS_SAVE_PC();
28B2  50FE     MOVF TOSH, W, ACCESS
28B4  6EED     MOVWF POSTDEC0, ACCESS
28B6  50FD     MOVF TOS, W, ACCESS
28B8  6EED     MOVWF POSTDEC0, ACCESS
197:               _OS_bTaskReady = 0;
28BA  96EF     BCF INDF0, 3, ACCESS
198:           
199:               #if defined(OS_ENABLE_TTIMERS)
200:                   if (!_OS_bTaskDelay) _OS_bTaskCanContinue = 0;
28BC  A8EF     BTFSS INDF0, 4, ACCESS
28BE  9AEF     BCF INDF0, 5, ACCESS
201:                   if (_OS_Temp & 0x01) _OS_bTaskCanContinue = 1;
28C0  B03B     BTFSC _OS_Temp, 0, ACCESS
28C2  8AEF     BSF INDF0, 5, ACCESS
202:               #endif
203:           
204:           }
28C4  0012     RETURN 0
205:           
206:           
207:           
208:           
209:           
210:           
211:           
212:           
213:           
214:           
215:           
216:           /************************************************************************************************
217:            *                                                                                              *
218:            *  MAKE FSR POINTER TO OS_CUR_TASK                                                             *
219:            *                                                                                              *
220:            *  (for code reducing)                                                                         *
221:            *                                                                                              *
222:            ************************************************************************************************/
223:           
224:           void _OS_SET_FSR_CUR_TASK (void)
225:           {
226:               _asm
227:                   movlw   0
28C6  0E00     MOVLW 0x0
228:                   goto __OS_SET_FSR_CUR_TASK_W
28C8  EF67     GOTO 0x28CE
28CA  F014     NOP
229:               _endasm
230:           }
28CC  0012     RETURN 0
231:           
232:           
233:           void __OS_SET_FSR_CUR_TASK_W (void)
234:           {
235:               _asm
236:                   addwf   _OS_CurTask + 0, 0, 0
28CE  243D     ADDWF _OS_CurTask, W, ACCESS
237:                   movwf   _fsr + 0, 0
28D0  6EE9     MOVWF FSR0, ACCESS
238:                   #if OS_BANK_TASKS == 0
239:                       clrf    _fsr + 1, 0
28D2  6AEA     CLRF FSR0H, ACCESS
240:                   #else
241:                       movlw   0
242:                       addwfc  _OS_CurTask + 1, 0, 0
243:                       movwf   _fsr + 1, 0
244:                   #endif
245:               _endasm
246:           }
28D4  0012     RETURN 0
247:           
248:           
249:           
250:           
251:           
252:           /*
253:            ************************************************************************************************
254:            *                                                                                              *
255:            *                                   D E L A Y S   I N   T A S K                                *
256:            *                                                                                              *
257:            ************************************************************************************************
258:            */
259:           
260:           //------------------------------------------------------------------------------
261:           #ifdef OS_ENABLE_TTIMERS
262:           //------------------------------------------------------------------------------
263:           
264:           /*
265:            ********************************************************************************
266:            *
267:            *   void _OS_InitDelay (OS_TTIMER_TYPE Delay)
268:            *
269:            *------------------------------------------------------------------------------
270:            *
271:            *  description:    (Internal function called by system kernel)
272:            *
273:            *                  Init task timer delay.Set timer variable in task descriptor,
274:            *                  sets bit bDelay and clears bit bCanContinue.
275:            *
276:            *                  _OS_CurTask must point to descriptor.
277:            *
278:            *
279:            *  parameters:     Delay   - time of delay in system ticks
280:            *
281:            *  on return:      none
282:            *
283:            *  note:           This function overloads "osa.c"
284:            *
285:            ********************************************************************************
286:            */
287:           
288:           //------------------------------------------------------------------------------
289:           #define _OS_InitDelay_DEFINED
290:           //------------------------------------------------------------------------------
291:           
292:           void _OS_InitDelay (OS_TTIMER_TYPE Delay)
28D6  CFD9     MOVFF FSR2, POSTINC1
28D8  FFE6     NOP
28DA  CFE1     MOVFF FSR1, FSR2
28DC  FFD9     NOP
28DE  52E6     MOVF POSTINC1, F, ACCESS
293:           {
294:           
295:               char temp;
296:               temp = 0;               // This variable used to prevent FSR changing
28E0  6ADF     CLRF INDF2, ACCESS
297:               if (Delay) temp = 1;    // when checking Delay after FSR set to task->Timer
28E2  0EFE     MOVLW 0xFE
28E4  50DB     MOVF PLUSW2, W, ACCESS
28E6  E002     BZ 0x28EC
28E8  0E01     MOVLW 0x1
28EA  6EDF     MOVWF INDF2, ACCESS
298:                                       // See "if (temp & 1)" below
299:           
300:               _OS_SET_FSR_CUR_TASK();
28EC  DFEC     RCALL _OS_SET_FSR_CUR_TASK
301:               _OS_bTaskCanContinue = 0;
28EE  9AEF     BCF INDF0, 5, ACCESS
302:               _OS_bTaskDelay = 0;     // Clear bDelay to prevent timer changing in interrupt
28F0  98EF     BCF INDF0, 4, ACCESS
303:           
304:               if (temp & 1)
28F2  A0DF     BTFSS INDF2, 0, ACCESS
28F4  D011     BRA 0x2918
305:               {
306:           
307:                   Delay ^= -1;
28F6  0EFE     MOVLW 0xFE
28F8  1EDB     COMF PLUSW2, F, ACCESS
308:                   Delay ++;
28FA  2ADB     INCF PLUSW2, F, ACCESS
309:           
310:                   _OS_CurTask->Timer = Delay;
28FC  C03D     MOVFF _OS_CurTask, FSR0
28FE  FFE9     NOP
2900  C03E     MOVFF 0x3E, FSR0H
2902  FFEA     NOP
2904  0E04     MOVLW 0x4
2906  26E9     ADDWF FSR0, F, ACCESS
2908  0E00     MOVLW 0x0
290A  22EA     ADDWFC FSR0H, F, ACCESS
290C  0EFE     MOVLW 0xFE
290E  CFDB     MOVFF PLUSW2, INDF0
2910  FFEF     NOP
311:                   _OS_SET_FSR_CUR_TASK();
2912  DFD9     RCALL _OS_SET_FSR_CUR_TASK
312:                   _OS_bTaskDelay = 1;
2914  88EF     BSF INDF0, 4, ACCESS
313:                   _OS_bTaskReady = 1;
2916  86EF     BSF INDF0, 3, ACCESS
314:           
315:               }
316:           }
2918  52E5     MOVF POSTDEC1, F, ACCESS
291A  52E5     MOVF POSTDEC1, F, ACCESS
291C  CFE7     MOVFF INDF1, FSR2
291E  FFD9     NOP
2920  0012     RETURN 0
317:           
318:           //------------------------------------------------------------------------------
319:           #endif  // #ifdef OS_ENABLE_TTIMERS
320:           //------------------------------------------------------------------------------
321:           
322:           
323:           
324:           
325:           
326:           
327:           
328:           
329:           
330:           
331:           
332:           
333:           
334:           
335:           
336:           
337:           
338:           
339:           
340:           
341:           
342:           
343:           
344:           
345:           
346:           
347:           
348:           
349:           
350:           
351:           
352:           
353:           
354:           
355:           
356:           
357:           
358:           
359:           
360:           
361:           
362:           
363:           
364:           
365:           
366:           
367:           
368:           /************************************************************************************************
369:            *                                                                                              *
370:            *                            S Y S T E M   F U N C T I O N S                                   *
371:            *                                                                                              *
372:            ************************************************************************************************/
373:           
374:           
375:           
376:           
377:           
378:           
379:           /*
380:            ********************************************************************************
381:            *
382:            *  char OS_DI (void)
383:            *
384:            *------------------------------------------------------------------------------
385:            *
386:            *  description:    Disable interrupt with GIE saving
387:            *
388:            *  parameters:     none
389:            *
390:            *  on return:      char - bit 7 = previous GIEH value,
391:            *                         bit 6 = previous GIEL value
392:            *                         bits 0..5 = 0
393:            *
394:            ********************************************************************************
395:            */
396:           
397:           //-------------------------------------------------------------------------------
398:           #define OS_DI_DEFINED
399:           //-------------------------------------------------------------------------------
400:           
401:           char OS_DI (void)
402:           {
403:               _asm
404:                   movf    _intcon, 0, 0
2922  50F2     MOVF INTCON, W, ACCESS
405:                   andlw   0xC0
2924  0BC0     ANDLW 0xC0
406:                   bcf     _intcon, 7, 0
2926  9EF2     BCF INTCON, 7, ACCESS
407:                   btfsc   _rcon, 7, 0
2928  BED0     BTFSC RCON, 7, ACCESS
408:                   bcf     _intcon, 6, 0
292A  9CF2     BCF INTCON, 6, ACCESS
409:               _endasm
410:           }
292C  0012     RETURN 0
411:           
412:           //------------------------------------------------------------------------------
413:           #if defined(OS_ENABLE_INT)
414:           //------------------------------------------------------------------------------
415:           
416:               void _OS_DI_INT (void)
417:               {
418:                   _asm
419:                       movf    _intcon, 0, 0
420:                       andlw   0xC0
421:                       bcf     _intcon, 7, 0
422:                       btfsc   _rcon, 7, 0
423:                       bcf     _intcon, 6, 0
424:                       movwf   _OS_Temp_I, 0
425:                   _endasm
426:               }
427:           
428:           //------------------------------------------------------------------------------
429:           #endif
430:           //------------------------------------------------------------------------------
431:           
432:           /*
433:            ********************************************************************************
434:            *
435:            *  char OS_RI (void)
436:            *
437:            *------------------------------------------------------------------------------
438:            *
439:            *  description:    Restore saved by OS_DI() GIEx states
440:            *
441:            *  parameters:     char - bit 7 = previos GIE value, bits 0..6 = 0
442:            *
443:            *  on return:      none
444:            *
445:            ********************************************************************************
446:            */
447:           
448:           //-------------------------------------------------------------------------------
449:           #define OS_RI_DEFINED
450:           //-------------------------------------------------------------------------------
451:           
452:           void _OS_RI ()
453:           {
454:               _asm
455:                   btfsc   _wreg, 7, 0
292E  BEE8     BTFSC WREG, 7, ACCESS
456:                   bsf     _intcon, 7, 0
2930  8EF2     BSF INTCON, 7, ACCESS
457:                   btfsc   _rcon, 7, 0
2932  BED0     BTFSC RCON, 7, ACCESS
458:                   btfss   _wreg, 6, 0
2934  ACE8     BTFSS WREG, 6, ACCESS
459:                   bra     _RI_EXIT
2936  D001     BRA 0x293A
460:                   bsf     _intcon, 6, 0
2938  8CF2     BSF INTCON, 6, ACCESS
461:               _RI_EXIT:
462:               _endasm
463:           
464:           }
293A  0012     RETURN 0
465:           
466:           //------------------------------------------------------------------------------
467:           #if defined(OS_ENABLE_INT)
468:           //------------------------------------------------------------------------------
469:           
470:               void _OS_RI_INT ()
471:               {
472:                   _asm
473:                       btfsc   _OS_Temp_I, 7, 0
474:                       bsf     _intcon, 7, 0
475:                       btfsc   _rcon, 7, 0
476:                       btfss   _OS_Temp_I, 6, 0
477:                       bra     _RI_INT_EXIT
478:                       bsf     _intcon, 6, 0
479:                   _RI_INT_EXIT:
480:                   _endasm
481:           
482:               }
483:           
484:           //------------------------------------------------------------------------------
485:           #endif
486:           //------------------------------------------------------------------------------
487:           
488:           
489:           
490:           
491:           
492:           
493:           
494:           
495:           
496:           
497:           
498:           /*
499:            ********************************************************************************
500:            *
501:            *  void _OS_CheckEvent (char bEvent)
502:            *
503:            *------------------------------------------------------------------------------
504:            *
505:            *  description:    (Internal function called by system kernel througth
506:            *                  waiting services)
507:            *
508:            *                  Check condition of bEvent. Accordint to bEvent value and
509:            *                  current state of bReady, bDelay and bCanContinue flags,
510:            *                  task becames ready to execute or still remains in waiting
511:            *                  mode.
512:            *
513:            *  parameters:     bEvent (passing througth _OS_TempH)
514:            *                  - zero, or non-zero condition
515:            *
516:            *
517:            *  on return:      none
518:            *
519:            *  note:           This function overloads "osa.c"
520:            *
521:            ********************************************************************************
522:            */
523:           
524:           //------------------------------------------------------------------------------
525:           #define _OS_CheckEvent_DEFINED
526:           //------------------------------------------------------------------------------
527:           
528:           #define bEvent  _OS_Temp
529:           
530:           void _OS_CheckEvent (void)
531:           {
532:               //------------------------------------------------------------------------------
533:               #if OS_PRIORITY_LEVEL == OS_PRIORITY_DISABLED
534:               //------------------------------------------------------------------------------
535:           
536:                   _OS_Flags.bTimeout = 0;
537:                   _OS_SET_FSR_CUR_TASK();
538:           
539:                   if (bEvent)
540:                   {
541:                       #ifdef OS_ENABLE_TTIMERS
542:                           _OS_bTaskDelay = 0;
543:                       #endif
544:           
545:                       return;
546:                   }
547:           
548:                   #ifdef OS_ENABLE_TTIMERS
549:           
550:                       if (_OS_bTaskTimeout && _OS_bTaskCanContinue)
551:                       {
552:                           _OS_Flags.bTimeout = 1;
553:           
554:                           return;
555:                       }
556:           
557:                   #endif
558:           
559:                   _OS_POP();
560:           
561:               //------------------------------------------------------------------------------
562:               #else
563:               //------------------------------------------------------------------------------
564:           
565:                   _OS_Flags.bTimeout = 0;
293C  9A3A     BCF _OS_Flags, 5, ACCESS
566:                   _OS_SET_FSR_CUR_TASK();
293E  DFC3     RCALL _OS_SET_FSR_CUR_TASK
567:           
568:                   if (bEvent)
2940  503B     MOVF _OS_Temp, W, ACCESS
2942  E006     BZ 0x2950
569:                   {
570:                       if (_OS_bTaskReady)
2944  A6EF     BTFSS INDF0, 3, ACCESS
2946  D002     BRA 0x294C
571:                       {
572:                           #ifdef OS_ENABLE_TTIMERS
573:                           _OS_bTaskDelay = 0;
2948  98EF     BCF INDF0, 4, ACCESS
574:                           #endif
575:           
576:                           #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED
577:                           _OS_Flags.bEventOK = 1;
578:                           #endif
579:           
580:                           return;
294A  D00D     BRA 0x2966
581:                       }
582:           
583:                       _OS_bTaskReady = 1;
294C  86EF     BSF INDF0, 3, ACCESS
584:           
585:                   } else {
294E  D001     BRA 0x2952
586:                       _OS_bTaskReady = 0;
2950  96EF     BCF INDF0, 3, ACCESS
587:                   }
588:           
589:                   #ifdef OS_ENABLE_TTIMERS
590:           
591:                       if (_OS_bTaskTimeout && _OS_bTaskCanContinue)
2952  50EF     MOVF INDF0, W, ACCESS
2954  0B10     ANDLW 0x10
2956  E106     BNZ 0x2964
2958  50EF     MOVF INDF0, W, ACCESS
295A  0B20     ANDLW 0x20
295C  E003     BZ 0x2964
592:                       {
593:                           _OS_bTaskReady = 1;
295E  86EF     BSF INDF0, 3, ACCESS
594:                           _OS_Flags.bTimeout = 1;
2960  8A3A     BSF _OS_Flags, 5, ACCESS
595:           
596:                           #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED
597:                           _OS_Flags.bEventOK = 1;
598:                           #endif
599:           
600:                           return;
2962  D001     BRA 0x2966
601:                       }
602:           
603:                   #endif
604:           
605:                   _OS_POP();
2964  0006     POP
606:           
607:               //------------------------------------------------------------------------------
608:               #endif
609:               //------------------------------------------------------------------------------
610:           }
2966  0012     RETURN 0
611:           
612:           
613:           
614:           
615:           
616:           //------------------------------------------------------------------------------
617:           #if (OS_STIMERS > 0 ) && defined(OS_STIMERS_ENABLE_ALLOCATION)
618:           //------------------------------------------------------------------------------
619:           
620:           /*
621:            ********************************************************************************
622:            *
623:            *  _OS_Stimer_GetFree
624:            *
625:            *------------------------------------------------------------------------------
626:            *
627:            *  description:    (Internal function called by system kernel througth service OS
628:            *                  Searches free static timer and returns it's ID
629:            *
630:            *
631:            *  parameters:     OST_UINT bCreate - =0 - do not created timer, just check for
632:            *                                               aviability
633:            *                                          =1 - create timer and mark it asm used
634:            *
635:            *  on return:      none
636:            *
637:            *  Overloaded in:  osa_pic18_htpicc.c
638:            *
639:            ********************************************************************************
640:            */
641:           
642:           //-----------------------------------------------------------------
643:           #define _OS_Stimer_GetFree_DEFINED
644:           //-----------------------------------------------------------------
645:           
646:           OST_UINT8   _OS_Stimer_GetFree (OST_UINT bCreate)
647:           {
648:               _OS_Flags.bError = 0;
649:               _fsr = (OS_FSR_TYPE)_OS_StimersFree;
650:               _OS_Temp = (OS_STIMERS >> 3) + 1;
651:               do
652:               {
653:                   if (_indf)
654:                   {
655:                       if (!(bCreate & 1)) return 0;
656:           
657:                       _asm
658:                           movlw   _OS_StimersFree
659:                           subwf   _fsr, 0, 0
660:                           rlcf    _wreg, 1, 0
661:                           rlcf    _wreg, 1, 0
662:                           rlcf    _wreg, 0, 0
663:                           andlw   0xF8
664:           
665:                           movff   _indf, _OS_TempH  // Search for first "1" in _indf
666:                           movwf   _OS_Temp, 0
667:                           movlw   1
668:                        OS_ST_GF_REPEAT:
669:                           rrcf    _OS_TempH, 1, 0
670:                           bc      OS_ST_GF_OK
671:                           rlcf    _wreg, 1, 0
672:                           incf    _OS_Temp, 1, 0
673:                           bra     OS_ST_GF_REPEAT
674:                        OS_ST_GF_OK:
675:           
676:                           xorwf  _indf, 1, 0         // Clear bit of selected timer
677:           
678:                       _endasm
679:                       return _OS_Temp;
680:           
681:                   }
682:                   _fsr++;
683:               } while (--_OS_Temp);
684:           
685:               _OS_Flags.bError = 1;
686:               return 0xFF;
687:           }
688:           
689:           
690:           void    _OS_Stimer_Free (OST_UINT8 ID)
691:           {
692:               _OS_Temp = ID;
693:               _asm
694:               __OS_Stimer_Free:
695:                   lfsr    0, _OS_StimersFree
696:                   movf    _OS_Temp, 0, 0
697:                   rrcf    _wreg, 0, 0          //  wreg = ID / 8
698:                   rrcf    _wreg, 0, 0
699:                   rrcf    _wreg, 0, 0
700:                   andlw   0x1F
701:                   addwf   _fsr, 1, 0
702:           
703:                   movlw   0x01                  // W = 1 << (ID & 7)
704:                   btfsc   _OS_Temp, 2, 0
705:                   swapf   _wreg, 0, 0
706:                   btfsc   _OS_Temp, 1, 0
707:                   rlcf    _wreg, 0, 0
708:                   btfsc   _OS_Temp, 1, 0
709:                   rlcf    _wreg, 0, 0
710:                   btfsc   _OS_Temp, 0, 0
711:                   rlcf    _wreg, 0, 0
712:                   iorwf   _indf, 1, 0          // Free timer
713:               _endasm
714:               return   ;
715:           }
716:           //------------------------------------------------------------------------------
717:           #endif      //  OS_STIMERS_ENABLE_ALLOCATION
718:           //-----------------------------------------------------------------
719:           
720:           
721:           
722:           //******************************************************************************
723:           //  END OF FILE osa_pic18_mplabc.c
724:           //******************************************************************************
725:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/OSA/kernel/system/osa_tasks.c  -------------------
1:             /*
2:              ************************************************************************************************
3:              *
4:              *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8
5:              *
6:              *  OSA is distributed under BSD license (see license.txt)
7:              *
8:              *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro
9:              *
10:             *----------------------------------------------------------------------------------------------
11:             *
12:             *  File:           osa_tasks.c
13:             *
14:             *  Programmer:     Timofeev Victor
15:             *                  osa@pic24.ru, testerplus@mail.ru
16:             *
17:             *  Description:    Functions and variables for Tasks.
18:             *                  This file directly included in osa.c
19:             *
20:             *  History:        12.09.2010 -    File updated
21:             *
22:             ************************************************************************************************
23:             */
24:            
25:            
26:            
27:            
28:            //******************************************************************************
29:            //  Task descriptors
30:            //******************************************************************************
31:            
32:            #if (OS_BANK_TASKS == 0) && defined(__OSA_PIC18_MPLABC__)
33:            #pragma udata access os_bsems
34:            #endif
35:            
36:            OS_TASKS_BANK  OST_TCB  _OS_Tasks[OS_TASKS] OS_ALLOCATION_TASKS;
37:            
38:            #if (OS_BANK_TASKS == 0) && defined(__OSA_PIC18_MPLABC__)
39:            #pragma udata
40:            #endif
41:            
42:            
43:            
44:            /*
45:             ********************************************************************************
46:             *
47:             *   void             _OS_Task_Create(OST_WORD    priority,
48:             *                                    OST_CODE_POINTER TaskAddr)
49:             *
50:             *------------------------------------------------------------------------------
51:             *
52:             *   description:   (Internal function called by system kernel from service
53:             *                  OS_Task_Create)
54:             *                  Create task in free descriptor.
55:             *  parameters:     priority - value from 0 (highest) to 7 (lowest)
56:             *                  TaskAddr - pointer to C-function that contains task
57:             *
58:             *  on return:      check OS_IsError
59:             *                  OST_TASK_POINTER - pointer to task descriptor
60:             *                  _OS_Temp - task position in _OS_Tasks array 
61:             *
62:             *  Overloaded in:  "osa_pic12_htpicc.c"
63:             *                  "osa_pic16_mikroc.c"
64:             *                  "osa_pic24_mplabc.c"
65:             *                  "port\osa_ccc16.c"
66:             *
67:             ********************************************************************************
68:             */
69:            
70:            
71:            //------------------------------------------------------------------------------
72:            #if !defined(_OS_Task_Create_DEFINED)
73:            //------------------------------------------------------------------------------
74:            
75:                void _OS_Task_Create(OST_WORD priority, OST_CODE_POINTER TaskAddr)
29AA  CFD9     MOVFF FSR2, POSTINC1
29AC  FFE6     NOP
29AE  CFE1     MOVFF FSR1, FSR2
29B0  FFD9     NOP
29B2  0E02     MOVLW 0x2
29B4  26E1     ADDWF FSR1, F, ACCESS
76:                {
77:                    OST_TASK_POINTER Task;
78:            
79:                    _OS_Flags.bError = 0;
29B6  923A     BCF _OS_Flags, 1, ACCESS
80:            
81:            
82:                    /*--------------------------------------*
83:                     *                                      *
84:                     *  Start search from first task in     *
85:                     *  OS_TASKS descriptors.               *
86:                     *                                      *
87:                     *--------------------------------------*/
88:                    Task = (OST_TASK_POINTER)_OS_Tasks;
29B8  0E05     MOVLW 0x5
29BA  6EDE     MOVWF POSTINC2, ACCESS
29BC  0E00     MOVLW 0x0
29BE  6EDD     MOVWF POSTDEC2, ACCESS
89:                    _OS_Temp = 0;   
29C0  6A3B     CLRF _OS_Temp, ACCESS
90:            
91:                    do {
92:            
93:                        if (!Task->State.bEnable)               // Is descriptor free?
29C2  D82F     RCALL __pa_0
29C4  50EF     MOVF INDF0, W, ACCESS
29C6  0B40     ANDLW 0x40
29C8  E115     BNZ 0x29F4
94:                        {                                       // Yes
95:                            ((OST_TASK_STATE*)&priority)->bEnable = 1;
29CA  0EFE     MOVLW 0xFE
29CC  8CDB     BSF PLUSW2, 6, ACCESS
96:                            ((OST_TASK_STATE*)&priority)->bReady = 1;
29CE  86DB     BSF PLUSW2, 3, ACCESS
97:            
98:                            Task->pTaskPointer = TaskAddr;
29D0  D828     RCALL __pa_0
29D2  52EE     MOVF POSTINC0, F, ACCESS
29D4  0EFC     MOVLW 0xFC
29D6  CFDB     MOVFF PLUSW2, POSTINC0
29D8  FFEE     NOP
29DA  0EFD     MOVLW 0xFD
29DC  CFDB     MOVFF PLUSW2, POSTDEC0
29DE  FFED     NOP
99:            
100:                           #ifdef OS_ENABLE_TTIMERS
101:                               Task->Timer = 0;
29E0  D820     RCALL __pa_0
29E2  0E04     MOVLW 0x4
29E4  D823     RCALL __pa_1
2A2C  26E9     ADDWF FSR0, F, ACCESS
2A2E  0E00     MOVLW 0x0
2A30  22EA     ADDWFC FSR0H, F, ACCESS
2A32  6AEF     CLRF INDF0, ACCESS
102:                           #endif
103:           
104:                           #ifdef _OS_TASK_CREATE_PROC_SPEC
105:                           _OS_TASK_CREATE_PROC_SPEC();
29E6  0E03     MOVLW 0x3
29E8  D821     RCALL __pa_1
2A34  EF11     GOTO 0x2A22
2A36  F015     NOP
106:                           #endif
107:           
108:                           *((OS_TASKS_BANK char*)&Task->State) = priority;
29EA  0EFE     MOVLW 0xFE
29EC  CFDB     MOVFF PLUSW2, INDF0
29EE  FFEF     NOP
2A22  CFDE     MOVFF POSTINC2, FSR0
2A24  FFE9     NOP
2A26  CFDD     MOVFF POSTDEC2, FSR0H
2A28  FFEA     NOP
2A2A  0012     RETURN 0
109:           
110:                           #if defined(_OS_CUR_FLAGS_IN_OS_STATE)
111:                           if (Task == _OS_CurTask) *((OS_RAM_NEAR char*)&_OS_State) = priority;
112:                           #endif
113:           
114:                           #if defined(__OSA_AVR_WINAVR__) || defined(__OSA_AVR_IAR__)
115:                           Task->nY_Temp = 0x8000;
116:                           #endif
117:           
118:                           #if defined(__OSA_AVR_WINAVR__)
119:                           Task->c_NumOfTemp = 0;  
120:                           #endif
121:           
122:                           #if defined(__OSA_STM8__)
123:                           Task->nSP_Temp = 0;
124:                           #endif
125:           
126:                           _OS_Flags.bError = 0;
29F0  923A     BCF _OS_Flags, 1, ACCESS
127:           
128:                           return ;
29F2  D00D     BRA 0x2A0E
129:           
130:                       }
131:           
132:                       Task ++;
29F4  CFD9     MOVFF FSR2, FSR0
29F6  FFE9     NOP
29F8  CFDA     MOVFF FSR2H, FSR0H
29FA  FFEA     NOP
29FC  0E05     MOVLW 0x5
29FE  26EE     ADDWF POSTINC0, F, ACCESS
2A00  0E00     MOVLW 0x0
2A02  22EF     ADDWFC INDF0, F, ACCESS
133:           
134:                   } while (++_OS_Temp < OS_TASKS);    
2A04  2A3B     INCF _OS_Temp, F, ACCESS
2A06  0E05     MOVLW 0x5
2A08  5C3B     SUBWF _OS_Temp, W, ACCESS
2A0A  E3DB     BNC 0x29C2
135:           
136:                   // There is no free descriptor. Task was not created.
137:                   _OS_Flags.bError = 1;
2A0C  823A     BSF _OS_Flags, 1, ACCESS
138:           
139:                   return ;
140:               }
2A0E  0E02     MOVLW 0x2
2A10  5CE1     SUBWF FSR1, W, ACCESS
2A12  E202     BC 0x2A18
2A14  6AE1     CLRF FSR1, ACCESS
2A16  52E5     MOVF POSTDEC1, F, ACCESS
2A18  6EE1     MOVWF FSR1, ACCESS
2A1A  52E5     MOVF POSTDEC1, F, ACCESS
2A1C  CFE7     MOVFF INDF1, FSR2
2A1E  FFD9     NOP
2A20  0012     RETURN 0
141:           
142:           //------------------------------------------------------------------------------
143:           #endif  // !defined(_OS_Task_Create_DEFINED)
144:           //------------------------------------------------------------------------------
145:           
146:           
147:           
148:           //******************************************************************************
149:           //  END OF FILE osa_tasks.c
150:           //******************************************************************************
151:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/OSA/kernel/system/osa_system.c  ------------------
1:             /*
2:              ************************************************************************************************
3:              *
4:              *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8
5:              *
6:              *  OSA is distributed under BSD license (see license.txt)
7:              *
8:              *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro
9:              *
10:             *----------------------------------------------------------------------------------------------
11:             *
12:             *  File:           osa_system.c
13:             *
14:             *  Programmer:     Timofeev Victor
15:             *                  osa@pic24.ru, testerplus@mail.ru
16:             *
17:             *  Description:    System functions
18:             *                  This file directly included in osa.c
19:             *
20:             *  History:        12.09.2010 -    File updated
21:             *
22:             ************************************************************************************************
23:             */
24:            
25:            
26:            
27:            
28:            
29:            
30:            /************************************************************************************************
31:             *                                                                                              *
32:             *                                                                                              *
33:             *                         F U N C T I O N   D E F I N I T I O N S                              *
34:             *                                                                                              *
35:             *                                                                                              *
36:             ************************************************************************************************/
37:            
38:            
39:            
40:            
41:            /*
42:             ********************************************************************************
43:             *
44:             *   void OS_Init (void)
45:             *
46:             *------------------------------------------------------------------------------
47:             *
48:             *  description:    (Internal function called by system kernel)
49:             *
50:             *                  Initialize all system variables:
51:             *                  - Clear all binary semaphores
52:             *                  - Free all task descriptors
53:             *                  - Clear all timeouts for old style static timers
54:             *                  - Set _OS_LastTask and _OS_CurTask variables at last task
55:             *                    descriptor
56:             *
57:             *  parameters:     none
58:             *
59:             *  on return:      _OSCurTask points to last task descriptor.
60:             *
61:             *  Overloaded in:  -
62:             *
63:             ********************************************************************************
64:             */
65:            
66:            
67:            void OS_Init (void)
68:            {
69:                #ifdef __OSA_PIC24_MPLABC__
70:                _OS_Flags = (OST_SYSTEM_FLAGS){0};
71:                #else
72:                *(OS_RAM_NEAR OST_WORD*)&_OS_Flags = 0;
2968  6A3A     CLRF _OS_Flags, ACCESS
73:                #endif
74:            
75:                _OS_INIT_PROC_SPEC();     /* Specific controller type's init operations   */
76:            
77:            
78:            
79:                #if OS_PRIORITY_LEVEL == OS_PRIORITY_NORMAL
80:            
81:                    _OS_LastTask = (OST_TASK_POINTER) _OS_Tasks + (OS_TASKS - 1);
296A  0E19     MOVLW 0x19
296C  6E02     MOVWF _OS_LastTask, ACCESS
296E  0E00     MOVLW 0x0
2970  6E03     MOVWF 0x3, ACCESS
82:            
83:                #endif
84:            
85:            
86:            
87:                /*--------------------------------------*
88:                 *                                      *
89:                 *  Zero all old style static timers    *
90:                 *                                      *
91:                 *--------------------------------------*/
92:            
93:                #if OS_TIMERS > 11*8 || ((OS_TIMERS > 0) && defined(__OSA_PIC24_MPLABC__))
94:            
95:                    _OS_Temp = sizeof(OS_Timeouts) / sizeof(OST_WORD);
96:                    do
97:                    {
98:                        OS_Timeouts[_OS_Temp-1] = 0;
99:                    } while (--_OS_Temp);
100:           
101:               #else
102:                   #if OS_TIMERS > 0
103:                       OS_Timeouts[0] = 0;
104:                   #endif
105:           
106:                   #if OS_TIMERS > 1*8
107:                       OS_Timeouts[1] = 0;
108:                   #endif
109:           
110:                   #if OS_TIMERS > 2*8
111:                       OS_Timeouts[2] = 0;
112:                   #endif
113:           
114:                   #if OS_TIMERS > 3*8
115:                       OS_Timeouts[3] = 0;
116:                   #endif
117:           
118:                   #if OS_TIMERS > 4*8
119:                       OS_Timeouts[4] = 0;
120:                   #endif
121:           
122:                   #if OS_TIMERS > 5*8
123:                       OS_Timeouts[5] = 0;
124:                   #endif
125:           
126:                   #if OS_TIMERS > 6*8
127:                       OS_Timeouts[6] = 0;
128:                   #endif
129:           
130:                   #if OS_TIMERS > 7*8
131:                       OS_Timeouts[7] = 0;
132:                   #endif
133:           
134:                   #if OS_TIMERS > 8*8
135:                       OS_Timeouts[8] = 0;
136:                   #endif
137:           
138:                   #if OS_TIMERS > 9*8
139:                       OS_Timeouts[9] = 0;
140:                   #endif
141:           
142:                   #if OS_TIMERS > 10*8
143:                       OS_Timeouts[10] = 0;
144:                   #endif
145:           
146:               #endif
147:           
148:           
149:               /*--------------------------------------*
150:                *                                      *
151:                *  Clear list of dynamic timers        *
152:                *                                      *
153:                *--------------------------------------*/
154:           
155:               #if defined(OS_ENABLE_DTIMERS)
156:                   *((OS_BANK OST_WORD*)&_OS_DTimers.Flags) = 0;
157:                   _OS_DTimers.Flags.bNextEnable = 0;
158:                   _OS_DTimers.Flags.bActive = 1;
159:               #endif
160:           
161:               /*--------------------------------------*
162:                *                                      *
163:                *  Clear list of fast timers           *
164:                *                                      *
165:                *--------------------------------------*/
166:           
167:           
168:               #if defined(OS_ENABLE_QTIMERS)
169:                   *((OS_BANK OST_WORD*)&_OS_Qtimers.Flags) = 0;
170:                   // Default:
171:                   //  bNextEnable     = 0
172:                   //  bListFunction   = 0 (FUNCTION_ADD)
173:                   //  bListGetTime    = 0
174:                   _OS_Qtimers.Flags.bActive = 1;
175:               #endif
176:           
177:               /*--------------------------------------*
178:                *                                      *
179:                *  Make all static timers free         *
180:                *                                      *
181:                *--------------------------------------*/
182:           
183:               #if defined (OS_ENABLE_STIMERS)
184:               #if defined (OS_STIMERS_ENABLE_ALLOCATION)
185:           
186:               #if OS_STIMERS > 11*8 || ((OS_STIMERS > 0) && defined(__OSA_PIC24_MPLABC__))
187:           
188:                   _OS_Temp = sizeof(_OS_StimersFree) / sizeof(OST_WORD);
189:                   do
190:                   {
191:                       _OS_StimersFree[_OS_Temp-1] = (OST_WORD)-1;
192:                   } while (--_OS_Temp);
193:           
194:               #else
195:                   #if OS_STIMERS > 1*8
196:                       _OS_StimersFree[0] = (OST_WORD)-1;
197:                   #endif
198:           
199:                   #if OS_STIMERS > 2*8
200:                       _OS_StimersFree[1] = (OST_WORD)-1;
201:                   #endif
202:           
203:                   #if OS_STIMERS > 3*8
204:                       _OS_StimersFree[2] = (OST_WORD)-1;
205:                   #endif
206:           
207:                   #if OS_STIMERS > 4*8
208:                       _OS_StimersFree[3] = (OST_WORD)-1;
209:                   #endif
210:           
211:                   #if OS_STIMERS > 5*8
212:                       _OS_StimersFree[4] = (OST_WORD)-1;
213:                   #endif
214:           
215:                   #if OS_STIMERS > 6*8
216:                       _OS_StimersFree[5] = (OST_WORD)-1;
217:                   #endif
218:           
219:                   #if OS_STIMERS > 7*8
220:                       _OS_StimersFree[6] = (OST_WORD)-1;
221:                   #endif
222:           
223:                   #if OS_STIMERS > 8*8
224:                       _OS_StimersFree[7] = (OST_WORD)-1;
225:                   #endif
226:           
227:                   #if OS_STIMERS > 9*8
228:                       _OS_StimersFree[8] = (OST_WORD)-1;
229:                   #endif
230:           
231:                   #if OS_STIMERS > 10*8
232:                       _OS_StimersFree[ 9] = (OST_WORD)-1;
233:                   #endif
234:           
235:               #endif
236:           
237:                   #if (OS_STIMERS & _OST_INT_MASK) != 0
238:                   _OS_StimersFree[OS_STIMERS >> _OST_INT_SHIFT] = (1 << (OS_STIMERS & _OST_INT_MASK)) - 1;
239:                   #endif
240:           
241:               #endif
242:               #endif
243:           
244:               /*--------------------------------------*
245:                *                                      *
246:                *  Zero all binary semaphores          *
247:                *                                      *
248:                *--------------------------------------*/
249:           
250:               #if OS_BSEMS > 11*8 || ((OS_BSEMS > 0) && defined(__OSA_PIC24_MPLABC__))
251:           
252:                   _OS_Temp = sizeof(_OS_Bsems) / sizeof(OST_WORD);
253:                   do
254:                   {
255:                       _OS_Bsems[_OS_Temp-1] = 0;
256:                   } while (--_OS_Temp);
257:           
258:               #else
259:                   #if OS_BSEMS > 0
260:                       _OS_Bsems[0] = 0;
261:                   #endif
262:           
263:                   #if OS_BSEMS > 1*8
264:                       _OS_Bsems[1] = 0;
265:                   #endif
266:           
267:                   #if OS_BSEMS > 2*8
268:                       _OS_Bsems[2] = 0;
269:                   #endif
270:           
271:                   #if OS_BSEMS > 3*8
272:                       _OS_Bsems[3] = 0;
273:                   #endif
274:           
275:                   #if OS_BSEMS > 4*8
276:                       _OS_Bsems[4] = 0;
277:                   #endif
278:           
279:                   #if OS_BSEMS > 5*8
280:                       _OS_Bsems[5] = 0;
281:                   #endif
282:           
283:                   #if OS_BSEMS > 6*8
284:                       _OS_Bsems[6] = 0;
285:                   #endif
286:           
287:                   #if OS_BSEMS > 7*8
288:                       _OS_Bsems[7] = 0;
289:                   #endif
290:           
291:                   #if OS_BSEMS > 8*8
292:                       _OS_Bsems[8] = 0;
293:                   #endif
294:           
295:                   #if OS_BSEMS > 9*8
296:                       _OS_Bsems[9] = 0;
297:                   #endif
298:           
299:                   #if OS_BSEMS > 10*8
300:                       _OS_Bsems[10] = 0;
301:                   #endif
302:               #endif
303:           
304:           
305:               /*--------------------------------------*
306:                *                                      *
307:                *  Zero all task descriptors           *
308:                *                                      *
309:                *--------------------------------------*/
310:           
311:               #if OS_TASKS > 10
312:                   _OS_SET_IRP_CUR_TASK();
313:                   _OS_CurTask = (OST_TASK_POINTER) _OS_Tasks;
314:                   _OS_Temp = OS_TASKS;
315:                   do {
316:                       _OS_CurTask->State.bEnable = 0;
317:                       _OS_CurTask ++;
318:                   } while (--_OS_Temp);
319:                   _OS_CLR_IRP();
320:               #else
321:           
322:                   #if OS_PRIORITY_LEVEL == OS_PRIORITY_DISABLED
323:                       _OS_CurTask = (OST_TASK_POINTER) _OS_Tasks + (OS_TASKS-1);
324:                   #endif
325:           
326:                   _OS_Tasks[0].State.bEnable = 0;
2972  9C05     BCF _OS_Tasks, 6, ACCESS
327:           
328:                   #if OS_TASKS > 1
329:                      _OS_Tasks[1].State.bEnable = 0;
2974  9C0A     BCF 0xA, 6, ACCESS
330:                   #endif
331:           
332:                   #if OS_TASKS > 2
333:                      _OS_Tasks[2].State.bEnable = 0;
2976  9C0F     BCF 0xF, 6, ACCESS
334:                   #endif
335:           
336:                   #if OS_TASKS > 3
337:                      _OS_Tasks[3].State.bEnable = 0;
2978  9C14     BCF 0x14, 6, ACCESS
338:                   #endif
339:           
340:                   #if OS_TASKS > 4
341:                      _OS_Tasks[4].State.bEnable = 0;
297A  9C19     BCF 0x19, 6, ACCESS
342:                   #endif
343:           
344:                   #if OS_TASKS > 5
345:                      _OS_Tasks[5].State.bEnable = 0;
346:                   #endif
347:           
348:                   #if OS_TASKS > 6
349:                      _OS_Tasks[6].State.bEnable = 0;
350:                   #endif
351:           
352:                   #if OS_TASKS > 7
353:                      _OS_Tasks[7].State.bEnable = 0;
354:                   #endif
355:           
356:                   #if OS_TASKS > 8
357:                      _OS_Tasks[8].State.bEnable = 0;
358:                   #endif
359:           
360:                   #if OS_TASKS > 9
361:                      _OS_Tasks[9].State.bEnable = 0;
362:                   #endif
363:           
364:               #endif
365:           
366:           
367:               /*--------------------------------------*
368:                *                                      *
369:                *  Zero task queue for extended        *
370:                *  priority mode                       *
371:                *                                      *
372:                *--------------------------------------*/
373:           
374:               //------------------------------------------------------------------------------
375:               #if (OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED)
376:               //------------------------------------------------------------------------------
377:           
378:           
379:               _OS_SET_IRP_CUR_TASK();
380:               _OS_CurTask = (OST_TASK_POINTER) _OS_Tasks;
381:               _OS_Temp = OS_TASKS;
382:               do
383:               {
384:                   _OS_TaskQueue[_OS_Temp-1] = _OS_Temp-1;
385:                   _OS_TaskLevel[_OS_Temp-1] = 0;
386:               } while (--_OS_Temp);
387:               _OS_CLR_IRP();
388:           
389:               //------------------------------------------------------------------------------
390:               #endif
391:               //------------------------------------------------------------------------------
392:           
393:           
394:           }
297C  0012     RETURN 0
395:           
396:           
397:           
398:           /*
399:            ************************************************************************************************
400:            *                                                                                              *
401:            *                         C R I T I C A L   S E C T I O N S                                    *
402:            *                                                                                              *
403:            ************************************************************************************************
404:            */
405:           
406:           //------------------------------------------------------------------------------
407:           #ifdef OS_ENABLE_CRITICAL_SECTION
408:           //------------------------------------------------------------------------------
409:           
410:           /*
411:            ********************************************************************************
412:            *
413:            *   void OS_EnterCriticalSection (void)
414:            *
415:            *------------------------------------------------------------------------------
416:            *
417:            *   description:   Enter critical section.
418:            *                  This function disables interrupts (with saving current
419:            *                  state) and sets system flag bInCriticalSection
420:            *
421:            *
422:            *  parameters:     none
423:            *
424:            *  on return:      none
425:            *
426:            *  Overloaded in:  "osa_pic16_htpicc.c"
427:            *                  "osa_pic16_mikroc.c"
428:            *                  "osa_pic16_ccs.c"
429:            *                  "osa_pic24_mplabc.c"
430:            *                  "osa_stm8_cosmic.c"
431:            *
432:            ********************************************************************************
433:            */
434:           
435:           //------------------------------------------------------------------------------
436:           #if !defined(OS_EnterCriticalSection_DEFINED)
437:           //------------------------------------------------------------------------------
438:           
439:           
440:           //------------------------------------------------------------------------------
441:           #ifdef      __OSA18__
442:           //------------------------------------------------------------------------------
443:           
444:               void OS_EnterCriticalSection (void)
445:               {
446:                   OST_UINT temp;
447:           
448:                   temp = OS_DI();
449:                   _OS_Flags.bInCriticalSection = 1;
450:           
451:                   _OS_Flags.bGIE_CTemp = 0;
452:                   if (temp & 0x80) _OS_Flags.bGIE_CTemp = 1;
453:           
454:                   _OS_Flags.bGIEL_CTemp = 0;
455:                   if (temp & 0x40) _OS_Flags.bGIEL_CTemp = 1;
456:               }
457:           
458:           
459:           //------------------------------------------------------------------------------
460:           #else   //  __OSA18__
461:           //------------------------------------------------------------------------------
462:           
463:               void OS_EnterCriticalSection (void)
464:               {
465:                   _OS_Flags.bGIE_CTemp = 0;
466:                   if (OS_DI() & 0x80) _OS_Flags.bGIE_CTemp = 1;
467:                   _OS_Flags.bInCriticalSection = 1;
468:           
469:               }
470:           
471:           //------------------------------------------------------------------------------
472:           #endif  //  __OSA18__
473:           //------------------------------------------------------------------------------
474:           
475:           //------------------------------------------------------------------------------
476:           #endif
477:           //------------------------------------------------------------------------------
478:           
479:           
480:           
481:           
482:           /*
483:            ********************************************************************************
484:            *
485:            *   void OS_LeaveCriticalSection (void)
486:            *
487:            *------------------------------------------------------------------------------
488:            *
489:            *  description:    Leave critical section.
490:            *                  This function restore interrupt state from OS_Flag temp bits
491:            *                  and clears system flag bInCriticalSection
492:            *
493:            *  parameters:     none
494:            *
495:            *  on return:      none
496:            *
497:            *
498:            *  Overloaded in:  "osa_pic16_htpicc.c"
499:            *                  "osa_pic16_ccs.c"
500:            *                  "osa_pic16_mikroc.c"
501:            *                  "osa_pic24_mplabc.c"
502:            *                  "osa_stm8_cosmic.c"
503:            *
504:            ********************************************************************************
505:            */
506:           
507:           //------------------------------------------------------------------------------
508:           #if !defined(OS_LeaveCriticalSection_DEFINED)
509:           //------------------------------------------------------------------------------
510:           
511:           //------------------------------------------------------------------------------
512:           #ifdef      __OSA18__
513:           //------------------------------------------------------------------------------
514:           
515:               void OS_LeaveCriticalSection (void)
516:               {
517:                   char temp;
518:                   _OS_Flags.bInCriticalSection = 0;
519:                   temp = 0;
520:                   if (_OS_Flags.bGIE_CTemp)  temp |= 0x80;
521:                   if (_OS_Flags.bGIEL_CTemp) temp |= 0x40;
522:                   OS_RI(temp);
523:               }
524:           
525:           //------------------------------------------------------------------------------
526:           #else   //  __OSA18__
527:           //------------------------------------------------------------------------------
528:           
529:               void OS_LeaveCriticalSection (void)
530:               {
531:                   _OS_Flags.bInCriticalSection = 0;
532:                   if (_OS_Flags.bGIE_CTemp) OS_RI(0x80);
533:               }
534:           
535:           //------------------------------------------------------------------------------
536:           #endif  //  __OSA18__
537:           //------------------------------------------------------------------------------
538:           
539:           //------------------------------------------------------------------------------
540:           #endif
541:           //------------------------------------------------------------------------------
542:           
543:           //------------------------------------------------------------------------------
544:           #endif  //  OS_ENABLE_CRITICAL_SECTION
545:           //------------------------------------------------------------------------------
546:           
547:           
548:           
549:           
550:           
551:           
552:           
553:           
554:           /*
555:            ************************************************************************************************
556:            *                                                                                              *
557:            *                                   S Y S T E M   T I M E R                                    *
558:            *                                                                                              *
559:            ************************************************************************************************
560:            */
561:           
562:           
563:           
564:           //-----------------------------------------------------------------
565:           #ifdef OS_ENABLE_OS_TIMER
566:           #ifndef OS_USE_INLINE_TIMER
567:           //-----------------------------------------------------------------
568:           void OS_Timer (void)
569:           {
570:               __OS_TimerInline();
297E  0100     MOVLB 0x0
2980  A905     BTFSS _OS_Tasks, 4, BANKED
2982  D002     BRA 0x2988
2984  4B09     INFSNZ 0x9, F, BANKED
2986  9905     BCF _OS_Tasks, 4, BANKED
2988  A90A     BTFSS 0xA, 4, BANKED
298A  D002     BRA 0x2990
298C  4B0E     INFSNZ 0xE, F, BANKED
298E  990A     BCF 0xA, 4, BANKED
2990  A90F     BTFSS 0xF, 4, BANKED
2992  D002     BRA 0x2998
2994  4B13     INFSNZ 0x13, F, BANKED
2996  990F     BCF 0xF, 4, BANKED
2998  A914     BTFSS 0x14, 4, BANKED
299A  D002     BRA 0x29A0
299C  4B18     INFSNZ 0x18, F, BANKED
299E  9914     BCF 0x14, 4, BANKED
29A0  A919     BTFSS 0x19, 4, BANKED
29A2  D002     BRA 0x29A8
29A4  4B1D     INFSNZ 0x1D, F, BANKED
29A6  9919     BCF 0x19, 4, BANKED
571:           }
29A8  0012     RETURN 0
572:           //-----------------------------------------------------------------
573:           #endif  // OS_ENABLE_OS_TIMER
574:           #endif  // OS_USE_INLINE_TIMER
575:           //-----------------------------------------------------------------
576:           
577:           
578:           
579:           
580:           
581:           
582:           /*
583:            ********************************************************************************
584:            *
585:            *  OST_BOOL _OS_CheckEvent (char bEvent)
586:            *
587:            *------------------------------------------------------------------------------
588:            *
589:            *  description:    (Internal function called by system kernel througth
590:            *                  waiting services)
591:            *
592:            *                  Check condition of bEvent. Accordint to bEvent value and
593:            *                  current state of bReady, bDelay and bCanContinue flags,
594:            *                  task becames ready to execute or still remains in waiting
595:            *                  mode.
596:            *
597:            *  parameters:     bEvent - zero, or non-zero condition
598:            *
599:            *  on return:      1 - when condition is true, or timeout occured
600:            *                  0 - condition is false and no timeout
601:            *
602:            *  Overloaded in:  "osa_pic12_htpicc.c"
603:            *                  "osa_pic16_htpicc.c"
604:            *                  "osa_pic18_htpicc.c"
605:            *                  "osa_pic16_mikroc.c"
606:            *                  "osa_pic18_mikroc.c"
607:            *                  "osa_pic18_mplabc.c"
608:            *                  "osa_pic24_mplabc.c"
609:            *                  "osa_pic16_ccs.c"
610:            *                  "osa_pic18_ccs.c"
611:            *
612:            ********************************************************************************
613:            */
614:           
615:           //------------------------------------------------------------------------------
616:           #if !defined(_OS_CheckEvent_DEFINED)
617:           //------------------------------------------------------------------------------
618:           
619:               OST_BOOL _OS_CheckEvent (char bEvent)
620:               {
621:                   _OS_Flags.bTimeout = 0;
622:           
623:                   if (bEvent)
624:                   {
625:                       if (_OS_CurTask->State.bReady)
626:                       {
627:                           #ifdef OS_ENABLE_TTIMERS
628:                               _OS_TASK_ATOMIC_WRITE_A(_OS_CurTask->State.bDelay = 0);
629:                           #endif
630:           
631:                           #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED
632:                           _OS_Flags.bEventOK = 1;
633:                           #endif
634:           
635:                           return 1;
636:                       }
637:           
638:                       _OS_bTaskReady = 1;
639:           
640:                   } else {
641:                       _OS_bTaskReady = 0;
642:                   }
643:           
644:                   #ifdef OS_ENABLE_TTIMERS
645:           
646:                       if (!_OS_CurTask->State.bDelay && _OS_CurTask->State.bCanContinue)
647:                       {
648:                           _OS_bTaskReady = 1;
649:                           _OS_Flags.bTimeout = 1;
650:           
651:                           #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED
652:                           _OS_Flags.bEventOK = 1;
653:                           #endif
654:           
655:                           return 1;
656:           
657:                       }
658:           
659:                   #endif
660:           
661:                   return 0;
662:           
663:               }
664:           
665:           //------------------------------------------------------------------------------
666:           #endif  // !defined(_OS_CheckEvent_DEFINED)
667:           //------------------------------------------------------------------------------
668:           
669:           
670:           
671:           //******************************************************************************
672:           //  END OF FILE osa_system.c
673:           //******************************************************************************
674:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_sound/module_sound.c  ---------------------
1:             #include "module_sound.h"
2:             #include <p18cxxx.h>
3:             #include "module_management.h"
4:             #include "module_logic_inputs.h"
5:             
6:             #define TIME_BUTTON_SUBMERGENCE_CONST		75U				//время подзвучки кнопки в мс
7:             #define TIME_FLASH_SOUND_CONST				500U			//время звука в аварийном режиме в мс
8:             #define SOUND_PIN							LATCbits.LATC5	//пин звука
9:             #define SOUND_TRIS							TRISCbits.TRISC5	//пин звука
10:            
11:            typedef struct 
12:            {
13:            	uint16_t time_flash_sound;
14:            	BOOL flag_flash_sound;
15:            	uint16_t time_button_submergence;
16:            }TimeMSound;
17:            
18:            
19:            /*Структуры модуля  */
20:            static TimeMSound time_M_Sound = { 0, 0, 0};
21:            
22:            
23:            /* Переменные модуля */
24:            BOOL button_submergence = 0; 	//флаг подзвучки кнопки
25:            
26:            
27:            /*Методы модуля */
28:            
29:            void M_Sound_ctor( void )
30:            {
31:                SOUND_TRIS = OUT;
3120  9A94     BCF TRISC, 5, ACCESS
32:                SOUND_PIN = OFF;
3122  9A8B     BCF LATC, 5, ACCESS
33:            }
3124  0012     RETURN 0
34:            
35:            /* Установка флага подзвучки кнопок */
36:            void M_Sound_set_button_submergence (BOOL value)
3126  CFD9     MOVFF FSR2, POSTINC1
3128  FFE6     NOP
312A  CFE1     MOVFF FSR1, FSR2
312C  FFD9     NOP
37:            {
38:            	button_submergence = value;
312E  0EFE     MOVLW 0xFE
3130  CFDB     MOVFF PLUSW2, button_submergence
3132  F0FE     NOP
39:            }
3134  52E5     MOVF POSTDEC1, F, ACCESS
3136  CFE7     MOVFF INDF1, FSR2
3138  FFD9     NOP
313A  0012     RETURN 0
40:            
41:            
42:            void M_Sound_run (void)
43:            {
44:            	if(M_Mngm_Get_parameters_buffer()->menu_parameters.enable_sound && M_Mngm_Get_state() != STATE_PAUSE)  //если звук разрешён
313C  ECFE     CALL 0x15FC, 0
313E  F00A     NOP
3140  CFF3     MOVFF PROD, FSR0
3142  FFE9     NOP
3144  CFF4     MOVFF PRODH, FSR0H
3146  FFEA     NOP
3148  0E29     MOVLW 0x29
314A  26E9     ADDWF FSR0, F, ACCESS
314C  0E00     MOVLW 0x0
314E  22EA     ADDWFC FSR0H, F, ACCESS
3150  50EF     MOVF INDF0, W, ACCESS
3152  E047     BZ 0x31E2
3154  EC0C     CALL 0x1618, 0
3156  F00B     NOP
3158  0803     SUBLW 0x3
315A  E043     BZ 0x31E2
45:            	{
46:            		if(button_submergence) 	//если установлено разрешение подзвучки кнопок
315C  0100     MOVLB 0x0
315E  51FE     MOVF button_submergence, W, BANKED
3160  E011     BZ 0x3184
47:            		{
48:            			SOUND_PIN = !SOUND_PIN;
3162  7A8B     BTG LATC, 5, ACCESS
49:            			//отсчёт времени подзвучки кнопок
50:            			if(time_M_Sound.time_button_submergence++ == TIME_BUTTON_SUBMERGENCE_CONST)
3164  C0FC     MOVFF 0xFC, __tmp_0
3166  F032     NOP
3168  C0FD     MOVFF 0xFD, 0x33
316A  F033     NOP
316C  2BFC     INCF 0xFC, F, BANKED
316E  0E00     MOVLW 0x0
3170  23FD     ADDWFC 0xFD, F, BANKED
3172  0E4B     MOVLW 0x4B
3174  1832     XORWF __tmp_0, W, ACCESS
3176  E106     BNZ 0x3184
3178  5033     MOVF 0x33, W, ACCESS
317A  E104     BNZ 0x3184
51:            			{
52:            				time_M_Sound.time_button_submergence = 0;
317C  6BFC     CLRF 0xFC, BANKED
317E  6BFD     CLRF 0xFD, BANKED
53:            				SOUND_PIN = OFF;
3180  9A8B     BCF LATC, 5, ACCESS
54:            				button_submergence = OFF;
3182  6BFE     CLRF button_submergence, BANKED
55:            			}
56:            		}	
57:            		//в состоянии аварии звук "меандром" с периодом TIME_FLASH_SOUND_CONST*2
58:            		if(M_Mngm_Get_state() ==  STATE_FAILURE) 
3184  EC0C     CALL 0x1618, 0
3186  F00B     NOP
3188  0805     SUBLW 0x5
318A  E125     BNZ 0x31D6
59:            		{
60:            			SOUND_PIN = time_M_Sound.flag_flash_sound ? OFF : !SOUND_PIN; 
318C  0100     MOVLB 0x0
318E  51FB     MOVF 0xFB, W, BANKED
3190  E002     BZ 0x3196
3192  0E00     MOVLW 0x0
3194  D005     BRA 0x31A0
3196  508B     MOVF LATC, W, ACCESS
3198  0B20     ANDLW 0x20
319A  0A20     XORLW 0x20
319C  E001     BZ 0x31A0
319E  0E01     MOVLW 0x1
31A0  B0E8     BTFSC WREG, 0, ACCESS
31A2  8A8B     BSF LATC, 5, ACCESS
31A4  A0E8     BTFSS WREG, 0, ACCESS
31A6  9A8B     BCF LATC, 5, ACCESS
61:            			if(time_M_Sound. time_flash_sound++ == TIME_FLASH_SOUND_CONST)
31A8  C0F9     MOVFF time_M_Sound, __tmp_0
31AA  F032     NOP
31AC  C0FA     MOVFF 0xFA, 0x33
31AE  F033     NOP
31B0  2BF9     INCF time_M_Sound, F, BANKED
31B2  0E00     MOVLW 0x0
31B4  23FA     ADDWFC 0xFA, F, BANKED
31B6  0EF4     MOVLW 0xF4
31B8  1832     XORWF __tmp_0, W, ACCESS
31BA  E119     BNZ 0x31EE
31BC  0E01     MOVLW 0x1
31BE  1833     XORWF 0x33, W, ACCESS
31C0  E10F     BNZ 0x31E0
62:            			{
63:            				time_M_Sound. time_flash_sound = 0;
31C2  6BF9     CLRF time_M_Sound, BANKED
31C4  6BFA     CLRF 0xFA, BANKED
64:            				time_M_Sound.flag_flash_sound = !time_M_Sound.flag_flash_sound;
31C6  51FB     MOVF 0xFB, W, BANKED
31C8  E002     BZ 0x31CE
31CA  0E00     MOVLW 0x0
31CC  D001     BRA 0x31D0
31CE  0E01     MOVLW 0x1
31D0  6FFB     MOVWF 0xFB, BANKED
65:            				SOUND_PIN = !SOUND_PIN;	
31D2  7A8B     BTG LATC, 5, ACCESS
66:            			}	
67:            		}
68:            		else
31D4  0012     RETURN 0
69:            		{
70:            			if(!button_submergence)  
31D6  0100     MOVLB 0x0
31D8  51FE     MOVF button_submergence, W, BANKED
31DA  E109     BNZ 0x31EE
71:            			{	
72:            				SOUND_PIN = OFF;	
31DC  9A8B     BCF LATC, 5, ACCESS
73:            				time_M_Sound.flag_flash_sound = OFF;
31DE  6BFB     CLRF 0xFB, BANKED
74:            			}
75:            		}
76:            	}
77:            	else
31E0  0012     RETURN 0
78:            	{
79:            		SOUND_PIN = OFF;
31E2  9A8B     BCF LATC, 5, ACCESS
80:            		button_submergence = FALSE;
31E4  0100     MOVLB 0x0
31E6  6BFE     CLRF button_submergence, BANKED
81:            		time_M_Sound.time_button_submergence = 0;
31E8  6BFC     CLRF 0xFC, BANKED
31EA  6BFD     CLRF 0xFD, BANKED
82:            		time_M_Sound.flag_flash_sound = OFF;
31EC  6BFB     CLRF 0xFB, BANKED
83:            	}
84:            }
31EE  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_motor/module_motor.c  ---------------------
1:             #include "module_management.h"
2:             #include <p18cxxx.h>
3:             #include <string.h>
4:             #include "module_motor.h"
5:             #include "module_logic_inputs.h"
6:             #include "module_indication.h"
7:             #include "interrupts.h"
8:             #include "main.h"
9:             #include "OSA.h"
10:            
11:            
12:            #define PWM_PERIOD                  25U  			//25 шагов ШИМа. Период ШИМа примерно 211мкс*25
13:            #define MAX_PWM_DUTY_PERCENT        100U
14:            
15:            #define ENABLE_TMR2_INTR            2
16:            #define DISABLE_TMR2_INTR           0
17:            
18:            #define NULL                        0
19:            
20:            #define ACCELERATION_MOTOR			0U
21:            #define WORKING_MOTOR				1U
22:            #define STOPPING_MOTOR				2U
23:            #define BRAKING_MOTOR				3U
24:            
25:            #define CALC_PARAMS									0U
26:            #define ACCELERATION								1U
27:            #define MOTOR_IS_ACCELERATED						2U
28:            
29:            #define MOTOR_IN_START_OR_END_POSITION              1U
30:            #define MOTOR_IN_FAILURE                            2U
31:            #define MOTOR_CHECKING                              0U
32:            
33:            #define TIME_BRAKE_MOTOR_CONST                      50U  	 //время торможения двигателя 20 мс
34:            #define TIME_PAUSE_DISPENSER_CONST                  2000U   //время паузы дозатора при загрузке топлива (в мс)
35:            #define TIME_AGITATOR_SENSOR_SURVEY                 8500U
36:            
37:            //#define TIME_CTRL_LS_AFTER_BEGIN				1500U
38:            //#define TIME_CTRL_LS_AFTER_BEGIN				2000U	  //время (мc), по истечении которого при вращении двигателя должен изменить состояние концевик
39:            #define TIME_CTRL_LS_AFTER_BEGIN				3000U
40:            #define TIME_ROTATE_MOTOR_IN_REVERSE            45U  	 //время (мc) торможения противовключением
41:            //#define TIME_ROTATE_MOTOR_IN_REVERSE          30U
42:            #define TIME_PAUSE_SHATTER_CONST                2000U    //время паузы заслонки при загрузке топлива
43:            
44:            #define TIMER2_INIT_VALUE                       0b00001101
45:            #define TIMER2_OFF_VALUE                        0
46:            
47:            #define FAILURE                                 3U
48:            #define NEED_REVERSE                            2U
49:            #define NEED_NEXT_STEP                          1U
50:            #define IS_BUSY                                 0U
51:            
52:            #define IS_FALSE_LS_FAILURE                     1
53:            #define NO_FALSE_LS_FAILURE                     0
54:            
55:            #define BRAKE_HIGH_SW                           1
56:            #define ROTATE_REVERSE                          0
57:            
58:            
59:            #define QUESTION_LS_FALSE_OFF 		1
60:            #define QUESTION_LS_FALSE_ON 		0
61:            
62:            #define PIN_COMMON_HALF_BRIDGE_H        LATHbits.LATH0     
63:            #define PIN_COMMON_HALF_BRIDGE_L        LATHbits.LATH1
64:            #define TRIS_COMMON_HALF_BRIDGE_H       TRISHbits.TRISH0
65:            #define TRIS_COMMON_HALF_BRIDGE_L       TRISHbits.TRISH1
66:            
67:            #define PIN_AGITATOR_1_SECOND_HALF_H    LATHbits.LATH3
68:            #define PIN_AGITATOR_1_SECOND_HALF_L    LATEbits.LATE0
69:            #define TRIS_AGITATOR_1_SECOND_HALF_H   TRISHbits.TRISH3
70:            #define TRIS_AGITATOR_1_SECOND_HALF_L   TRISEbits.TRISE0
71:            
72:            #define PIN_AGITATOR_2_SECOND_HALF_H    LATHbits.LATH2   
73:            #define PIN_AGITATOR_2_SECOND_HALF_L    LATEbits.LATE1
74:            #define TRIS_AGITATOR_2_SECOND_HALF_H   TRISHbits.TRISH2
75:            #define TRIS_AGITATOR_2_SECOND_HALF_L   TRISEbits.TRISE1
76:            
77:            #define PIN_DISPENSER_SECOND_HALF_H     LATGbits.LATG3
78:            #define PIN_DISPENSER_SECOND_HALF_L     LATGbits.LATG0
79:            #define TRIS_DISPENSER_SECOND_HALF_H    TRISGbits.TRISG3
80:            #define TRIS_DISPENSER_SECOND_HALF_L    TRISGbits.TRISG3
81:            
82:            #define PIN_SHATTER_SECOND_HALF_H       LATFbits.LATF5   
83:            #define PIN_SHATTER_SECOND_HALF_L       LATFbits.LATF6
84:            #define TRIS_SHATTER_SECOND_HALF_H      TRISFbits.TRISF5
85:            #define TRIS_SHATTER_SECOND_HALF_L      TRISFbits.TRISF6
86:            
87:            #define PIN_ASH_CLEANING_SECOND_HALF_H  LATFbits.LATF7
88:            #define PIN_ASH_CLEANING_SECOND_HALF_L  LATGbits.LATG4
89:            #define TRIS_ASH_CLEANING_SECOND_HALF_H TRISFbits.TRISF7
90:            #define TRIS_ASH_CLEANING_SECOND_HALF_L TRISGbits.TRISG4
91:            
92:            typedef struct 
93:            {
94:            	uint16_t time_step_accel;				//для отсчёта времени приращения разгона двигателя
95:            	uint16_t time_work_motor;               //для отсчёта времени максимальной работы двигателя		
96:            	uint16_t time_brake_motor;              //для отсчёта времени торможения двигателя
97:            	uint16_t time_rotate_motor_in_reverse;  //для отсчёта времени реверса двигателя при торможении
98:            	uint16_t time_pause;					//для отсчёта время паузы переж возвращением дозатора или заслонки назад	
99:            	uint16_t time_ctrl_ls_after_begin;		//для отсчёта времени после которого проверяется состояние концевика при вращении двигателя
100:           	uint16_t time_ls_agitator_survey;		//для отсчёта периода проеврки импульса датчика ворошителя
101:           }TIME_M_Motor;
102:           
103:           
104:           //TO DO исправить время работы ворошителя с 15 с на 30 с, время опроса датчика с 5 с на 15 с (#define TIME_AGITATOR_SENSOR_SURVEY)
105:           
106:           uint8_t cnt_duty = 0;
107:           uint8_t accel_state = 0;
108:           uint8_t saved_cnt_duty = 0;
109:           uint8_t M_Motor_PWM_period = 0;
110:           uint8_t M_Motor_state = 0;
111:           BOOL ctrl = OFF;
112:           uint8_t direction = TO_FORWARD_DISPENSER;
113:           uint8_t num_motor = 0;
114:           uint8_t ctrl_shatter = NO_MOVEMENT;  //для управления заслонкой в режиме чистки дымохода
115:           uint8_t cnt_step = 0;
116:           BOOL M_Motor_false_state_LS[QUANTITY_FALSE_LS] = {0, 0, 0, 0, 0};   				//для опроса ложно сработанных концевиков
117:           BOOL M_Motor_direction_question_LS[QUANTITY_FALSE_LS] = {0, 0, 0, 0, 0};  	//1 - опрос на ложное отключение, 0 - опрос на ложное включение
118:           BOOL* temp_start_ls = NULL;
119:           uint8_t temp_index;
120:           uint8_t M_Motor_prev_state = 0;
121:           
122:           TIME_M_Motor time_M_Motor = {0, 0, 0, 0, 0, 0, 0};
123:           FailureMotor M_Motor_failure_motor[QUANTITY_MOTORS] = {{0, 0}, {0, 0}, {0,0}}; 
124:           
125:           
126:           /* Массив структур пинов верхних и нижних ключей для вращения двигателя в прямом направлении */
127:           const rom IOport_motor motor_pins_forward[QUANTITY_MOTORS] =
128:           {
129:           	//дозатор
130:           	{
131:                   (volatile uint8_t* const)&LATH, 0,  //верхний ключ 1-го полумоста
132:                   (volatile uint8_t* const)&LATG, 0   //нижний ключ 2-го полумоста
133:               }, 			
134:           	
135:           	//ворошитель
136:           	{
137:                   (volatile uint8_t* const)&LATH, 0,	//верхний ключ 1-го полумоста
138:                   (volatile uint8_t* const)&LATE, 0   //нижний ключ 3-го полумоста
139:               }, 			
140:           	
141:               //заслонка 
142:           	{
143:                   (volatile uint8_t* const)&LATH, 0,		//верхний ключ 1-го полумоста
144:                   (volatile uint8_t* const)&LATG, 4       //нижний ключ 5-го полумоста
145:               },			
146:               
147:               //чистка золы
148:               {
149:                   (volatile uint8_t* const)&LATH, 0,		//верхний ключ 1-го полумоста
150:                   (volatile uint8_t* const)&LATF, 6       //нижний ключ 4-го полумоста
151:               }
152:           };
153:           
154:           /* Массив структур верхних и нижних ключей для вращения двигателя в обратном направлении */
155:           const rom IOport_motor motor_pins_backward[QUANTITY_MOTORS] =
156:           {
157:           	//дозатор
158:           	{
159:                   (volatile uint8_t* const)&LATG, 3,	//верхний ключ 2-го полумоста
160:                   (volatile uint8_t* const)&LATH, 1   //нижний ключ 1-го полумоста
161:               }, 		
162:           
163:           	//ворошитель
164:           	{
165:                   (volatile uint8_t* const)&LATH, 3,	//верхний ключ 3-го полумоста
166:                   (volatile uint8_t* const)&LATH, 1   //нижний ключ 1-го полумоста
167:               }, 		
168:               	
169:               //заслонка 
170:           	{
171:                   (volatile uint8_t* const)&LATF, 5,	//верхний ключ 4-го полумоста
172:                   (volatile uint8_t* const)&LATH, 1   //нижний ключ 1-го полумоста
173:               },		
174:               
175:               //чистка золы
176:               {
177:                   (volatile uint8_t* const)&LATF, 7,	//верхний ключ 1-го полумоста
178:                   (volatile uint8_t* const)&LATH, 1   //нижний ключ 1-го полумоста
179:               }
180:           };
181:           
182:           /* Массив структур верхних ключей двух полумостов для торможения */
183:           const rom IOport_motor  motor_pins_brake_high_sw[QUANTITY_MOTORS] = 
184:           {
185:           	//дозатор
186:           	{
187:                   (volatile uint8_t* const)&LATH, 0,	//верхний ключ 1-го полумоста
188:                   (volatile uint8_t* const)&LATG, 3   //верхний ключ 2-го полумоста
189:               }, 		
190:           
191:           	//ворошитель
192:           	{
193:                   (volatile uint8_t* const)&LATH, 0,	//верхний ключ 1-го полумоста
194:                   (volatile uint8_t* const)&LATH, 3   //верхний ключ 3-го полумоста
195:               }, 		
196:           
197:           	//заслонка 
198:           	{
199:                   (volatile uint8_t* const)&LATH, 0,	//верхний ключ 1-го полумоста
200:                   (volatile uint8_t* const)&LATF, 5   //верхний ключ 4-го полумоста
201:               },		
202:               
203:               //чистка золы
204:               {
205:                   (volatile uint8_t* const)&LATH, 0,		//верхний ключ 1-го полумоста
206:                   (volatile uint8_t* const)&LATF, 7   //нижний ключ 1-го полумоста
207:               }
208:           };
209:           
210:           /* Массив структур нижних ключей двух полумостов для торможения */
211:           const rom IOport_motor  motor_pins_brake_low_sw[QUANTITY_MOTORS] = 
212:           {
213:           	//дозатор
214:           	{
215:                   (volatile uint8_t* const)&LATH, 1,	//нижний ключ 1-го полумоста
216:                   (volatile uint8_t* const)&LATG, 0   //нижний ключ 2-го полумоста
217:               }, 		
218:           
219:           	//ворошитель
220:           	{
221:                   (volatile uint8_t* const)&LATH, 1,	//нижний ключ 1-го полумоста
222:                   (volatile uint8_t* const)&LATE, 0   //нижний ключ 3-го полумоста
223:               }, 		
224:           
225:           	//заслонка 
226:           	{
227:                   (volatile uint8_t* const)&LATH, 1,	//нижний ключ 1-го полумоста
228:                   (volatile uint8_t* const)&LATG, 4   //нижний ключ 4-го полумоста
229:               },		
230:           
231:               //чистка золы 
232:           	{
233:                   (volatile uint8_t* const)&LATH, 1,	//нижний ключ 1-го полумоста
234:                   (volatile uint8_t* const)&LATF, 6   //нижний ключ 4-го полумоста
235:               }	
236:           };
237:           
238:           const rom IOport_motor*  ptr_to_motor_pins = &motor_pins_forward [INDEX_OF_DISPENSER]; 
239:           											
240:           //Локальные функции модуля 
241:           static BOOL    M_Motor_check_ls_after_begin_start(BOOL ls, uint8_t index);
242:           static void    M_Motor_check_false_LS (LimitSwitch* struct_ls, const uint8_t size);
243:           static void    M_motor_forming_direction_question_LS(BOOL disp_st, BOOL disp_fin, BOOL shat_st, BOOL shat_fin, BOOL shat_after_fin);
244:           static uint8_t M_Motor_check_motor(uint8_t index, BOOL limit_switch, uint8_t type_of_ls, uint8_t* cnt_fail);
245:           static BOOL    M_Motor_is_brake(const rom IOport_motor* motor_pins, uint8_t which_ls, uint8_t num);
246:           static void    M_Motor_Timer2_change(const uint8_t value_timer_ctrl, const uint8_t en_intr);
247:           static void    M_Motor_clear_accel_state ( void );
248:           static uint8_t M_Motor_rotate (uint8_t index, BOOL limit_switch, uint8_t type_of_ls );
249:           static void    M_Motor_is_stopped ( const rom IOport_motor* motor_pins );
250:           static void    M_Motor_is_worked ( const rom IOport_motor* motor_pins );
251:           static void    M_Motor_accel ( uint8_t index );
252:           
253:           
254:           void M_Motor_ctor( void )
255:           {
256:               PIN_COMMON_HALF_BRIDGE_H           = OFF;         
0088  9090     BCF LATH, 0, ACCESS
257:               PIN_COMMON_HALF_BRIDGE_L           = OFF;  
008A  9290     BCF LATH, 1, ACCESS
258:               TRIS_COMMON_HALF_BRIDGE_H          = OUT;  
008C  9099     BCF TRISH, 0, ACCESS
259:               TRIS_COMMON_HALF_BRIDGE_L          = OUT;  
008E  9299     BCF TRISH, 1, ACCESS
260:           
261:               PIN_AGITATOR_1_SECOND_HALF_H       = OFF;   
0090  9690     BCF LATH, 3, ACCESS
262:               PIN_AGITATOR_1_SECOND_HALF_L       = OFF; 
0092  908D     BCF LATE, 0, ACCESS
263:               TRIS_AGITATOR_1_SECOND_HALF_H      = OUT; 
0094  9699     BCF TRISH, 3, ACCESS
264:               TRIS_AGITATOR_1_SECOND_HALF_L      = OUT; 
0096  9096     BCF TRISE, 0, ACCESS
265:           
266:               PIN_AGITATOR_2_SECOND_HALF_H       = OFF;           
0098  9490     BCF LATH, 2, ACCESS
267:               PIN_AGITATOR_2_SECOND_HALF_L       = OFF;    
009A  928D     BCF LATE, 1, ACCESS
268:               TRIS_AGITATOR_2_SECOND_HALF_H      = OUT; 
009C  9499     BCF TRISH, 2, ACCESS
269:               TRIS_AGITATOR_2_SECOND_HALF_L      = OUT; 
009E  9296     BCF TRISE, 1, ACCESS
270:           
271:               PIN_DISPENSER_SECOND_HALF_H        = OFF;     
00A0  968F     BCF LATG, 3, ACCESS
272:               PIN_DISPENSER_SECOND_HALF_L        = OFF;     
00A2  908F     BCF LATG, 0, ACCESS
273:               TRIS_DISPENSER_SECOND_HALF_H       = OUT; 
00A4  9698     BCF TRISG, 3, ACCESS
274:               TRIS_DISPENSER_SECOND_HALF_L       = OUT; 
00A6  9698     BCF TRISG, 3, ACCESS
275:           
276:               PIN_SHATTER_SECOND_HALF_H          = OFF;      
00A8  9A8E     BCF LATF, 5, ACCESS
277:               PIN_SHATTER_SECOND_HALF_L          = OFF;        
00AA  9C8E     BCF LATF, 6, ACCESS
278:               TRIS_SHATTER_SECOND_HALF_H         = OUT; 
00AC  9A97     BCF TRISF, 5, ACCESS
279:               TRIS_SHATTER_SECOND_HALF_L         = OUT; 
00AE  9C97     BCF TRISF, 6, ACCESS
280:           
281:               PIN_ASH_CLEANING_SECOND_HALF_H     = OFF;  
00B0  9E8E     BCF LATF, 7, ACCESS
282:               PIN_ASH_CLEANING_SECOND_HALF_L     = OFF;   
00B2  988F     BCF LATG, 4, ACCESS
283:               TRIS_ASH_CLEANING_SECOND_HALF_H    = OUT; 
00B4  9E97     BCF TRISF, 7, ACCESS
284:               TRIS_ASH_CLEANING_SECOND_HALF_L    = OUT; 
00B6  9898     BCF TRISG, 4, ACCESS
285:           }
00B8  0012     RETURN 0
286:           
287:           
288:           void M_Motor_clear_parameters(void)
289:           {
290:           	M_Motor_state = STATE_MODULE_MOTOR_WAITING;
00BA  0100     MOVLB 0x0
00BC  0E01     MOVLW 0x1
00BE  6F64     MOVWF M_Motor_state, BANKED
291:           	direction = TO_FORWARD_DISPENSER;
00C0  6F66     MOVWF direction, BANKED
292:           	cnt_step = 0;
00C2  6B69     CLRF cnt_step, BANKED
293:           	num_motor = INDEX_OF_AGITATOR;
00C4  6F67     MOVWF num_motor, BANKED
294:           	ctrl = OFF;
00C6  6B65     CLRF ctrl, BANKED
295:           }
00C8  0012     RETURN 0
296:           
297:           /* 
298:           Функция проверки изменения состояния концевика после начала вращения двигателя 
299:           через время TIME_CTRL_LS_AFTER_BEGIN 
300:           Входные параметры:
301:           
302:           */
303:           static BOOL M_Motor_check_ls_after_begin_start(BOOL ls, uint8_t index)
00CA  EC45     CALL 0xC8A, 0
00CC  F006     NOP
0C8A  DF1B     RCALL __pa_5
304:           {
305:           	if(M_LI_Get_Limit_Switches()->ls_hopper_cover_state)  //в режиме "Пауза эта проверка не делается"
00CE  E024     BZ 0x118
0C8C  DEF3     RCALL __pa_0
0C8E  EFD4     GOTO 0xBA8
0C90  F005     NOP
306:           	{
307:           		if(time_M_Motor.time_ctrl_ls_after_begin++ == TIME_CTRL_LS_AFTER_BEGIN )
00D0  0100     MOVLB 0x0
00D2  C085     MOVFF 0x85, __tmp_0
00D4  F032     NOP
00D6  C086     MOVFF 0x86, 0x33
00D8  F033     NOP
00DA  2B85     INCF 0x85, F, BANKED
00DC  0E00     MOVLW 0x0
00DE  2386     ADDWFC 0x86, F, BANKED
00E0  0EB8     MOVLW 0xB8
00E2  1832     XORWF __tmp_0, W, ACCESS
00E4  E119     BNZ 0x118
00E6  0E0B     MOVLW 0xB
00E8  1833     XORWF 0x33, W, ACCESS
00EA  E116     BNZ 0x118
308:           		{
309:           			M_Motor_false_state_LS[index] = ls;
00EC  0EFD     MOVLW 0xFD
00EE  50DB     MOVF PLUSW2, W, ACCESS
00F0  6AEA     CLRF FSR0H, ACCESS
00F2  0F6A     ADDLW 0x6A
00F4  6EE9     MOVWF FSR0, ACCESS
00F6  0E00     MOVLW 0x0
00F8  22EA     ADDWFC FSR0H, F, ACCESS
00FA  0EFE     MOVLW 0xFE
00FC  CFDB     MOVFF PLUSW2, INDF0
00FE  FFEF     NOP
310:           			time_M_Motor.time_ctrl_ls_after_begin = 0;
0100  6B85     CLRF 0x85, BANKED
0102  6B86     CLRF 0x86, BANKED
311:           			if(ls)
0104  50DB     MOVF PLUSW2, W, ACCESS
0106  E006     BZ 0x114
312:           			{	
313:           				M_Motor_state = STATE_MODULE_MOTOR_FAILURE;			
0108  0E02     MOVLW 0x2
010A  6F64     MOVWF M_Motor_state, BANKED
314:           			 	M_Motor_is_stopped(ptr_to_motor_pins);
010C  EC6A     CALL 0xAD4, 0
010E  F005     NOP
315:           			 	return IS_FALSE_LS_FAILURE;
0110  0E01     MOVLW 0x1
0112  D003     BRA 0x11A
316:           			}
317:           			else
318:           				return NO_FALSE_LS_FAILURE;
0114  0E00     MOVLW 0x0
0116  D001     BRA 0x11A
319:           		}	
320:           	}
321:           	return NO_FALSE_LS_FAILURE;
0118  0E00     MOVLW 0x0
322:           }
011A  EF66     GOTO 0xACC
011C  F005     NOP
323:           
324:           /* Формирование маски опроса концевиков в массив M_Motor_direction_question_LS */
325:           static void M_motor_forming_direction_question_LS(BOOL disp_st, BOOL disp_fin, BOOL shat_st, BOOL shat_fin, BOOL shat_after_fin)
011E  EC58     CALL 0xCB0, 0
0120  F006     NOP
326:           {
327:           	M_Motor_direction_question_LS[0] = disp_st; 
0122  CFDB     MOVFF PLUSW2, M_Motor_direction_question_LS
0124  F071     NOP
328:           	M_Motor_direction_question_LS[1] = disp_fin;
0126  0EFD     MOVLW 0xFD
0128  CFDB     MOVFF PLUSW2, 0x72
012A  F072     NOP
329:           	M_Motor_direction_question_LS[2] = shat_st;
012C  0EFC     MOVLW 0xFC
012E  CFDB     MOVFF PLUSW2, 0x73
0130  F073     NOP
330:           	M_Motor_direction_question_LS[3] = shat_fin;
0132  0EFB     MOVLW 0xFB
0134  CFDB     MOVFF PLUSW2, 0x74
0136  F074     NOP
331:           	M_Motor_direction_question_LS[4] = shat_after_fin;
0138  0EFA     MOVLW 0xFA
013A  CFDB     MOVFF PLUSW2, 0x75
013C  F075     NOP
332:           }
013E  EF66     GOTO 0xACC
0140  F005     NOP
333:           
334:           void M_Motor_clear_false_state_LS(const uint8_t size)
0142  EC38     CALL 0xC70, 0
0144  F006     NOP
335:           {
336:           	uint8_t counter;	
337:           
338:           	for(counter = 0; counter < size; counter++)
0146  0EFE     MOVLW 0xFE
0148  50DB     MOVF PLUSW2, W, ACCESS
014A  5CDF     SUBWF INDF2, W, ACCESS
014C  E203     BC 0x154
0152  D7F9     BRA 0x146
0B96  2ADF     INCF INDF2, F, ACCESS
0B98  0012     RETURN 0
339:           	{
340:           		M_Motor_false_state_LS[counter] = 0;
014E  ECC4     CALL 0xB88, 0
0150  F005     NOP
0B88  50DF     MOVF INDF2, W, ACCESS
0B8A  6AEA     CLRF FSR0H, ACCESS
0B8C  0F6A     ADDLW 0x6A
0B8E  6EE9     MOVWF FSR0, ACCESS
0B90  0E00     MOVLW 0x0
0B92  22EA     ADDWFC FSR0H, F, ACCESS
0B94  6AEF     CLRF INDF0, ACCESS
341:           	}
342:           }
0154  52E5     MOVF POSTDEC1, F, ACCESS
0156  EF66     GOTO 0xACC
0158  F005     NOP
343:           
344:           /* Проверка ложного состояния концевиков в отстутствие вращения двигателей */
345:           static void M_Motor_check_false_LS (LimitSwitch* struct_ls, const uint8_t size)
015A  EC38     CALL 0xC70, 0
015C  F006     NOP
346:           {
347:           	uint8_t counter;	
348:           
349:           	for(counter = 0; counter < size; counter++)
015E  0EFC     MOVLW 0xFC
0160  50DB     MOVF PLUSW2, W, ACCESS
0162  5CDF     SUBWF INDF2, W, ACCESS
0164  E203     BC 0x16C
016A  D7F9     BRA 0x15E
350:           	{
351:           		#ifdef NO_CONTROL_FALSE_STATE_LS
352:           			M_Motor_false_state_LS[counter] = 0;
0166  ECC4     CALL 0xB88, 0
0168  F005     NOP
353:           		#else
354:           			M_Motor_false_state_LS[counter] = *((BOOL*)struct_ls + counter) ^ M_Motor_direction_question_LS[counter] ;
355:           		#endif
356:           	}
357:           }
016C  52E5     MOVF POSTDEC1, F, ACCESS
016E  EF66     GOTO 0xACC
0170  F005     NOP
358:           
359:           BOOL* M_Motor_get_false_state_LS(void)
360:           {
361:           	return M_Motor_false_state_LS;
0172  0E6A     MOVLW 0x6A
0174  6E32     MOVWF __tmp_0, ACCESS
0176  0E00     MOVLW 0x0
0178  C032     MOVFF __tmp_0, PROD
017A  FFF3     NOP
017C  6EF4     MOVWF PRODH, ACCESS
362:           }
017E  0012     RETURN 0
363:           
364:           void M_Motor_set_state (uint8_t value)
0180  EC58     CALL 0xCB0, 0
0182  F006     NOP
365:           {
366:           	M_Motor_state = value;
0184  CFDB     MOVFF PLUSW2, M_Motor_state
0186  F064     NOP
367:           }
0188  EF66     GOTO 0xACC
018A  F005     NOP
368:           
369:           uint8_t M_Motor_get_direction(void)
370:           {
371:           	return direction;
018C  0100     MOVLB 0x0
018E  5166     MOVF direction, W, BANKED
372:           }
0190  0012     RETURN 0
373:           
374:           void M_Motor_set_work (BOOL value)
0192  EC58     CALL 0xCB0, 0
0194  F006     NOP
375:           {
376:           	ctrl = value;
0196  CFDB     MOVFF PLUSW2, ctrl
0198  F065     NOP
377:           }
019A  EF66     GOTO 0xACC
019C  F005     NOP
378:           
379:           BOOL M_Motor_get_work(void)
380:           {
381:           	return ctrl;
019E  0100     MOVLB 0x0
01A0  5165     MOVF ctrl, W, BANKED
382:           }
01A2  0012     RETURN 0
383:           
384:           uint8_t	M_Motor_get_state(void)
385:           {
386:           	return M_Motor_state;
01A4  0100     MOVLB 0x0
01A6  5164     MOVF M_Motor_state, W, BANKED
387:           }
01A8  0012     RETURN 0
388:           
389:           void M_Motor_set_ctrl_shatter (uint8_t value)
01AA  EC58     CALL 0xCB0, 0
01AC  F006     NOP
390:           {
391:           	ctrl_shatter = value;
01AE  CFDB     MOVFF PLUSW2, ctrl_shatter
01B0  F068     NOP
392:           }
01B2  EF66     GOTO 0xACC
01B4  F005     NOP
393:           
394:           uint8_t M_Motor_get_ctrl_shatter (void)
395:           {
396:           	return ctrl_shatter;
01B6  0100     MOVLB 0x0
01B8  5168     MOVF ctrl_shatter, W, BANKED
397:           }
01BA  0012     RETURN 0
398:           
399:           
400:           FailureMotor* M_Motor_get_state_failure(uint8_t index)
01BC  EC61     CALL 0xAC2, 0
01BE  F005     NOP
401:           {
402:           	return &M_Motor_failure_motor[index];
01C0  0EFE     MOVLW 0xFE
01C2  6A33     CLRF 0x33, ACCESS
01C4  34DB     RLCF PLUSW2, W, ACCESS
01C6  ECEB     CALL 0xBD6, 0
01C8  F005     NOP
01CA  C032     MOVFF __tmp_0, PROD
01CC  FFF3     NOP
01CE  C033     MOVFF 0x33, PRODH
01D0  FFF4     NOP
0BD6  0BFE     ANDLW 0xFE
0BD8  3633     RLCF 0x33, F, ACCESS
0BDA  6E32     MOVWF __tmp_0, ACCESS
0BDC  0E89     MOVLW 0x89
0BDE  2632     ADDWF __tmp_0, F, ACCESS
0BE0  0E00     MOVLW 0x0
0BE2  2233     ADDWFC 0x33, F, ACCESS
0BE4  0012     RETURN 0
403:           }
01D2  EF66     GOTO 0xACC
01D4  F005     NOP
404:           
405:           void M_Motor_clear_struct_failure_motor(void)
01D6  EC38     CALL 0xC70, 0
01D8  F006     NOP
406:           {
407:           	uint8_t count;
408:           	for(count = 0; count < SIZE_STRUCT_MOTORS; count++)
01DA  0E04     MOVLW 0x4
01DC  5CDF     SUBWF INDF2, W, ACCESS
01DE  E212     BC 0x204
0200  2ADF     INCF INDF2, F, ACCESS
0202  D7EB     BRA 0x1DA
409:           		memset(&M_Motor_failure_motor[count], 0, sizeof M_Motor_failure_motor[count]);
01E0  0E02     MOVLW 0x2
01E2  6EE6     MOVWF POSTINC1, ACCESS
01E4  6AE6     CLRF POSTINC1, ACCESS
01E6  6AE6     CLRF POSTINC1, ACCESS
01E8  6A33     CLRF 0x33, ACCESS
01EA  34DF     RLCF INDF2, W, ACCESS
01EC  ECEB     CALL 0xBD6, 0
01EE  F005     NOP
01F0  EC30     CALL 0xC60, 0
01F2  F006     NOP
01F4  EC1A     CALL 0x3634, 0
01F6  F01B     NOP
01F8  6E34     MOVWF 0x34, ACCESS
01FA  0E05     MOVLW 0x5
01FC  5EE1     SUBWF FSR1, F, ACCESS
01FE  5034     MOVF 0x34, W, ACCESS
410:           	memset(&time_M_Motor, 0, sizeof time_M_Motor);
0204  0E0E     MOVLW 0xE
0206  6EE6     MOVWF POSTINC1, ACCESS
0208  6AE6     CLRF POSTINC1, ACCESS
020A  6AE6     CLRF POSTINC1, ACCESS
020C  0E7B     MOVLW 0x7B
020E  6EE6     MOVWF POSTINC1, ACCESS
0210  0E00     MOVLW 0x0
0212  6EE6     MOVWF POSTINC1, ACCESS
0214  EC1A     CALL 0x3634, 0
0216  F01B     NOP
0218  EC4E     CALL 0xC9C, 0
021A  F006     NOP
411:           }
021C  52E5     MOVF POSTDEC1, F, ACCESS
021E  EF66     GOTO 0xACC
0220  F005     NOP
412:           
413:           
414:           uint8_t M_Motor_get_prev_state(void)
415:           {
416:           	return M_Motor_prev_state;
0222  0100     MOVLB 0x0
0224  517A     MOVF M_Motor_prev_state, W, BANKED
417:           }
0226  0012     RETURN 0
418:           
419:           
420:           /*Установка двигателей в начальное положение
421:           Входные параметры: 
422:           - индекс массива структур двигателей index
423:           - состояние соответствующего стартового концевика limit_switch
424:           - тип концевика type_of_ls
425:           */
426:           static uint8_t M_Motor_rotate(uint8_t index, BOOL limit_switch, uint8_t type_of_ls)
0228  EC38     CALL 0xC70, 0
022A  F006     NOP
0C70  DF28     RCALL __pa_5
0C72  52E6     MOVF POSTINC1, F, ACCESS
427:           {
428:           	
429:           	uint8_t pos_motor = MOTOR_CHECKING; 
0C74  6ADF     CLRF INDF2, ACCESS
0C76  0012     RETURN 0
430:           	static BOOL is_motor_failure = FALSE;
431:           	
432:           	if(!M_LI_Get_Limit_Switches()->ls_hopper_cover_state )
022C  EC3A     CALL 0xA74, 0
022E  F005     NOP
0230  ECD4     CALL 0xBA8, 0
0232  F005     NOP
0234  E103     BNZ 0x23C
433:           	{
434:           		M_Motor_is_stopped(ptr_to_motor_pins);
0236  EC6A     CALL 0xAD4, 0
0238  F005     NOP
435:           	}
436:           	else
023A  D0E8     BRA 0x40C
437:           	{
438:           		switch(cnt_step) 
023C  0100     MOVLB 0x0
023E  5169     MOVF cnt_step, W, BANKED
0240  0A03     XORLW 0x3
0242  E101     BNZ 0x246
0244  D0B1     BRA 0x3A8
0246  0A01     XORLW 0x1
0248  E101     BNZ 0x24C
024A  D0A8     BRA 0x39C
024C  0A03     XORLW 0x3
024E  E026     BZ 0x29C
0250  0A01     XORLW 0x1
0252  E001     BZ 0x256
0254  D0DB     BRA 0x40C
439:           		{
440:           			case ACCELERATION_MOTOR:   		//состояние разгона двигателя
441:           				if(limit_switch && type_of_ls != AGITATOR_LS) //двигатель в стартовом положении, переход на останов (не проверять для датчика ворошителя) 
0256  0EFD     MOVLW 0xFD
0258  50DB     MOVF PLUSW2, W, ACCESS
025A  E014     BZ 0x284
025C  ECC0     CALL 0xB80, 0
025E  F005     NOP
0260  E011     BZ 0x284
442:           				{
443:           					if(!accel_state)
0262  5161     MOVF accel_state, W, BANKED
0264  E103     BNZ 0x26C
444:           					{
445:           						pos_motor =  MOTOR_IN_START_OR_END_POSITION;
0266  0E01     MOVLW 0x1
0268  6EDF     MOVWF INDF2, ACCESS
446:           						break;		
026A  D0D0     BRA 0x40C
447:           					}
448:           					else
449:           					{
450:           						M_Motor_is_stopped(ptr_to_motor_pins);
026C  EC6A     CALL 0xAD4, 0
026E  F005     NOP
451:           						M_Motor_failure_motor[index].is_failure = OFF;
0270  EC4E     CALL 0xA9C, 0
0272  F005     NOP
0274  6AEF     CLRF INDF0, ACCESS
452:           						M_Motor_clear_accel_state();
0276  DACE     RCALL M_Motor_clear_accel_state
453:           						time_M_Motor.time_step_accel = 0;
0278  0100     MOVLB 0x0
027A  6B7B     CLRF time_M_Motor, BANKED
027C  6B7C     CLRF 0x7C, BANKED
454:           						cnt_step = STOPPING_MOTOR;
027E  0E02     MOVLW 0x2
0280  6F69     MOVWF cnt_step, BANKED
455:           						 is_motor_failure = FALSE;
456:           						break;
0282  D021     BRA 0x2C6
457:           					}
458:           				}
459:           				M_Motor_accel(index); 							//разогнать двигатель
0284  0EFE     MOVLW 0xFE
0286  CFDB     MOVFF PLUSW2, POSTINC1
0288  FFE6     NOP
028A  DB3C     RCALL M_Motor_accel
028C  52E5     MOVF POSTDEC1, F, ACCESS
460:           				if (accel_state == MOTOR_IS_ACCELERATED) 		//если двигатель разогнан
028E  0E02     MOVLW 0x2
0290  0100     MOVLB 0x0
0292  5D61     SUBWF accel_state, W, BANKED
0294  E001     BZ 0x298
0296  D0BA     BRA 0x40C
461:           				{
462:           					M_Motor_clear_accel_state(); 	
0298  DABD     RCALL M_Motor_clear_accel_state
463:           					cnt_step++; 									//перейти к счёту максимального времени работы двигателя
464:           				}	
465:           				break;
029A  D083     BRA 0x3A2
466:           			case WORKING_MOTOR:			//рабочее состояние двигателя (работа на максимальных оборотах)
467:           				M_Motor_is_worked(ptr_to_motor_pins); 		//включить соответствующий верхний и нижний ключ статически
029C  C091     MOVFF ptr_to_motor_pins, POSTINC1
029E  FFE6     NOP
02A0  C092     MOVFF 0x92, POSTINC1
02A2  FFE6     NOP
02A4  EC0C     CALL 0xC18, 0
02A6  F006     NOP
468:           				if(limit_switch && type_of_ls != AGITATOR_LS) //двигатель в стартовом положении 
02A8  0EFD     MOVLW 0xFD
02AA  50DB     MOVF PLUSW2, W, ACCESS
02AC  E00E     BZ 0x2CA
02AE  ECC0     CALL 0xB80, 0
02B0  F005     NOP
02B2  E00B     BZ 0x2CA
469:           				{
470:           					cnt_step++;
02B4  0100     MOVLB 0x0
02B6  2B69     INCF cnt_step, F, BANKED
471:           					time_M_Motor.time_work_motor = 0;
02B8  6B7D     CLRF 0x7D, BANKED
02BA  6B7E     CLRF 0x7E, BANKED
472:           					M_Motor_failure_motor[index].is_failure = OFF;
02BC  DBEF     RCALL __pa_3
02BE  6AEF     CLRF INDF0, ACCESS
473:           					M_Motor_is_stopped(ptr_to_motor_pins);
02C0  EC6A     CALL 0xAD4, 0
02C2  F005     NOP
474:           					is_motor_failure = FALSE;
02C4  0100     MOVLB 0x0
02C6  6B93     CLRF 0x93, BANKED
475:           					break;
02C8  D0A1     BRA 0x40C
476:           				}
477:           				else if(type_of_ls == AGITATOR_LS)  //для ворошителя
02CA  ECC0     CALL 0xB80, 0
02CC  F005     NOP
02CE  E122     BNZ 0x314
478:           				{
479:           					//если отсчитан интервал опроса датчика ворошителя
480:           					if(time_M_Motor.time_ls_agitator_survey ++ == TIME_AGITATOR_SENSOR_SURVEY )
02D0  0100     MOVLB 0x0
02D2  C087     MOVFF 0x87, __tmp_0
02D4  F032     NOP
02D6  C088     MOVFF 0x88, 0x33
02D8  F033     NOP
02DA  2B87     INCF 0x87, F, BANKED
02DC  0E00     MOVLW 0x0
02DE  2388     ADDWFC 0x88, F, BANKED
02E0  0E34     MOVLW 0x34
02E2  1832     XORWF __tmp_0, W, ACCESS
02E4  E117     BNZ 0x314
02E6  0E21     MOVLW 0x21
02E8  1833     XORWF 0x33, W, ACCESS
02EA  E114     BNZ 0x314
481:           					{
482:           						time_M_Motor.time_ls_agitator_survey = 0;
02EC  6B87     CLRF 0x87, BANKED
02EE  6B88     CLRF 0x88, BANKED
483:           						if(Intr_get_is_impulse_agitator_sensor())  //за период опроса был импульс на датчике	
02F0  EC42     CALL 0x2E84, 0
02F2  F017     NOP
02F4  0900     IORLW 0x0
02F6  E005     BZ 0x302
484:           						{
485:           							Intr_set_is_impulse_agitator_sensor(FALSE);	
02F8  6AE6     CLRF POSTINC1, ACCESS
02FA  EC45     CALL 0x2E8A, 0
02FC  F017     NOP
02FE  52E5     MOVF POSTDEC1, F, ACCESS
486:           						}
487:           						else  //переход к торможению двигателя и установке признака аварии
0300  D009     BRA 0x314
488:           						{
489:           							time_M_Motor.time_work_motor = 0;
0302  0100     MOVLB 0x0
0304  6B7D     CLRF 0x7D, BANKED
0306  6B7E     CLRF 0x7E, BANKED
490:           							cnt_step++;
0308  2B69     INCF cnt_step, F, BANKED
491:           							M_Motor_is_stopped(ptr_to_motor_pins);
030A  DBE4     RCALL __pa_7
492:           							is_motor_failure = TRUE;
030C  0100     MOVLB 0x0
030E  0E01     MOVLW 0x1
0310  6F93     MOVWF 0x93, BANKED
493:           							break;
0312  D07C     BRA 0x40C
494:           						}
495:           					}
496:           				}
497:           				//если отсчёт максимального времени работы двигателя окончен, а стартовый концевик не сработал
498:           				if(time_M_Motor.time_work_motor++ == (M_Mngm_Get_parameters_buffer()->menu_parameters.Motor[index].max_time_work)*1000U)
0314  0100     MOVLB 0x0
0316  C07D     MOVFF 0x7D, __tmp_0
0318  F032     NOP
031A  C07E     MOVFF 0x7E, 0x33
031C  F033     NOP
031E  2B7D     INCF 0x7D, F, BANKED
0320  0E00     MOVLW 0x0
0322  237E     ADDWFC 0x7E, F, BANKED
0324  EC30     CALL 0xC60, 0
0326  F006     NOP
0328  ECFE     CALL 0x15FC, 0
032A  F00A     NOP
032C  52E5     MOVF POSTDEC1, F, ACCESS
032E  CFE7     MOVFF INDF1, 0x33
0330  F033     NOP
0332  ECF3     CALL 0xBE6, 0
0334  F005     NOP
0336  CFF3     MOVFF PROD, 0x36
0338  F036     NOP
033A  CFF4     MOVFF PRODH, 0x37
033C  F037     NOP
033E  0EFE     MOVLW 0xFE
0340  50DB     MOVF PLUSW2, W, ACCESS
0342  0D04     MULLW 0x4
0344  5036     MOVF 0x36, W, ACCESS
0346  24F3     ADDWF PROD, W, ACCESS
0348  6EE9     MOVWF FSR0, ACCESS
034A  5037     MOVF 0x37, W, ACCESS
034C  20F4     ADDWFC PRODH, W, ACCESS
034E  6EEA     MOVWF FSR0H, ACCESS
0350  52EE     MOVF POSTINC0, F, ACCESS
0352  50EF     MOVF INDF0, W, ACCESS
0354  6E34     MOVWF 0x34, ACCESS
0356  6A35     CLRF 0x35, ACCESS
0358  0EE8     MOVLW 0xE8
035A  0235     MULWF 0x35, ACCESS
035C  CFF3     MOVFF PROD, 0x35
035E  F035     NOP
0360  0E03     MOVLW 0x3
0362  0234     MULWF 0x34, ACCESS
0364  50F3     MOVF PROD, W, ACCESS
0366  2635     ADDWF 0x35, F, ACCESS
0368  0EE8     MOVLW 0xE8
036A  0234     MULWF 0x34, ACCESS
036C  CFF3     MOVFF PROD, 0x34
036E  F034     NOP
0370  50F4     MOVF PRODH, W, ACCESS
0372  2635     ADDWF 0x35, F, ACCESS
0374  50F3     MOVF PROD, W, ACCESS
0376  1832     XORWF __tmp_0, W, ACCESS
0378  E149     BNZ 0x40C
037A  5035     MOVF 0x35, W, ACCESS
037C  1833     XORWF 0x33, W, ACCESS
037E  E146     BNZ 0x40C
0BE6  52E5     MOVF POSTDEC1, F, ACCESS
0BE8  CFE7     MOVFF INDF1, __tmp_0
0BEA  F032     NOP
0BEC  EF53     GOTO 0xCA6
0BEE  F006     NOP
0CA6  CFF3     MOVFF PROD, FSR0
0CA8  FFE9     NOP
0CAA  CFF4     MOVFF PRODH, FSR0H
0CAC  FFEA     NOP
0CAE  0012     RETURN 0
499:           				{
500:           					cnt_step++;
0380  0100     MOVLB 0x0
0382  2B69     INCF cnt_step, F, BANKED
501:           					Intr_set_is_impulse_agitator_sensor(FALSE);
0384  6AE6     CLRF POSTINC1, ACCESS
0386  EC45     CALL 0x2E8A, 0
0388  F017     NOP
038A  52E5     MOVF POSTDEC1, F, ACCESS
502:           					time_M_Motor.time_ls_agitator_survey = 0;
038C  0100     MOVLB 0x0
038E  6B87     CLRF 0x87, BANKED
0390  6B88     CLRF 0x88, BANKED
503:           					M_Motor_is_stopped(ptr_to_motor_pins);
0392  DBA0     RCALL __pa_7
0AD4  C091     MOVFF ptr_to_motor_pins, POSTINC1
0AD6  FFE6     NOP
0AD8  C092     MOVFF 0x92, POSTINC1
0ADA  FFE6     NOP
0ADC  EF3C     GOTO 0xC78
0ADE  F006     NOP
0C78  DE31     RCALL M_Motor_is_stopped
0C7A  52E5     MOVF POSTDEC1, F, ACCESS
0C7C  52E5     MOVF POSTDEC1, F, ACCESS
0C7E  0012     RETURN 0
504:           					time_M_Motor.time_work_motor = 0;
0394  0100     MOVLB 0x0
0396  6B7D     CLRF 0x7D, BANKED
0398  6B7E     CLRF 0x7E, BANKED
505:           				}
506:           				break;
039A  D038     BRA 0x40C
507:           			case STOPPING_MOTOR:		//останов двигателя
508:           				M_Motor_is_stopped(&motor_pins_brake_high_sw[index]);
039C  DBA1     RCALL __pa_8
039E  EC3C     CALL 0xC78, 0
03A0  F006     NOP
509:           				cnt_step++;
03A2  0100     MOVLB 0x0
03A4  2B69     INCF cnt_step, F, BANKED
510:           				break;
03A6  D032     BRA 0x40C
511:           			case BRAKING_MOTOR:		//торможение двигателя (включение верхних ключей в обоимх полумостах)
512:           				if(M_Motor_is_brake(&motor_pins_brake_high_sw[index], type_of_ls, index))
03A8  0EFE     MOVLW 0xFE
03AA  CFDB     MOVFF PLUSW2, POSTINC1
03AC  FFE6     NOP
03AE  0EFC     MOVLW 0xFC
03B0  CFDB     MOVFF PLUSW2, POSTINC1
03B2  FFE6     NOP
03B4  DB95     RCALL __pa_8
03B6  DA40     RCALL M_Motor_is_brake
03B8  52E5     MOVF POSTDEC1, F, ACCESS
03BA  52E5     MOVF POSTDEC1, F, ACCESS
03BC  52E5     MOVF POSTDEC1, F, ACCESS
03BE  52E5     MOVF POSTDEC1, F, ACCESS
03C0  0900     IORLW 0x0
03C2  E024     BZ 0x40C
513:           				{
514:           					M_Motor_is_stopped(&motor_pins_brake_high_sw[index]);
03C4  DB8D     RCALL __pa_8
03C6  EC3C     CALL 0xC78, 0
03C8  F006     NOP
0AE0  0EFE     MOVLW 0xFE
0AE2  50DB     MOVF PLUSW2, W, ACCESS
0AE4  0D06     MULLW 0x6
0AE6  D8CC     RCALL __pa_43
0AE8  0E58     MOVLW 0x58
0AEA  2632     ADDWF __tmp_0, F, ACCESS
0AEC  0E35     MOVLW 0x35
0AEE  2233     ADDWFC 0x33, F, ACCESS
0AF0  EF30     GOTO 0xC60
0AF2  F006     NOP
0C60  C032     MOVFF __tmp_0, POSTINC1
0C62  FFE6     NOP
0C64  C033     MOVFF 0x33, POSTINC1
0C66  FFE6     NOP
0C68  0012     RETURN 0
515:           					cnt_step = ACCELERATION_MOTOR;  
03CA  0100     MOVLB 0x0
03CC  6B69     CLRF cnt_step, BANKED
516:           					if((limit_switch && type_of_ls != AGITATOR_LS) || (type_of_ls == AGITATOR_LS && !is_motor_failure))
03CE  0EFD     MOVLW 0xFD
03D0  50DB     MOVF PLUSW2, W, ACCESS
03D2  E002     BZ 0x3D8
03D4  DBD5     RCALL __pa_18
03D6  E104     BNZ 0x3E0
03D8  DBD3     RCALL __pa_18
03DA  E104     BNZ 0x3E4
03DC  5193     MOVF 0x93, W, BANKED
03DE  E102     BNZ 0x3E4
517:           						pos_motor =  MOTOR_IN_START_OR_END_POSITION;
03E0  0E01     MOVLW 0x1
03E2  6EDF     MOVWF INDF2, ACCESS
518:           					if((!limit_switch && type_of_ls != AGITATOR_LS) ||  (type_of_ls == AGITATOR_LS && is_motor_failure))
03E4  0EFD     MOVLW 0xFD
03E6  50DB     MOVF PLUSW2, W, ACCESS
03E8  E102     BNZ 0x3EE
03EA  DBCA     RCALL __pa_18
03EC  E104     BNZ 0x3F6
03EE  DBC8     RCALL __pa_18
03F0  E10D     BNZ 0x40C
03F2  5193     MOVF 0x93, W, BANKED
03F4  E00B     BZ 0x40C
519:           					{
520:           						is_motor_failure = FALSE;
03F6  6B93     CLRF 0x93, BANKED
521:           						pos_motor =  MOTOR_IN_FAILURE;
03F8  0E02     MOVLW 0x2
03FA  6EDF     MOVWF INDF2, ACCESS
522:           						M_Motor_failure_motor[index].is_failure = ON; //сформировать код аварии
03FC  DB4F     RCALL __pa_3
03FE  0E01     MOVLW 0x1
0400  6EEF     MOVWF INDF0, ACCESS
523:           						M_Motor_failure_motor[index].type_ls = type_of_ls;
0402  DB4C     RCALL __pa_3
0404  52EE     MOVF POSTINC0, F, ACCESS
0406  0EFC     MOVLW 0xFC
0408  CFDB     MOVFF PLUSW2, INDF0
040A  FFEF     NOP
524:           					}
525:           				}
526:           				break;
527:           		}
528:           	}
529:           	return pos_motor;
040C  50DF     MOVF INDF2, W, ACCESS
530:           }
040E  52E5     MOVF POSTDEC1, F, ACCESS
0410  D35D     BRA __pa_6
531:           
532:           
533:           const rom  IOport_motor* M_Motor_get_ptr_to_motor_pins(void)
534:           {
535:           	return ptr_to_motor_pins;
0412  C091     MOVFF ptr_to_motor_pins, PROD
0414  FFF3     NOP
0416  C092     MOVFF 0x92, PRODH
0418  FFF4     NOP
536:           }
041A  0012     RETURN 0
537:           
538:           
539:           static uint8_t M_Motor_check_motor(uint8_t index, BOOL limit_switch, uint8_t type_of_ls, uint8_t* cnt_fail)
041C  DB52     RCALL __pa_5
540:           {
541:           	if(M_Motor_rotate(index, limit_switch, type_of_ls) != MOTOR_CHECKING)
041E  0EFC     MOVLW 0xFC
0420  CFDB     MOVFF PLUSW2, POSTINC1
0422  FFE6     NOP
0424  DBE5     RCALL __pa_28
0426  DB95     RCALL __pa_14
0428  E02B     BZ 0x480
0BF0  0EFD     MOVLW 0xFD
0BF2  CFDB     MOVFF PLUSW2, POSTINC1
0BF4  FFE6     NOP
0BF6  0EFE     MOVLW 0xFE
0BF8  CFDB     MOVFF PLUSW2, POSTINC1
0BFA  FFE6     NOP
0BFC  0012     RETURN 0
542:           	{ 
543:           		if(M_Motor_failure_motor[index].is_failure)  //если есть признак аварии
042A  DB38     RCALL __pa_3
042C  50EF     MOVF INDF0, W, ACCESS
042E  E024     BZ 0x478
544:           		{
545:           			if((*cnt_fail) == M_Mngm_Get_parameters_buffer()->menu_parameters.Motor[index].quantity_repeat_try)
0430  DB97     RCALL __pa_15
0432  CFEF     MOVFF INDF0, __tmp_0
0434  F032     NOP
0436  C032     MOVFF __tmp_0, POSTINC1
0438  FFE6     NOP
043A  ECFE     CALL 0x15FC, 0
043C  F00A     NOP
043E  DBD3     RCALL __pa_27
0440  CFF3     MOVFF PROD, 0x33
0442  F033     NOP
0444  CFF4     MOVFF PRODH, 0x34
0446  F034     NOP
0448  0EFE     MOVLW 0xFE
044A  50DB     MOVF PLUSW2, W, ACCESS
044C  0D04     MULLW 0x4
044E  5033     MOVF 0x33, W, ACCESS
0450  24F3     ADDWF PROD, W, ACCESS
0452  6EE9     MOVWF FSR0, ACCESS
0454  5034     MOVF 0x34, W, ACCESS
0456  20F4     ADDWFC PRODH, W, ACCESS
0458  6EEA     MOVWF FSR0H, ACCESS
045A  0E03     MOVLW 0x3
045C  EC35     CALL 0xC6A, 0
045E  F006     NOP
0460  5C32     SUBWF __tmp_0, W, ACCESS
0462  E104     BNZ 0x46C
546:           			{		
547:           				*cnt_fail = 0;
0464  DB7D     RCALL __pa_15
0466  6AEF     CLRF INDF0, ACCESS
548:           				return FAILURE;
0468  0E03     MOVLW 0x3
046A  D00B     BRA 0x482
549:           			}
550:           			else
551:           			{
552:           				(*cnt_fail)++;
046C  DB79     RCALL __pa_15
046E  2AEF     INCF INDF0, F, ACCESS
553:           				M_Motor_failure_motor[index].is_failure = 0;		/*вставка на этапе отладки */
0470  DB15     RCALL __pa_3
0472  6AEF     CLRF INDF0, ACCESS
0A9C  0EFE     MOVLW 0xFE
0A9E  6AEA     CLRF FSR0H, ACCESS
0AA0  34DB     RLCF PLUSW2, W, ACCESS
0AA2  0BFE     ANDLW 0xFE
0AA4  36EA     RLCF FSR0H, F, ACCESS
0AA6  6EE9     MOVWF FSR0, ACCESS
0AA8  0E89     MOVLW 0x89
0AAA  26E9     ADDWF FSR0, F, ACCESS
0AAC  0E00     MOVLW 0x0
0AAE  22EA     ADDWFC FSR0H, F, ACCESS
0AB0  0012     RETURN 0
554:           				return NEED_REVERSE;
0474  0E02     MOVLW 0x2
0476  D005     BRA 0x482
555:           			}
556:           		}
557:           		else
558:           		{	
559:           			*cnt_fail = 0;
0478  DB73     RCALL __pa_15
047A  6AEF     CLRF INDF0, ACCESS
0B60  0EFA     MOVLW 0xFA
0B62  CFDB     MOVFF PLUSW2, FSR0
0B64  FFE9     NOP
0B66  0EFB     MOVLW 0xFB
0B68  CFDB     MOVFF PLUSW2, FSR0H
0B6A  FFEA     NOP
0B6C  0012     RETURN 0
560:           			return NEED_NEXT_STEP;
047C  0E01     MOVLW 0x1
047E  D001     BRA 0x482
561:           		}
562:           	}
563:           	else
564:           	{
565:           		return IS_BUSY;
0480  0E00     MOVLW 0x0
566:           	}
567:           }
0482  D324     BRA __pa_6
568:           
569:           /* Реализация автомата состояний модуля двигателей  */
570:           void M_Motor_Run(void)
571:           {
572:           	static uint8_t cnt_failure_forward = 0;
573:           	static uint8_t cnt_failure_backward = 0;
574:           	static BOOL after_pause = OFF;
575:           	static BOOL shatter_reverse = OFF;
576:           	static uint8_t ls_type;
577:           		
578:           	if(M_Ind_Get_state() == STATE_IND_INIT)
0484  ECA5     CALL 0xD4A, 0
0486  F006     NOP
0488  0900     IORLW 0x0
048A  E101     BNZ 0x48E
579:           	{
580:           		return;
048C  0012     RETURN 0
581:           	}
582:           	
583:           	switch(M_Motor_state)
048E  0100     MOVLB 0x0
0490  5164     MOVF M_Motor_state, W, BANKED
0492  0A03     XORLW 0x3
0494  E101     BNZ 0x498
0496  D0B8     BRA 0x608
0498  0A06     XORLW 0x6
049A  E101     BNZ 0x49E
049C  D081     BRA 0x5A0
049E  0A01     XORLW 0x1
04A0  E054     BZ 0x54A
04A2  0A05     XORLW 0x5
04A4  E030     BZ 0x506
04A6  0A03     XORLW 0x3
04A8  E02C     BZ 0x502
04AA  0A02     XORLW 0x2
04AC  E001     BZ 0x4B0
04AE  0012     RETURN 0
584:           	{
585:           		//проверка начального положения двигателей (дозатора и заслонки)
586:           		//Заслонка проверяется только после окончания проверки дозатора
587:           		//Далее переход либо в состояние ожидания, либо в состояние аварии модуля
588:           		case CHECK_START_POSITION: 				
589:           			M_Motor_prev_state = M_Motor_state;
04B0  C064     MOVFF M_Motor_state, M_Motor_prev_state
04B2  F07A     NOP
590:           			switch(num_motor)
04B4  5167     MOVF num_motor, W, BANKED
04B6  0A02     XORLW 0x2
04B8  E012     BZ 0x4DE
04BA  0A02     XORLW 0x2
04BC  E001     BZ 0x4C0
04BE  0012     RETURN 0
591:           			{
592:           				case INDEX_OF_DISPENSER:
593:           					ptr_to_motor_pins = &motor_pins_backward[INDEX_OF_DISPENSER];
04C0  EC5F     CALL 0xCBE, 0
04C2  F006     NOP
0CBE  0E40     MOVLW 0x40
0CC0  6F91     MOVWF ptr_to_motor_pins, BANKED
0CC2  0E35     MOVLW 0x35
0CC4  6F92     MOVWF 0x92, BANKED
594:           					if (M_Motor_rotate(INDEX_OF_DISPENSER, M_LI_Get_Limit_Switches()->ls_dispenser_start_state, 
04C4  50EF     MOVF INDF0, W, ACCESS
04C6  6EE6     MOVWF POSTINC1, ACCESS
04C8  6AE6     CLRF POSTINC1, ACCESS
0CCA  F006     NOP
595:           					START_LS) != MOTOR_CHECKING)
04CA  DB43     RCALL __pa_14
04CC  E019     BZ 0x500
0CC6  0E01     MOVLW 0x1
0CC8  EF2D     GOTO 0xC5A
596:           					{
597:           						if(M_Motor_failure_motor[INDEX_OF_DISPENSER].is_failure)
04CE  0100     MOVLB 0x0
04D0  5189     MOVF M_Motor_failure_motor, W, BANKED
04D2  E10E     BNZ 0x4F0
598:           						{
599:           							cnt_step = 0;
600:           							M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
601:           						}
602:           						else
603:           						{
604:           							cnt_step = 0;
04D4  6B69     CLRF cnt_step, BANKED
605:           							num_motor = INDEX_OF_SHATTER;
04D6  0E02     MOVLW 0x2
04D8  6F67     MOVWF num_motor, BANKED
606:           							ptr_to_motor_pins = &motor_pins_backward[INDEX_OF_SHATTER];
04DA  EF10     GOTO 0xC20
04DC  F006     NOP
607:           						}
608:           					}
609:           				break;	
610:           				case INDEX_OF_SHATTER:		
611:           					if(M_Motor_rotate(INDEX_OF_SHATTER, M_LI_Get_Limit_Switches()->ls_shatter_start_state,
04E2  0E02     MOVLW 0x2
04E4  DB44     RCALL __pa_16
612:           					START_LS) != MOTOR_CHECKING)
04DE  0E01     MOVLW 0x1
04E0  DBBC     RCALL __pa_38
04E6  DB35     RCALL __pa_14
04E8  E00B     BZ 0x500
613:           					{
614:           						if(M_Motor_failure_motor[INDEX_OF_SHATTER].is_failure)
04EA  0100     MOVLB 0x0
04EC  518D     MOVF 0x8D, W, BANKED
04EE  E004     BZ 0x4F8
615:           						{
616:           							cnt_step = 0;
04F0  6B69     CLRF cnt_step, BANKED
617:           							M_Motor_state = STATE_MODULE_MOTOR_FAILURE;		
04F2  0E02     MOVLW 0x2
04F4  6F64     MOVWF M_Motor_state, BANKED
618:           						}
619:           						else 
04F6  0012     RETURN 0
620:           						{
621:           							cnt_step = 0;
04F8  6B69     CLRF cnt_step, BANKED
622:           							M_Motor_state = STATE_MODULE_MOTOR_WAITING;
04FA  0E01     MOVLW 0x1
04FC  6F64     MOVWF M_Motor_state, BANKED
623:           							num_motor = INDEX_OF_AGITATOR;
04FE  6F67     MOVWF num_motor, BANKED
624:           						}
625:           					}
626:           				break;
627:           			}
628:           			break;
0500  0012     RETURN 0
629:           		
630:           		case STATE_MODULE_MOTOR_FAILURE:	//режим "Авария"
631:           			ctrl = OFF;
0502  6B65     CLRF ctrl, BANKED
632:           
633:           			break;
0504  0012     RETURN 0
634:           		case STATE_MODULE_MOTOR_WAITING:	//режим ожидания команды вращения мотора
635:           			//ctrl = TRUE; //!!!!!!для отладки
636:           			M_Motor_prev_state = M_Motor_state;
0506  C064     MOVFF M_Motor_state, M_Motor_prev_state
0508  F07A     NOP
637:           			if(ctrl)
050A  5165     MOVF ctrl, W, BANKED
050C  E009     BZ 0x520
638:           			{
639:           				cnt_step = 0;
050E  6B69     CLRF cnt_step, BANKED
640:           				M_Motor_state = STATE_MODULE_MOTOR_WORKING;
0510  0E03     MOVLW 0x3
0512  6F64     MOVWF M_Motor_state, BANKED
641:           				M_Ind_Set_state(STATE_VIEW_SUPPLY_FUEL);
0514  0E07     MOVLW 0x7
0516  6EE6     MOVWF POSTINC1, ACCESS
0518  ECA1     CALL 0xD42, 0
051A  F006     NOP
051C  52E5     MOVF POSTDEC1, F, ACCESS
642:           				M_Ind_Set_blink_mode(NEED_BLINK);
051E  DB47     RCALL __pa_22
643:           			}
644:           				M_motor_forming_direction_question_LS(QUESTION_LS_FALSE_OFF, QUESTION_LS_FALSE_ON, QUESTION_LS_FALSE_OFF, QUESTION_LS_FALSE_ON, QUESTION_LS_FALSE_ON);
0520  6AE6     CLRF POSTINC1, ACCESS
0522  6AE6     CLRF POSTINC1, ACCESS
0524  0E01     MOVLW 0x1
0526  6EE6     MOVWF POSTINC1, ACCESS
0528  6AE6     CLRF POSTINC1, ACCESS
052A  6EE6     MOVWF POSTINC1, ACCESS
052C  DDF8     RCALL M_motor_forming_direction_question_LS
052E  DBB6     RCALL __pa_46
645:           				//#ifndef NO_CONTROL_FALSE_STATE_LS
646:           					M_Motor_check_false_LS(M_LI_Get_Limit_Switches(), QUANTITY_FALSE_LS);
0530  0E07     MOVLW 0x7
0532  6EE6     MOVWF POSTINC1, ACCESS
0534  EC54     CALL 0x26A8, 0
0536  F013     NOP
0538  DBA3     RCALL __pa_43
053A  CFF3     MOVFF PROD, POSTINC1
053C  FFE6     NOP
053E  CFF4     MOVFF PRODH, POSTINC1
0540  FFE6     NOP
0542  DE0B     RCALL M_Motor_check_false_LS
0544  52E5     MOVF POSTDEC1, F, ACCESS
0546  52E5     MOVF POSTDEC1, F, ACCESS
647:           				//#endif
648:           		break;
0548  D029     BRA 0x59C
649:           		case STATE_MODULE_MOTOR_CLEAN_CHIMNEY:		//режим "Чистка дымохода"
650:           				M_Motor_prev_state = M_Motor_state;
054A  C064     MOVFF M_Motor_state, M_Motor_prev_state
054C  F07A     NOP
651:           				M_Ind_Set_blink_mode(NEED_BLINK);
054E  DB2F     RCALL __pa_22
652:           				if(M_Motor_check_ls_after_begin_start(*temp_start_ls, temp_index))
0550  C118     MOVFF temp_index, POSTINC1
0552  FFE6     NOP
0554  C078     MOVFF temp_start_ls, FSR0
0556  FFE9     NOP
0558  C079     MOVFF 0x79, FSR0H
055A  FFEA     NOP
055C  DACB     RCALL __pa_9
055E  E004     BZ 0x568
653:           				{	
654:           					time_M_Motor.time_ctrl_ls_after_begin = 0;
0560  0100     MOVLB 0x0
0562  6B85     CLRF 0x85, BANKED
0564  6B86     CLRF 0x86, BANKED
655:           					M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
656:           					break;		
0566  D011     BRA 0x58A
657:           				}
658:           				if (M_Motor_rotate(INDEX_OF_SHATTER, *(M_LI_get_ptr_to_ls()), 
056C  EC47     CALL 0x268E, 0
056E  F013     NOP
0570  DB9A     RCALL __pa_47
0572  50EF     MOVF INDF0, W, ACCESS
0574  6EE6     MOVWF POSTINC1, ACCESS
0576  0E02     MOVLW 0x2
0578  6EE6     MOVWF POSTINC1, ACCESS
659:           				ls_type) != MOTOR_CHECKING)
0568  C119     MOVFF 0x119, POSTINC1
056A  FFE6     NOP
057A  DAEB     RCALL __pa_14
057C  E101     BNZ 0x580
057E  D149     BRA 0x812
0B52  EC14     CALL 0x228, 0
0B54  F001     NOP
0B56  52E5     MOVF POSTDEC1, F, ACCESS
0B58  52E5     MOVF POSTDEC1, F, ACCESS
0B5A  52E5     MOVF POSTDEC1, F, ACCESS
0B5C  0900     IORLW 0x0
0B5E  0012     RETURN 0
660:           				{
661:           					time_M_Motor.time_ctrl_ls_after_begin = 0;
0580  0100     MOVLB 0x0
0582  6B85     CLRF 0x85, BANKED
0584  6B86     CLRF 0x86, BANKED
662:           					if(M_Motor_failure_motor[INDEX_OF_SHATTER].is_failure)
0586  518D     MOVF 0x8D, W, BANKED
0588  E002     BZ 0x58E
663:           					{
664:           						M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
058A  0E02     MOVLW 0x2
665:           					}
666:           					else
058C  D038     BRA 0x5FE
667:           					{
668:           						M_Motor_state = STATE_MODULE_MOTOR_WAITING_FOR_MOVE_CLEAN_CHIMNEY;
058E  0E05     MOVLW 0x5
0590  6F64     MOVWF M_Motor_state, BANKED
669:           						ctrl_shatter = WAITING_MOVEMENT;
0592  0E03     MOVLW 0x3
0594  6F68     MOVWF ctrl_shatter, BANKED
670:           						M_Ind_Set_blink_mode(NO_NEED_BLINK);
0596  6AE6     CLRF POSTINC1, ACCESS
0598  EC96     CALL 0xD2C, 0
059A  F006     NOP
059C  52E5     MOVF POSTDEC1, F, ACCESS
671:           					}
672:           				}
673:           		break;
059E  0012     RETURN 0
674:           		case STATE_MODULE_MOTOR_WAITING_FOR_MOVE_CLEAN_CHIMNEY:		//установка параметров перед вращением двигателя заслонки в режиме "Чистка дымохода"
675:           			M_Motor_prev_state = M_Motor_state;
05A0  C064     MOVFF M_Motor_state, M_Motor_prev_state
05A2  F07A     NOP
676:           			if(ctrl_shatter == MOVEMENT_FORWARD) 		//подготовка к вращению мотора заслонки для её открытия
05A4  0568     DECF ctrl_shatter, W, BANKED
05A6  E112     BNZ 0x5CC
677:           			{
678:           				M_LI_set_ptr_to_ls(&(M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state));	
05A8  DA65     RCALL __pa_0
05AA  0E04     MOVLW 0x4
05AC  DAAF     RCALL __pa_11
0B0C  D8EA     RCALL __pa_53
0B0E  CFE9     MOVFF FSR0, __tmp_0
0B10  F032     NOP
0B12  CFEA     MOVFF FSR0H, 0x33
0B14  F033     NOP
0B16  CFE9     MOVFF FSR0, POSTINC1
0B18  FFE6     NOP
0B1A  CFEA     MOVFF FSR0H, POSTINC1
0B1C  FFE6     NOP
0B1E  EC4C     CALL 0x2698, 0
0B20  F013     NOP
0B22  52E5     MOVF POSTDEC1, F, ACCESS
0B24  52E5     MOVF POSTDEC1, F, ACCESS
679:           				M_Motor_state = STATE_MODULE_MOTOR_CLEAN_CHIMNEY;
0B26  0100     MOVLB 0x0
0B28  0E04     MOVLW 0x4
0B2A  6F64     MOVWF M_Motor_state, BANKED
0B2C  0012     RETURN 0
680:           				ptr_to_motor_pins = &motor_pins_forward[INDEX_OF_SHATTER];
05AE  0E34     MOVLW 0x34
05B0  6F91     MOVWF ptr_to_motor_pins, BANKED
05B2  0E35     MOVLW 0x35
05B4  6F92     MOVWF 0x92, BANKED
681:           				ls_type = AFTER_FINISH_LS;
05B6  0101     MOVLB 0x1
05B8  0E03     MOVLW 0x3
05BA  6F19     MOVWF 0x19, BANKED
682:           				M_Ind_Set_blink_mode(NEED_BLINK);
05BC  DAF8     RCALL __pa_22
0BAE  0E01     MOVLW 0x1
0BB0  6EE6     MOVWF POSTINC1, ACCESS
0BB2  EC96     CALL 0xD2C, 0
0BB4  F006     NOP
0BB6  52E5     MOVF POSTDEC1, F, ACCESS
0BB8  0012     RETURN 0
683:           				cnt_step = 0;
05BE  0100     MOVLB 0x0
05C0  6B69     CLRF cnt_step, BANKED
684:           				temp_start_ls = &(M_LI_Get_Limit_Switches()->ls_shatter_start_state); 
05C2  DA58     RCALL __pa_0
05C4  0E02     MOVLW 0x2
05C6  DAE9     RCALL __pa_20
0B9A  D8A3     RCALL __pa_53
0B9C  CFE9     MOVFF FSR0, temp_start_ls
0B9E  F078     NOP
0BA0  CFEA     MOVFF FSR0H, 0x79
0BA2  F079     NOP
685:           				temp_index =  INDEX_FALSE_STATE_LS_START_SHATTER;
05C8  0E02     MOVLW 0x2
0BA4  0101     MOVLB 0x1
0BA6  0012     RETURN 0
686:           			}
687:           			else if(ctrl_shatter == MOVEMENT_BACKWARD)		//подготовка к вращению мотора заслонки для её закрытия	
05CA  D014     BRA 0x5F4
05CC  0E02     MOVLW 0x2
05CE  5D68     SUBWF ctrl_shatter, W, BANKED
05D0  E113     BNZ 0x5F8
688:           			{
689:           				M_LI_set_ptr_to_ls(&(M_LI_Get_Limit_Switches()->ls_shatter_start_state));
05D2  DA50     RCALL __pa_0
05D4  0E02     MOVLW 0x2
05D6  DA9A     RCALL __pa_11
690:           				M_Motor_state = STATE_MODULE_MOTOR_CLEAN_CHIMNEY;
691:           				ptr_to_motor_pins = &motor_pins_backward[INDEX_OF_SHATTER];
05D8  DB23     RCALL __pa_32
692:           				ls_type = START_LS;
05DA  0101     MOVLB 0x1
05DC  0E01     MOVLW 0x1
05DE  6F19     MOVWF 0x19, BANKED
693:           				M_Ind_Set_blink_mode(NEED_BLINK);
05E0  6EE6     MOVWF POSTINC1, ACCESS
05E2  EC96     CALL 0xD2C, 0
05E4  F006     NOP
05E6  52E5     MOVF POSTDEC1, F, ACCESS
694:           				cnt_step = 0;
05E8  0100     MOVLB 0x0
05EA  6B69     CLRF cnt_step, BANKED
695:           				temp_start_ls = &(M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state);
05EC  DA43     RCALL __pa_0
05EE  0E04     MOVLW 0x4
05F0  DAD4     RCALL __pa_20
696:           				temp_index = INDEX_FALSE_STATE_LS_AFTER_FINISH_SHATTER;
05F2  0E04     MOVLW 0x4
05F4  6F18     MOVWF 0x18, BANKED
697:           			}
698:           			else if(ctrl_shatter == NO_MOVEMENT)
05F6  0012     RETURN 0
05F8  5168     MOVF ctrl_shatter, W, BANKED
05FA  E103     BNZ 0x602
699:           			{
700:           				M_Motor_state = STATE_MODULE_MOTOR_WAITING;
05FC  0E01     MOVLW 0x1
05FE  6F64     MOVWF M_Motor_state, BANKED
701:           			}
702:           			else if(ctrl_shatter == WAITING_MOVEMENT)
0600  0012     RETURN 0
0602  0E03     MOVLW 0x3
0604  5D68     SUBWF ctrl_shatter, W, BANKED
703:           			{
704:           			
705:           			}
706:           		break;
0606  0012     RETURN 0
707:           		
708:           		case STATE_MODULE_MOTOR_WORKING:	//алгоритм засыпки топлива из бункера в котёл
709:           			M_Motor_prev_state = M_Motor_state;
0608  C064     MOVFF M_Motor_state, M_Motor_prev_state
060A  F07A     NOP
710:           			switch(num_motor)
060C  5167     MOVF num_motor, W, BANKED
060E  0A02     XORLW 0x2
0610  E101     BNZ 0x614
0612  D090     BRA 0x734
0614  0A02     XORLW 0x2
0616  E023     BZ 0x65E
0618  0A01     XORLW 0x1
061A  E001     BZ 0x61E
061C  0012     RETURN 0
711:           			{
712:           				case INDEX_OF_AGITATOR:		//вращение ворошителя
713:           						//LED_FAN_PIN = ON;
714:           						ptr_to_motor_pins = &motor_pins_forward[INDEX_OF_AGITATOR];
061E  0E2E     MOVLW 0x2E
0620  6F91     MOVWF ptr_to_motor_pins, BANKED
0622  0E35     MOVLW 0x35
0624  6F92     MOVWF 0x92, BANKED
715:           						switch(M_Motor_check_motor(INDEX_OF_AGITATOR, M_LI_Get_Limit_Switches()->ls_agitator_state, AGITATOR_LS,
0628  0E04     MOVLW 0x4
062A  DB17     RCALL __pa_38
062C  0E05     MOVLW 0x5
062E  DB1D     RCALL __pa_40
0630  6EE6     MOVWF POSTINC1, ACCESS
0632  0E01     MOVLW 0x1
0634  6EE6     MOVWF POSTINC1, ACCESS
0638  E101     BNZ 0x63C
063A  D0EB     BRA 0x812
063C  0A01     XORLW 0x1
063E  E008     BZ 0x650
0640  0A02     XORLW 0x2
0642  E001     BZ 0x646
0644  0012     RETURN 0
716:           						&cnt_failure_forward))
0626  DB01     RCALL __pa_33
0636  DA66     RCALL __pa_10
717:           						{
718:           							case FAILURE:
719:           								M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
0646  0100     MOVLB 0x0
0648  0E02     MOVLW 0x2
064A  6F64     MOVWF M_Motor_state, BANKED
720:           								cnt_step = 0;
064C  6B69     CLRF cnt_step, BANKED
721:           							break;
064E  0012     RETURN 0
722:           							case NEED_NEXT_STEP:
723:           								cnt_step = 0;
0650  0100     MOVLB 0x0
0652  6B69     CLRF cnt_step, BANKED
724:           								num_motor = INDEX_OF_SHATTER; 
0654  0E02     MOVLW 0x2
0656  6F67     MOVWF num_motor, BANKED
725:           								direction = TO_FORWARD_SHATTER;
0658  0E04     MOVLW 0x4
065A  6F66     MOVWF direction, BANKED
726:           								//LED_FAN_PIN = OFF;
727:           								break;
065C  0012     RETURN 0
728:           							case IS_BUSY:
729:           							
730:           							break;
731:           						}
732:           					break;
733:           				case INDEX_OF_DISPENSER:	//вращение дозатора
734:           					switch(direction)		
065E  5166     MOVF direction, W, BANKED
0660  0A03     XORLW 0x3
0662  E053     BZ 0x70A
0664  0A01     XORLW 0x1
0666  E02A     BZ 0x6BC
0668  0A03     XORLW 0x3
066A  E001     BZ 0x66E
066C  0012     RETURN 0
735:           					{
736:           						case TO_FORWARD_DISPENSER:	//направление вращения "вперёд"
737:           							ptr_to_motor_pins = &motor_pins_forward[INDEX_OF_DISPENSER];
066E  0E28     MOVLW 0x28
0670  6F91     MOVWF ptr_to_motor_pins, BANKED
0672  0E35     MOVLW 0x35
0674  6F92     MOVWF 0x92, BANKED
738:           							if(M_Motor_check_ls_after_begin_start(M_LI_Get_Limit_Switches()->ls_dispenser_start_state, INDEX_FALSE_STATE_LS_START_DISPENSER))
0676  6AE6     CLRF POSTINC1, ACCESS
0678  D9FD     RCALL __pa_0
067A  DA3C     RCALL __pa_9
067C  E001     BZ 0x680
739:           							{	
740:           								M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
067E  D29D     BRA __pa_23
741:           								break;
742:           							}
743:           							switch(M_Motor_check_motor(INDEX_OF_DISPENSER, M_LI_Get_Limit_Switches()->ls_dispenser_finish_state, FINISH_LS,
0682  0E02     MOVLW 0x2
0684  DAEA     RCALL __pa_38
0686  52EE     MOVF POSTINC0, F, ACCESS
0688  50EF     MOVF INDF0, W, ACCESS
068A  6EE6     MOVWF POSTINC1, ACCESS
068C  6AE6     CLRF POSTINC1, ACCESS
0690  E101     BNZ 0x694
0692  D0BF     BRA 0x812
0694  0A02     XORLW 0x2
0696  E00B     BZ 0x6AE
0698  0A03     XORLW 0x3
069A  E005     BZ 0x6A6
069C  0A02     XORLW 0x2
069E  E001     BZ 0x6A2
06A0  0012     RETURN 0
744:           							&cnt_failure_forward))
0680  DAD4     RCALL __pa_33
068E  DA3A     RCALL __pa_10
745:           							{
746:           								case FAILURE:
747:           									cnt_step = 0;
06A2  DA8F     RCALL __pa_24
748:           									M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
749:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
750:           								break;
06A4  D008     BRA 0x6B6
751:           								case NEED_NEXT_STEP:
752:           									cnt_step = 0;
06A6  0100     MOVLB 0x0
06A8  6B69     CLRF cnt_step, BANKED
753:           									direction = TIME_PAUSE_DISPENSER;
06AA  0E03     MOVLW 0x3
754:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
755:           								break;
06AC  D003     BRA 0x6B4
756:           								case NEED_REVERSE:
757:           									cnt_step = 0;
06AE  0100     MOVLB 0x0
06B0  6B69     CLRF cnt_step, BANKED
758:           									direction = TO_BACKWARD_DISPENSER;							
06B2  0E02     MOVLW 0x2
06B4  6F66     MOVWF direction, BANKED
759:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
06B6  6B85     CLRF 0x85, BANKED
06B8  6B86     CLRF 0x86, BANKED
760:           								break;
06BA  0012     RETURN 0
761:           								case IS_BUSY:
762:           								break;	
763:           							}
764:           							break;
765:           						case TO_BACKWARD_DISPENSER:		//направление вращения "назад"
766:           							ptr_to_motor_pins = &motor_pins_backward[INDEX_OF_DISPENSER];
06BC  DB00     RCALL __pa_50
767:           							if(M_Motor_check_ls_after_begin_start(M_LI_Get_Limit_Switches()->ls_dispenser_finish_state, INDEX_FALSE_STATE_LS_FINISH_DISPENSER))
06BE  52EE     MOVF POSTINC0, F, ACCESS
06C0  DA19     RCALL __pa_9
06C2  E001     BZ 0x6C6
768:           							{	
769:           								M_Motor_state = STATE_MODULE_MOTOR_FAILURE;	
06C4  D27A     BRA __pa_23
770:           								break;
771:           							}
772:           							switch(M_Motor_check_motor(INDEX_OF_DISPENSER, M_LI_Get_Limit_Switches()->ls_dispenser_start_state, 
06C8  50EF     MOVF INDF0, W, ACCESS
06CA  6EE6     MOVWF POSTINC1, ACCESS
06CC  6AE6     CLRF POSTINC1, ACCESS
06D0  E101     BNZ 0x6D4
06D2  D09F     BRA 0x812
06D4  0A02     XORLW 0x2
06D6  E012     BZ 0x6FC
06D8  0A03     XORLW 0x3
06DA  E005     BZ 0x6E6
06DC  0A02     XORLW 0x2
06DE  E001     BZ 0x6E2
06E0  0012     RETURN 0
0C5C  EF3A     GOTO 0xA74
0C5E  F005     NOP
0CD8  F006     NOP
773:           							START_LS, &cnt_failure_backward))
06C6  DB02     RCALL __pa_51
06CE  DA1A     RCALL __pa_10
0C5A  6EE6     MOVWF POSTINC1, ACCESS
0CCC  0E95     MOVLW 0x95
0CCE  6EE6     MOVWF POSTINC1, ACCESS
0CD0  0E00     MOVLW 0x0
0CD2  6EE6     MOVWF POSTINC1, ACCESS
0CD4  0E01     MOVLW 0x1
0CD6  EF2D     GOTO 0xC5A
774:           							{
775:           								case FAILURE:
776:           									cnt_step = 0;
06E2  DA6F     RCALL __pa_24
777:           									M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
778:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
779:           								break;
06E4  D00F     BRA 0x704
780:           								case NEED_NEXT_STEP:
781:           									direction = TO_FORWARD_DISPENSER;
06E6  0100     MOVLB 0x0
06E8  0E01     MOVLW 0x1
06EA  6F66     MOVWF direction, BANKED
782:           									cnt_step = 0;
06EC  6B69     CLRF cnt_step, BANKED
783:           									if(after_pause)
06EE  5196     MOVF 0x96, W, BANKED
06F0  E009     BZ 0x704
784:           									{
785:           										num_motor = INDEX_OF_SHATTER;
06F2  0E02     MOVLW 0x2
06F4  6F67     MOVWF num_motor, BANKED
786:           										after_pause = OFF;
06F6  6B96     CLRF 0x96, BANKED
787:           										direction = TO_BACKWARD_SHATTER;
06F8  0E05     MOVLW 0x5
788:           									}
789:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
790:           								break;
06FA  D003     BRA 0x702
791:           								case NEED_REVERSE:
792:           									cnt_step = 0;
06FC  0100     MOVLB 0x0
06FE  6B69     CLRF cnt_step, BANKED
793:           									direction = TO_FORWARD_DISPENSER;							
0700  0E01     MOVLW 0x1
0702  6F66     MOVWF direction, BANKED
794:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0704  6B85     CLRF 0x85, BANKED
0706  6B86     CLRF 0x86, BANKED
795:           									break;
0708  0012     RETURN 0
796:           								case IS_BUSY:
797:           								break;	
798:           							}
799:           							break;
800:           						
801:           						case TIME_PAUSE_DISPENSER:		//пауза после вращения вперёд с отключенным двигателем на время TIME_PAUSE_DISPENSER_CONST
802:           							if(time_M_Motor.time_pause++ == TIME_PAUSE_DISPENSER_CONST)
070A  C083     MOVFF 0x83, __tmp_0
070C  F032     NOP
070E  C084     MOVFF 0x84, 0x33
0710  F033     NOP
0712  2B83     INCF 0x83, F, BANKED
0714  0E00     MOVLW 0x0
0716  2384     ADDWFC 0x84, F, BANKED
0718  0ED0     MOVLW 0xD0
071A  1832     XORWF __tmp_0, W, ACCESS
071C  E001     BZ 0x720
071E  D079     BRA 0x812
0720  0E07     MOVLW 0x7
0722  1833     XORWF 0x33, W, ACCESS
0724  E176     BNZ 0x812
803:           							{
804:           								time_M_Motor.time_pause = 0;
0726  6B83     CLRF 0x83, BANKED
0728  6B84     CLRF 0x84, BANKED
805:           								direction = TO_BACKWARD_DISPENSER;	
072A  0E02     MOVLW 0x2
072C  6F66     MOVWF direction, BANKED
806:           								after_pause = ON;
072E  0E01     MOVLW 0x1
0730  6F96     MOVWF 0x96, BANKED
807:           							}	
808:           							break;
809:           						
810:           					}
811:           					break;
0732  0012     RETURN 0
812:           				case INDEX_OF_SHATTER:	//вращение двигателя заслонки
813:           					switch(direction)		
0734  5166     MOVF direction, W, BANKED
0736  0A05     XORLW 0x5
0738  E032     BZ 0x79E
073A  0A01     XORLW 0x1
073C  E001     BZ 0x740
073E  0012     RETURN 0
814:           					{
815:           						case TO_FORWARD_SHATTER:		//направление вращения "вперёд"
816:           							ptr_to_motor_pins = &motor_pins_forward[INDEX_OF_SHATTER];
0740  0E34     MOVLW 0x34
0742  6F91     MOVWF ptr_to_motor_pins, BANKED
0744  0E35     MOVLW 0x35
0746  6F92     MOVWF 0x92, BANKED
817:           							if(M_Motor_check_ls_after_begin_start(M_LI_Get_Limit_Switches()->ls_shatter_start_state, INDEX_FALSE_STATE_LS_START_SHATTER))
0748  0E02     MOVLW 0x2
074A  DA87     RCALL __pa_38
074C  0E02     MOVLW 0x2
074E  DAC9     RCALL __pa_53
0750  D9D1     RCALL __pa_9
0752  E001     BZ 0x756
818:           							{	
819:           								M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
0754  D232     BRA __pa_23
820:           								break;
821:           							}
822:           							switch(M_Motor_check_motor(INDEX_OF_SHATTER, M_LI_Get_Limit_Switches()->ls_shatter_finish_state, FINISH_LS,
0758  0E02     MOVLW 0x2
075A  DA7F     RCALL __pa_38
075C  0E03     MOVLW 0x3
075E  DA07     RCALL __pa_16
0762  E057     BZ 0x812
0764  0A02     XORLW 0x2
0766  E014     BZ 0x790
0768  0A03     XORLW 0x3
076A  E005     BZ 0x776
076C  0A02     XORLW 0x2
076E  E001     BZ 0x772
0770  0012     RETURN 0
823:           							&cnt_failure_forward))
0756  DA69     RCALL __pa_33
0760  D9D1     RCALL __pa_10
0C2A  0E94     MOVLW 0x94
0C2C  6EE6     MOVWF POSTINC1, ACCESS
0C2E  0E00     MOVLW 0x0
0C30  6EE6     MOVWF POSTINC1, ACCESS
0C32  0012     RETURN 0
824:           							{
825:           								case FAILURE:
826:           									cnt_step = 0;
0772  DA27     RCALL __pa_24
827:           									M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
828:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
829:           									break;
0774  D011     BRA 0x798
830:           								case NEED_NEXT_STEP:
831:           									cnt_step = 0;
0776  0100     MOVLB 0x0
0778  6B69     CLRF cnt_step, BANKED
832:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
077A  6B85     CLRF 0x85, BANKED
077C  6B86     CLRF 0x86, BANKED
833:           									if(!shatter_reverse) 
077E  5197     MOVF 0x97, W, BANKED
0780  E103     BNZ 0x788
834:           									{
835:           									
836:           										num_motor = INDEX_OF_DISPENSER; 
0782  6B67     CLRF num_motor, BANKED
837:           										direction = TO_FORWARD_DISPENSER;
0784  0E01     MOVLW 0x1
838:           									}
839:           									else  //если застряли на преграде при движении заслонки назад, откатываем её вперёд и повторяем движение назад
0786  D002     BRA 0x78C
840:           									{
841:           										shatter_reverse = OFF;
0788  6B97     CLRF 0x97, BANKED
842:           										direction = TO_BACKWARD_SHATTER;	
078A  0E05     MOVLW 0x5
078C  6F66     MOVWF direction, BANKED
843:           									}
844:           									break;
078E  0012     RETURN 0
845:           								case NEED_REVERSE:
846:           									cnt_step = 0;
0790  0100     MOVLB 0x0
0792  6B69     CLRF cnt_step, BANKED
847:           									direction = TO_BACKWARD_SHATTER;							
0794  0E05     MOVLW 0x5
0796  6F66     MOVWF direction, BANKED
848:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0798  6B85     CLRF 0x85, BANKED
079A  6B86     CLRF 0x86, BANKED
849:           									break;
079C  0012     RETURN 0
850:           								case IS_BUSY:
851:           									break;	
852:           							}
853:           							break;
854:           						case TO_BACKWARD_SHATTER:		//направление вращения "назад"
855:           							ptr_to_motor_pins = &motor_pins_backward[INDEX_OF_SHATTER];
079E  DA40     RCALL __pa_32
0C20  0E4C     MOVLW 0x4C
0C22  6F91     MOVWF ptr_to_motor_pins, BANKED
0C24  0E35     MOVLW 0x35
0C26  6F92     MOVWF 0x92, BANKED
0C28  0012     RETURN 0
856:           							if(M_Motor_check_ls_after_begin_start(M_LI_Get_Limit_Switches()->ls_shatter_finish_state, INDEX_FALSE_STATE_LS_FINISH_SHATTER))
07A0  0E03     MOVLW 0x3
07A2  DA5B     RCALL __pa_38
07A4  0E03     MOVLW 0x3
07A6  DA9D     RCALL __pa_53
07A8  D9A5     RCALL __pa_9
07AA  E001     BZ 0x7AE
0AF4  50EF     MOVF INDF0, W, ACCESS
0AF6  6EE6     MOVWF POSTINC1, ACCESS
0AF8  EC65     CALL 0xCA, 0
0AFA  F000     NOP
0AFC  52E5     MOVF POSTDEC1, F, ACCESS
0AFE  52E5     MOVF POSTDEC1, F, ACCESS
0B00  0900     IORLW 0x0
0B02  0012     RETURN 0
0CE2  26E9     ADDWF FSR0, F, ACCESS
0CE4  0E00     MOVLW 0x0
0CE6  22EA     ADDWFC FSR0H, F, ACCESS
0CE8  0012     RETURN 0
857:           							{	
858:           								M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
07AC  D206     BRA __pa_23
0BBA  0100     MOVLB 0x0
0BBC  0E02     MOVLW 0x2
0BBE  6F64     MOVWF M_Motor_state, BANKED
859:           								break;
0BC0  0012     RETURN 0
860:           							}
861:           							switch(M_Motor_check_motor(INDEX_OF_SHATTER, M_LI_Get_Limit_Switches()->ls_shatter_start_state, START_LS,
07B0  0E02     MOVLW 0x2
07B2  D9DD     RCALL __pa_16
07B6  E02D     BZ 0x812
07B8  0A02     XORLW 0x2
07BA  E023     BZ 0x802
07BC  0A03     XORLW 0x3
07BE  E005     BZ 0x7CA
07C0  0A02     XORLW 0x2
07C2  E001     BZ 0x7C6
07C4  0012     RETURN 0
0B08  0A00     XORLW 0x0
0B0A  0012     RETURN 0
0B6E  D87D     RCALL __pa_40
0B70  6EE6     MOVWF POSTINC1, ACCESS
0B72  0E02     MOVLW 0x2
0B74  6EE6     MOVWF POSTINC1, ACCESS
0B76  0012     RETURN 0
862:           							&cnt_failure_backward))
07AE  DA8E     RCALL __pa_51
07B4  D9A7     RCALL __pa_10
0B04  DC8B     RCALL M_Motor_check_motor
0B06  D8CA     RCALL __pa_46
0C9C  6E32     MOVWF __tmp_0, ACCESS
0C9E  0E05     MOVLW 0x5
0CA0  5EE1     SUBWF FSR1, F, ACCESS
0CA2  5032     MOVF __tmp_0, W, ACCESS
0CA4  0012     RETURN 0
863:           							{
864:           								case FAILURE:
865:           									cnt_step = 0;
07C6  D9FD     RCALL __pa_24
0BC2  0100     MOVLB 0x0
0BC4  6B69     CLRF cnt_step, BANKED
866:           									M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
0BC6  0E02     MOVLW 0x2
0BC8  6F64     MOVWF M_Motor_state, BANKED
0BCA  0012     RETURN 0
867:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
868:           									break;
07C8  D019     BRA 0x7FC
869:           								case NEED_NEXT_STEP:
870:           									cnt_step = 0;
07CA  0100     MOVLB 0x0
07CC  6B69     CLRF cnt_step, BANKED
871:           									direction = TO_FORWARD_SHATTER;
07CE  0E04     MOVLW 0x4
07D0  6F66     MOVWF direction, BANKED
872:           									num_motor = INDEX_OF_AGITATOR;
07D2  0E01     MOVLW 0x1
07D4  6F67     MOVWF num_motor, BANKED
873:           									ctrl = OFF;
07D6  6B65     CLRF ctrl, BANKED
874:           									after_pause = OFF;
07D8  6B96     CLRF 0x96, BANKED
875:           									M_Ind_Set_blink_mode(NO_NEED_BLINK);
07DA  6AE6     CLRF POSTINC1, ACCESS
07DC  EC96     CALL 0xD2C, 0
07DE  F006     NOP
07E0  52E5     MOVF POSTDEC1, F, ACCESS
876:           									M_Motor_state = STATE_MODULE_MOTOR_WAITING;
07E2  0100     MOVLB 0x0
07E4  0E01     MOVLW 0x1
07E6  6F64     MOVWF M_Motor_state, BANKED
877:           									if(M_Mngm_Get_state() == STATE_BURNING) 
07E8  EC0C     CALL 0x1618, 0
07EA  F00B     NOP
07EC  0802     SUBLW 0x2
07EE  E105     BNZ 0x7FA
878:           										M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
07F0  0E03     MOVLW 0x3
07F2  6EE6     MOVWF POSTINC1, ACCESS
07F4  ECA1     CALL 0xD42, 0
07F6  F006     NOP
07F8  52E5     MOVF POSTDEC1, F, ACCESS
879:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
07FA  0100     MOVLB 0x0
07FC  6B85     CLRF 0x85, BANKED
07FE  6B86     CLRF 0x86, BANKED
880:           									break;
0800  0012     RETURN 0
881:           								case NEED_REVERSE:
882:           									cnt_step = 0;
0802  0100     MOVLB 0x0
0804  6B69     CLRF cnt_step, BANKED
883:           									direction = TO_FORWARD_SHATTER;							
0806  0E04     MOVLW 0x4
0808  6F66     MOVWF direction, BANKED
884:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
080A  6B85     CLRF 0x85, BANKED
080C  6B86     CLRF 0x86, BANKED
885:           									shatter_reverse = ON;
080E  0E01     MOVLW 0x1
0810  6F97     MOVWF 0x97, BANKED
886:           									break;
887:           								case IS_BUSY:
888:           									break;	
889:           							}
890:           							break;
891:           				}
892:           				break;
893:           			}	
894:           			break;
895:           	}
896:           }
0812  0012     RETURN 0
897:           
898:           
899:           static void M_Motor_clear_accel_state(void)
900:           {
901:           	accel_state = 0;
0814  0100     MOVLB 0x0
0816  6B61     CLRF accel_state, BANKED
902:           	M_Motor_PWM_period = 0;
0818  6B63     CLRF M_Motor_PWM_period, BANKED
903:           	M_Motor_Timer2_change(TIMER2_OFF_VALUE, DISABLE_TMR2_INTR);
081A  EFFF     GOTO 0xBFE
081C  F005     NOP
0BFE  6AE6     CLRF POSTINC1, ACCESS
0C00  6AE6     CLRF POSTINC1, ACCESS
0C02  DE79     RCALL M_Motor_Timer2_change
0C04  52E5     MOVF POSTDEC1, F, ACCESS
0C06  52E5     MOVF POSTDEC1, F, ACCESS
0C08  0012     RETURN 0
904:           }
905:           
906:           
907:           /*Реализация включенного двигателя (номинальное напряжение) 
908:           Включается верхний ключ и нижний ключ в диагонали моста
909:            */
910:           static void M_Motor_is_worked(const rom IOport_motor* motor_pins)
081E  D951     RCALL __pa_5
911:           {
912:           	*motor_pins->portReg_prim_half_bridge |= 1 << (motor_pins->pin_num_prim_half_bridge);	
0820  DA0E     RCALL __pa_35
0822  E002     BZ 0x828
0824  D9A9     RCALL __pa_17
0826  E1FE     BNZ 0x824
0828  DA34     RCALL __pa_45
0C92  6E32     MOVWF __tmp_0, ACCESS
0C94  DEF3     RCALL __pa_1
0C96  DF0D     RCALL __pa_4
0C98  12EF     IORWF INDF0, F, ACCESS
0C9A  0012     RETURN 0
913:           	*motor_pins->portReg_sec_half_bridge |= 1 << (motor_pins->pin_num_sec_half_bridge);
082A  DA45     RCALL __pa_49
082C  E002     BZ 0x832
082E  D9A4     RCALL __pa_17
0830  E1FE     BNZ 0x82E
0832  DA0E     RCALL __pa_37
0834  12EF     IORWF INDF0, F, ACCESS
914:           }
0836  D14A     BRA __pa_6
915:           
916:           
917:           /* 
918:           Торможение двигателя
919:           Включается 2 верхних ключа в плечах моста
920:           Возвращает:
921:           0 -  если не прошло время торможения двигателя
922:           1 -  если прошло время торможения двигателя
923:           */
924:           static BOOL M_Motor_is_brake(const rom IOport_motor* motor_pins, uint8_t which_ls, uint8_t num)
0838  D944     RCALL __pa_5
925:           {
926:           	static uint8_t step_brake = ROTATE_REVERSE;
927:           	
928:           	switch(step_brake)
083A  0100     MOVLB 0x0
083C  5198     MOVF 0x98, W, BANKED
083E  0A01     XORLW 0x1
0840  E037     BZ 0x8B0
0842  0A01     XORLW 0x1
0844  E149     BNZ 0x8D8
929:           	{
930:           		case ROTATE_REVERSE:
931:           			if (which_ls == AGITATOR_LS)
0846  D99C     RCALL __pa_18
0848  E103     BNZ 0x850
0B80  0EFC     MOVLW 0xFC
0B82  50DB     MOVF PLUSW2, W, ACCESS
0B84  0804     SUBLW 0x4
0B86  0012     RETURN 0
932:           			{
933:           				step_brake = BRAKE_HIGH_SW;	
084A  0E01     MOVLW 0x1
084C  6F98     MOVWF 0x98, BANKED
934:           				break;
084E  D044     BRA 0x8D8
935:           			}
936:           			M_Motor_is_worked(which_ls ==  START_LS ? &motor_pins_forward[num]  :  &motor_pins_backward[num]);
0850  0EFC     MOVLW 0xFC
0852  04DB     DECF PLUSW2, W, ACCESS
0854  E105     BNZ 0x860
0856  D96B     RCALL __pa_12
0858  0E28     MOVLW 0x28
085A  2632     ADDWF __tmp_0, F, ACCESS
085C  0E35     MOVLW 0x35
085E  D004     BRA 0x868
0860  D966     RCALL __pa_12
0862  0E40     MOVLW 0x40
0864  2632     ADDWF __tmp_0, F, ACCESS
0866  0E35     MOVLW 0x35
0868  2233     ADDWFC 0x33, F, ACCESS
086A  D9FA     RCALL __pa_39
086C  D9D5     RCALL __pa_31
937:           			if(time_M_Motor. time_rotate_motor_in_reverse++ ==  TIME_ROTATE_MOTOR_IN_REVERSE)
086E  0100     MOVLB 0x0
0870  C081     MOVFF 0x81, __tmp_0
0872  F032     NOP
0874  C082     MOVFF 0x82, 0x33
0876  F033     NOP
0878  2B81     INCF 0x81, F, BANKED
087A  0E00     MOVLW 0x0
087C  2382     ADDWFC 0x82, F, BANKED
087E  0E2D     MOVLW 0x2D
0880  1832     XORWF __tmp_0, W, ACCESS
0882  E12A     BNZ 0x8D8
0884  5033     MOVF 0x33, W, ACCESS
0886  E128     BNZ 0x8D8
938:           			{
939:           				time_M_Motor. time_rotate_motor_in_reverse = 0;
0888  6B81     CLRF 0x81, BANKED
088A  6B82     CLRF 0x82, BANKED
940:           				step_brake = BRAKE_HIGH_SW;
088C  0E01     MOVLW 0x1
088E  6F98     MOVWF 0x98, BANKED
941:           				M_Motor_is_stopped(which_ls ==  START_LS ? &motor_pins_forward[num]  :  &motor_pins_backward[num]);
0890  0EFC     MOVLW 0xFC
0892  04DB     DECF PLUSW2, W, ACCESS
0894  E105     BNZ 0x8A0
0896  D94B     RCALL __pa_12
0898  0E28     MOVLW 0x28
089A  2632     ADDWF __tmp_0, F, ACCESS
089C  0E35     MOVLW 0x35
089E  D004     BRA 0x8A8
08A0  D946     RCALL __pa_12
08A2  0E40     MOVLW 0x40
08A4  2632     ADDWF __tmp_0, F, ACCESS
08A6  0E35     MOVLW 0x35
08A8  2233     ADDWFC 0x33, F, ACCESS
08AA  D9DA     RCALL __pa_39
08AC  D9E5     RCALL __pa_42
0B2E  0EFB     MOVLW 0xFB
0B30  50DB     MOVF PLUSW2, W, ACCESS
0B32  0D06     MULLW 0x6
0B34  EF40     GOTO 0xC80
0B36  F006     NOP
942:           			}
943:           		break;
08AE  D014     BRA 0x8D8
944:           		case BRAKE_HIGH_SW:
945:           			M_Motor_is_worked(motor_pins);
08B0  D99F     RCALL __pa_28
08B2  D9B2     RCALL __pa_31
0C18  DE02     RCALL M_Motor_is_worked
0C1A  52E5     MOVF POSTDEC1, F, ACCESS
0C1C  52E5     MOVF POSTDEC1, F, ACCESS
0C1E  0012     RETURN 0
946:           			if(time_M_Motor.time_brake_motor++ == TIME_BRAKE_MOTOR_CONST)
08B4  0100     MOVLB 0x0
08B6  C07F     MOVFF 0x7F, __tmp_0
08B8  F032     NOP
08BA  C080     MOVFF 0x80, 0x33
08BC  F033     NOP
08BE  2B7F     INCF 0x7F, F, BANKED
08C0  0E00     MOVLW 0x0
08C2  2380     ADDWFC 0x80, F, BANKED
08C4  0E32     MOVLW 0x32
08C6  1832     XORWF __tmp_0, W, ACCESS
08C8  E107     BNZ 0x8D8
08CA  5033     MOVF 0x33, W, ACCESS
08CC  E105     BNZ 0x8D8
947:           			{	
948:           				time_M_Motor.time_brake_motor = 0;
08CE  6B7F     CLRF 0x7F, BANKED
08D0  6B80     CLRF 0x80, BANKED
949:           				step_brake = ROTATE_REVERSE;
08D2  6B98     CLRF 0x98, BANKED
950:           				return TRUE;
08D4  0E01     MOVLW 0x1
08D6  D001     BRA 0x8DA
951:           			}
952:           	 	break;
953:           	}
954:           	return FALSE;
08D8  0E00     MOVLW 0x0
955:           }
08DA  D0F8     BRA __pa_6
956:            
957:           
958:           	
959:           /*
960:           Реализация выключения двигателя 
961:           Отключается в диагонали моста верхний и нижний ключ
962:           */
963:           static void M_Motor_is_stopped(const rom IOport_motor* motor_pins)
08DC  D8F2     RCALL __pa_5
964:           {
965:           	*motor_pins->portReg_prim_half_bridge &= ~(1 << (motor_pins->pin_num_prim_half_bridge));	
08DE  D9AF     RCALL __pa_35
08E0  E002     BZ 0x8E6
08E2  D94A     RCALL __pa_17
08E4  E1FE     BNZ 0x8E2
08E6  D9AF     RCALL __pa_36
0C46  D849     RCALL __pa_52
0C48  DF34     RCALL __pa_4
0C4A  16EF     ANDWF INDF0, F, ACCESS
0CDA  1CE8     COMF WREG, W, ACCESS
0CDC  6E32     MOVWF __tmp_0, ACCESS
0CDE  EF3E     GOTO 0xA7C
0CE0  F005     NOP
966:           	*motor_pins->portReg_sec_half_bridge &= ~(1 << (motor_pins->pin_num_sec_half_bridge));
08E8  E002     BZ 0x8EE
08EA  D946     RCALL __pa_17
08EC  E1FE     BNZ 0x8EA
08EE  1CE8     COMF WREG, W, ACCESS
08F0  D9AF     RCALL __pa_37
08F2  16EF     ANDWF INDF0, F, ACCESS
0C4C  EF5B     GOTO 0xCB6
0C4E  F006     NOP
0CB6  DEE2     RCALL __pa_1
0CB8  0E05     MOVLW 0x5
0CBA  EF45     GOTO 0xA8A
0CBC  F005     NOP
967:           }
08F4  D0EB     BRA __pa_6
968:           
969:           
970:           /* Для управления включением/отключением т/с2, которым формируется программный ШИМ разгона двигателя */
971:           static void M_Motor_Timer2_change(const uint8_t value_timer_ctrl, const uint8_t en_intr)
08F6  D9DC     RCALL __pa_48
0CB0  DF08     RCALL __pa_5
972:           {
973:           	T2CON = value_timer_ctrl;
08F8  50DB     MOVF PLUSW2, W, ACCESS
08FA  6ECA     MOVWF T2CON, ACCESS
0CB2  0EFE     MOVLW 0xFE
0CB4  0012     RETURN 0
974:           	PIE1 =  en_intr;
08FC  0EFD     MOVLW 0xFD
08FE  50DB     MOVF PLUSW2, W, ACCESS
0900  6E9D     MOVWF PIE1, ACCESS
975:           }
0902  D0E4     BRA __pa_6
976:           
977:           /* Реализация плавного разгона коллекторного двигателя ШИМом от min_PWM_accel до 100%
978:           по заданному времени разгона и значению начальной длительности ШИМа
979:            вычисляется количество "ступенек" ШИМа quantity_steps_accel
980:            */
981:           static void M_Motor_accel(uint8_t index)
0904  D8DE     RCALL __pa_5
0906  0E02     MOVLW 0x2
0908  26E1     ADDWF FSR1, F, ACCESS
982:           {
983:           	static uint8_t quantity_steps_accel;
984:           	static uint16_t delta_t_accel;
985:           	uint16_t temp;
986:           	
987:           	switch(accel_state)
090A  0100     MOVLB 0x0
090C  5161     MOVF accel_state, W, BANKED
090E  0A01     XORLW 0x1
0910  E05E     BZ 0x9CE
0912  0A01     XORLW 0x1
0914  E001     BZ 0x918
0916  D078     BRA 0xA08
988:           	{
989:           		case CALC_PARAMS: //вычисление параметров для плавного разгона ШИМом до номинального напряжения
990:           			//Получаем из меню значение минимальной длительности ШИМа в процентах
991:           			temp = M_Mngm_Get_parameters_buffer()->menu_parameters.Motor[index].min_PWM_accel;	
0918  D90F     RCALL __pa_13
091A  0E02     MOVLW 0x2
091C  D9A6     RCALL __pa_40
091E  6EDE     MOVWF POSTINC2, ACCESS
0920  6ADD     CLRF POSTDEC2, ACCESS
0B38  ECFE     CALL 0x15FC, 0
0B3A  F00A     NOP
0B3C  D8A1     RCALL __pa_43
0B3E  0EFE     MOVLW 0xFE
0B40  50DB     MOVF PLUSW2, W, ACCESS
0B42  0D04     MULLW 0x4
0B44  5032     MOVF __tmp_0, W, ACCESS
0B46  24F3     ADDWF PROD, W, ACCESS
0B48  6EE9     MOVWF FSR0, ACCESS
0B4A  5033     MOVF 0x33, W, ACCESS
0B4C  20F4     ADDWFC PRODH, W, ACCESS
0B4E  6EEA     MOVWF FSR0H, ACCESS
0B50  0012     RETURN 0
0C80  CFF3     MOVFF PROD, __tmp_0
0C82  F032     NOP
0C84  CFF4     MOVFF PRODH, 0x33
0C86  F033     NOP
0C88  0012     RETURN 0
992:           			if(temp == MAX_PWM_DUTY_PERCENT)  		//если максимальный ШИМ, значит разгон не нужен
0922  CFD9     MOVFF FSR2, FSR0
0924  FFE9     NOP
0926  CFDA     MOVFF FSR2H, FSR0H
0928  FFEA     NOP
092A  0E64     MOVLW 0x64
092C  18EE     XORWF POSTINC0, W, ACCESS
092E  E106     BNZ 0x93C
0930  50ED     MOVF POSTDEC0, W, ACCESS
0932  E104     BNZ 0x93C
993:           			{
994:           				accel_state	= MOTOR_IS_ACCELERATED;
0934  0100     MOVLB 0x0
0936  0E02     MOVLW 0x2
0938  6F61     MOVWF accel_state, BANKED
995:           				break;
093A  D066     BRA 0xA08
996:           			}
997:           			else
998:           			{
999:           				//Деление на 4 сдвигом, то есть вся шкала ШИМа - 25 шагов
1000:          				//вычисляем значение длительности ШИМа в каждом периоде для прерывания (от 7 до 25)
1001:          				cnt_duty = temp >> 2;			 	
093C  D97B     RCALL __pa_34
093E  D965     RCALL __pa_30
0940  C032     MOVFF __tmp_0, cnt_duty
0942  F060     NOP
0C0A  90D8     BCF STATUS, 0, ACCESS
0C0C  3233     RRCF 0x33, F, ACCESS
0C0E  3232     RRCF __tmp_0, F, ACCESS
0C10  90D8     BCF STATUS, 0, ACCESS
0C12  3233     RRCF 0x33, F, ACCESS
0C14  3232     RRCF __tmp_0, F, ACCESS
0C16  0012     RETURN 0
1002:          				quantity_steps_accel = (100 - temp) >> 2; 	//вычисляем количество шагов приращения ШИМа
0944  D977     RCALL __pa_34
0946  0E64     MOVLW 0x64
0948  80D8     BSF STATUS, 0, ACCESS
094A  5632     SUBFWB __tmp_0, F, ACCESS
094C  0E00     MOVLW 0x0
094E  5633     SUBFWB 0x33, F, ACCESS
0950  D95C     RCALL __pa_30
0952  C032     MOVFF __tmp_0, 0x11A
0954  F11A     NOP
1003:          				
1004:          				//Получаем значение времени режима разгона двигателя
1005:          				temp = M_Mngm_Get_parameters_buffer()->menu_parameters.Motor[index].time_accel; 
0956  D8F0     RCALL __pa_13
0958  50EF     MOVF INDF0, W, ACCESS
095A  6EDE     MOVWF POSTINC2, ACCESS
095C  6ADD     CLRF POSTDEC2, ACCESS
1006:          				
1007:          				//Получаем количество шагов приращения ШИМа
1008:          				if(!quantity_steps_accel)			//для исключения обработки деления на ноль
095E  0101     MOVLB 0x1
0960  511A     MOVF 0x1A, W, BANKED
0962  E10E     BNZ 0x980
1009:          					delta_t_accel = temp * 10;		//переводим в реальные единицы в мс
0964  0E0A     MOVLW 0xA
0966  6E26     MOVWF 0x26, ACCESS
0968  6A27     CLRF 0x27, ACCESS
096A  CFDE     MOVFF POSTINC2, 0x2B
096C  F02B     NOP
096E  CFDD     MOVFF POSTDEC2, 0x2C
0970  F02C     NOP
0972  ECC4     CALL 0x3588, 0
0974  F01A     NOP
0976  C024     MOVFF 0x24, 0x11B
0978  F11B     NOP
097A  C025     MOVFF 0x25, 0x11C
097C  F11C     NOP
1010:          				else
097E  D01B     BRA 0x9B6
1011:          					delta_t_accel = (temp * 10) / quantity_steps_accel;
0980  511A     MOVF 0x1A, W, BANKED
0982  6E34     MOVWF 0x34, ACCESS
0984  6A35     CLRF 0x35, ACCESS
0986  D956     RCALL __pa_34
0988  0E0A     MOVLW 0xA
098A  0233     MULWF 0x33, ACCESS
098C  CFF3     MOVFF PROD, 0x33
098E  F033     NOP
0990  0232     MULWF __tmp_0, ACCESS
0992  CFF3     MOVFF PROD, __tmp_0
0994  F032     NOP
0996  50F4     MOVF PRODH, W, ACCESS
0998  2633     ADDWF 0x33, F, ACCESS
099A  CFF3     MOVFF PROD, 0x26
099C  F026     NOP
099E  C033     MOVFF 0x33, 0x27
09A0  F027     NOP
09A2  C11A     MOVFF 0x11A, 0x2B
09A4  F02B     NOP
09A6  C035     MOVFF 0x35, 0x2C
09A8  F02C     NOP
09AA  EC63     CALL 0x36C6, 0
09AC  F01B     NOP
09AE  C026     MOVFF 0x26, 0x11B
09B0  F11B     NOP
09B2  C027     MOVFF 0x27, 0x11C
09B4  F11C     NOP
0C34  CFDE     MOVFF POSTINC2, __tmp_0
0C36  F032     NOP
0C38  CFDD     MOVFF POSTDEC2, 0x33
0C3A  F033     NOP
0C3C  0012     RETURN 0
1012:          				accel_state++; 	//переход к разгону 
09B6  0100     MOVLB 0x0
09B8  2B61     INCF accel_state, F, BANKED
1013:          				saved_cnt_duty = cnt_duty;
09BA  C060     MOVFF cnt_duty, saved_cnt_duty
09BC  F062     NOP
1014:          				M_Motor_Timer2_change(TIMER2_INIT_VALUE, ENABLE_TMR2_INTR);
09BE  0E02     MOVLW 0x2
09C0  6EE6     MOVWF POSTINC1, ACCESS
09C2  0E0D     MOVLW 0xD
09C4  6EE6     MOVWF POSTINC1, ACCESS
09C6  DF97     RCALL M_Motor_Timer2_change
09C8  52E5     MOVF POSTDEC1, F, ACCESS
09CA  52E5     MOVF POSTDEC1, F, ACCESS
1015:          			}
1016:          			break;
09CC  D01D     BRA 0xA08
1017:          		case ACCELERATION:	//реализация плавного разгона
1018:          			if(quantity_steps_accel  > 0U)
09CE  0101     MOVLB 0x1
09D0  511A     MOVF 0x1A, W, BANKED
09D2  0800     SUBLW 0x0
09D4  E216     BC 0xA02
1019:          			{
1020:          				//Отсчёт времени приращения 
1021:          				if(time_M_Motor.time_step_accel++ < delta_t_accel)
09D6  0100     MOVLB 0x0
09D8  C07B     MOVFF time_M_Motor, __tmp_0
09DA  F032     NOP
09DC  C07C     MOVFF 0x7C, 0x33
09DE  F033     NOP
09E0  2B7B     INCF time_M_Motor, F, BANKED
09E2  0E00     MOVLW 0x0
09E4  237C     ADDWFC 0x7C, F, BANKED
09E6  0101     MOVLB 0x1
09E8  511B     MOVF 0x1B, W, BANKED
09EA  5C32     SUBWF __tmp_0, W, ACCESS
09EC  511C     MOVF 0x1C, W, BANKED
09EE  5833     SUBWFB 0x33, W, ACCESS
09F0  E30B     BNC 0xA08
1022:          					break;		
1023:          				else //если интервал отсчёта времени приращения окончен, установить следующий уровень ШИМа 
1024:          				{
1025:          					time_M_Motor.time_step_accel = 0;
09F2  0100     MOVLB 0x0
09F4  6B7B     CLRF time_M_Motor, BANKED
09F6  6B7C     CLRF 0x7C, BANKED
1026:          					quantity_steps_accel--;
09F8  0101     MOVLB 0x1
09FA  071A     DECF 0x1A, F, BANKED
1027:          					cnt_duty++;
09FC  0100     MOVLB 0x0
09FE  2B60     INCF cnt_duty, F, BANKED
1028:          				}
1029:          			}
1030:          			else //переход к следующему состоянию автомата состояний
0A00  D003     BRA 0xA08
1031:          			{
1032:          				M_Motor_Timer2_change(TIMER2_OFF_VALUE, DISABLE_TMR2_INTR); //по окончании разгона отключить таймер 2
0A02  D8FD     RCALL __pa_29
1033:          				accel_state++;   //MOTOR_IS_ACCELERATED
0A04  0100     MOVLB 0x0
0A06  2B61     INCF accel_state, F, BANKED
1034:          			}
1035:          			break;
1036:          			
1037:          	}
1038:          }
0A08  0E02     MOVLW 0x2
0A0A  5CE1     SUBWF FSR1, W, ACCESS
0A0C  E202     BC 0xA12
0A0E  6AE1     CLRF FSR1, ACCESS
0A10  52E5     MOVF POSTDEC1, F, ACCESS
0A12  6EE1     MOVWF FSR1, ACCESS
0A14  D05B     BRA __pa_6
1039:          
1040:          /* Реализация в прерывании от т/с2 программного ШИМ частотой примерно 500 Гц */
1041:          void M_Motor_software_PWM_interrrupt(const rom IOport_motor* motor_pins)
0A16  D939     RCALL __pa_44
0AC2  CFD9     MOVFF FSR2, POSTINC1
0AC4  FFE6     NOP
0AC6  CFE1     MOVFF FSR1, FSR2
0AC8  FFD9     NOP
0ACA  0012     RETURN 0
1042:          {
1043:          	if(M_LI_Get_Limit_Switches()->ls_hopper_cover_state)
0A18  E020     BZ 0xA5A
0A74  EC54     CALL 0x26A8, 0
0A76  F013     NOP
0A78  EF53     GOTO 0xCA6
0A7A  F006     NOP
0BA8  0E06     MOVLW 0x6
0BAA  EF35     GOTO 0xC6A
0BAC  F006     NOP
0C6A  D83B     RCALL __pa_53
0C6C  50EF     MOVF INDF0, W, ACCESS
0C6E  0012     RETURN 0
1044:          	{
1045:          		*motor_pins->portReg_sec_half_bridge |= 1 <<( motor_pins->pin_num_sec_half_bridge); 	//включить нижний ключ. который не "ШИМит" (в диагонали моста)
0A1A  D94D     RCALL __pa_49
0A1C  E002     BZ 0xA22
0A1E  D8AC     RCALL __pa_17
0A20  E1FE     BNZ 0xA1E
0A22  D916     RCALL __pa_37
0A24  12EF     IORWF INDF0, F, ACCESS
0BCC  0E03     MOVLW 0x3
0BCE  26F6     ADDWF TBLPTR, F, ACCESS
0BD0  0E00     MOVLW 0x0
0BD2  22F7     ADDWFC TBLPTRH, F, ACCESS
0BD4  0012     RETURN 0
0C50  6E32     MOVWF __tmp_0, ACCESS
0C52  DF14     RCALL __pa_1
0C54  DFBB     RCALL __pa_25
0C56  EF59     GOTO 0xAB2
0C58  F005     NOP
1046:          		if(M_Motor_PWM_period++ < PWM_PERIOD) //если период ШИМа ещё не прошёл
0A26  0100     MOVLB 0x0
0A28  5163     MOVF M_Motor_PWM_period, W, BANKED
0A2A  2B63     INCF M_Motor_PWM_period, F, BANKED
0A2C  6E32     MOVWF __tmp_0, ACCESS
0A2E  0E19     MOVLW 0x19
0A30  5C32     SUBWF __tmp_0, W, ACCESS
0A32  E20F     BC 0xA52
1047:          		{
1048:          			if(!saved_cnt_duty) //выключить ШИМ, если длительность окончена
0A34  5162     MOVF saved_cnt_duty, W, BANKED
0A36  E106     BNZ 0xA44
1049:          				*motor_pins->portReg_prim_half_bridge &= ~(1 << (motor_pins->pin_num_prim_half_bridge));
0A38  D902     RCALL __pa_35
0A3A  E002     BZ 0xA40
0A3C  D89D     RCALL __pa_17
0A3E  E1FE     BNZ 0xA3C
0A40  D94C     RCALL __pa_52
1050:          			else				//включить ШИМ и декрементировать значение длительности
0A42  D015     BRA 0xA6E
1051:          			{
1052:          				saved_cnt_duty--; 
0A44  0762     DECF saved_cnt_duty, F, BANKED
1053:          				*motor_pins->portReg_prim_half_bridge |= 1 << (motor_pins->pin_num_prim_half_bridge);
0A46  D8FB     RCALL __pa_35
0A48  E002     BZ 0xA4E
0A4A  D896     RCALL __pa_17
0A4C  E1FE     BNZ 0xA4A
0A4E  D921     RCALL __pa_45
0AB2  0009     TBLRD*+
0AB4  CFF5     MOVFF TABLAT, FSR0
0AB6  FFE9     NOP
0AB8  0008     TBLRD*
0ABA  CFF5     MOVFF TABLAT, FSR0H
0ABC  FFEA     NOP
0ABE  5032     MOVF __tmp_0, W, ACCESS
0AC0  0012     RETURN 0
1054:          			}
1055:          		}	
1056:          		else //период ШИМа окончен, перезаписать значение длительности и обнулить счётчик времени периода
0A50  D010     BRA 0xA72
1057:          		{
1058:          			saved_cnt_duty = cnt_duty;  
0A52  C060     MOVFF cnt_duty, saved_cnt_duty
0A54  F062     NOP
1059:          			M_Motor_PWM_period = 0;
0A56  6B63     CLRF M_Motor_PWM_period, BANKED
1060:          		}
1061:          	}	
1062:          	else
0A58  D00C     BRA 0xA72
1063:          	{
1064:          		*motor_pins->portReg_prim_half_bridge &= ~(1 << (motor_pins->pin_num_prim_half_bridge));	
0A5A  D8F1     RCALL __pa_35
0A5C  E002     BZ 0xA62
0A5E  D88C     RCALL __pa_17
0A60  E1FE     BNZ 0xA5E
0A62  D8F1     RCALL __pa_36
0A7C  0EFD     MOVLW 0xFD
0A7E  CFDB     MOVFF PLUSW2, TBLPTR
0A80  FFF6     NOP
0A82  0EFE     MOVLW 0xFE
0A84  CFDB     MOVFF PLUSW2, TBLPTRH
0A86  FFF7     NOP
0A88  0012     RETURN 0
0C3E  DF1E     RCALL __pa_1
0C40  0E02     MOVLW 0x2
0C42  EF45     GOTO 0xA8A
0C44  F005     NOP
1065:          		*motor_pins->portReg_sec_half_bridge &= ~(1 << (motor_pins->pin_num_sec_half_bridge));
0A64  E002     BZ 0xA6A
0A66  D888     RCALL __pa_17
0A68  E1FE     BNZ 0xA66
0A6A  D937     RCALL __pa_52
0A6C  D8AF     RCALL __pa_25
0A6E  D821     RCALL __pa_4
0A70  16EF     ANDWF INDF0, F, ACCESS
0A8A  26F6     ADDWF TBLPTR, F, ACCESS
0A8C  0E00     MOVLW 0x0
0A8E  22F7     ADDWFC TBLPTRH, F, ACCESS
0A90  0008     TBLRD*
0A92  50F5     MOVF TABLAT, W, ACCESS
0A94  6E33     MOVWF 0x33, ACCESS
0A96  0E01     MOVLW 0x1
0A98  5233     MOVF 0x33, F, ACCESS
0A9A  0012     RETURN 0
0B78  46E8     RLNCF WREG, F, ACCESS
0B7A  0BFE     ANDLW 0xFE
0B7C  0633     DECF 0x33, F, ACCESS
0B7E  0012     RETURN 0
1066:          	}
1067:          
1068:          }
0A72  D02C     BRA __pa_6
0ACC  52E5     MOVF POSTDEC1, F, ACCESS
0ACE  CFE7     MOVFF INDF1, FSR2
0AD0  FFD9     NOP
0AD2  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_management/module_management.c  -----------
1:             #include "stdint.h"
2:             #include "module_management.h"
3:             #include "module_analog_inputs.h"
4:             #include "module_indication.h"
5:             #include "module_logic_inputs.h"
6:             #include "module_motor.h"
7:             #include "module_fan.h"
8:             #include "menu.h"
9:             #include <p18cxxx.h>
10:            #include "main.h"
11:            #include "eeprom.h"
12:            
13:            #define TIMEOUT_TASK_MANAGEMENT	100
14:            
15:            
16:            uint8_t M_Mngm_State = 0;
17:            uint8_t M_Mngm_Code_Failure = 0;
18:            uint8_t M_Mngm_Previous_State = 0;
19:            uint8_t burning_state =  CALC_PARAMS_PERIOD;
20:            uint16_t timeout_supply_fuel = 0;
21:            uint16_t timeout_check_gas_sensor = 0;
22:            uint8_t saved_temperature_water;
23:            uint16_t timeout_change_temperature_water = 0;
24:            ParametersBuffer M_Mngm_parameters_buffer;
25:            BOOL M_Mngm_state_draught = IS_DRAUGHT;
26:            uint16_t period_load_fuel;
27:            uint16_t timeout;
28:            uint8_t state_accel_fan = CALCULATE;
29:            BOOL phase_cycle = PAUSE_IN_CYCLE;
30:            uint8_t fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_INCREASE;
31:            uint8_t* pFanLevel = 0;
32:            uint8_t level;
33:            
34:            uint8_t M_Mngm_get_fanParamOffset(void)
35:            {
36:            	return fan_param_offset;
156A  0100     MOVLB 0x0
156C  51E7     MOVF fan_param_offset, W, BANKED
37:            } 
156E  0012     RETURN 0
38:            
39:            uint8_t* M_Mngm_get_pFanLevel(void)
40:            {
41:            	return pFanLevel;
1570  C0E8     MOVFF pFanLevel, PROD
1572  FFF3     NOP
1574  C0E9     MOVFF 0xE9, PRODH
1576  FFF4     NOP
42:            }
1578  0012     RETURN 0
43:            
44:            
45:            BOOL M_Mngm_get_phase_cycle(void)
46:            {
47:            	return phase_cycle;
157A  0100     MOVLB 0x0
157C  51E6     MOVF phase_cycle, W, BANKED
48:            }
157E  0012     RETURN 0
49:            
50:            
51:            /*
52:            Проверка изменения температуры воды по истечении заданного таймаута  TIMEOUT_CHECK_CHANGE_TEMPERATURE_WATER (пока 10 минут)
53:            если температура уменьшилась - переход в состояние ожидания. Далее пользователь либо подкидывает топливо в бункер, либо уменьшает 
54:            в меню период загрузок топлива
55:            Возвращает 
56:            1 - если температура уменьшилась
57:            0 - если не уменьшилась и ли увеличилась
58:            */
59:            BOOL M_Mngm_check_change_temperature_water(void)
60:            {
61:            	if(burning_state == INCREASE_TEMPERATURE || burning_state == MAINTENANCE_TEMPERATURE_INCR)
1580  0E02     MOVLW 0x2
1582  0100     MOVLB 0x0
1584  5DDD     SUBWF burning_state, W, BANKED
1586  E003     BZ 0x158E
1588  0E05     MOVLW 0x5
158A  5DDD     SUBWF burning_state, W, BANKED
158C  E11D     BNZ 0x15C8
62:            	{
63:            		if(M_Motor_get_state() == STATE_MODULE_MOTOR_WAITING)	//при работе алгоритма засыпки timeout_change_temperature_water считается после окончания засыпки	
158E  ECD2     CALL 0x1A4, 0
1590  F000     NOP
1592  0801     SUBLW 0x1
1594  E118     BNZ 0x15C6
64:            		{
65:            			if(timeout_change_temperature_water++ >= TIMEOUT_CHECK_CHANGE_TEMPERATURE_WATER )
1596  0100     MOVLB 0x0
1598  C0E2     MOVFF timeout_change_temperature_water, __tmp_0
159A  F032     NOP
159C  C0E3     MOVFF 0xE3, 0x33
159E  F033     NOP
15A0  2BE2     INCF timeout_change_temperature_water, F, BANKED
15A2  0E00     MOVLW 0x0
15A4  23E3     ADDWFC 0xE3, F, BANKED
15A6  0E50     MOVLW 0x50
15A8  5C32     SUBWF __tmp_0, W, ACCESS
15AA  0E46     MOVLW 0x46
15AC  5833     SUBWFB 0x33, W, ACCESS
15AE  E30A     BNC 0x15C4
66:            			{
67:            				timeout_change_temperature_water = 0;	
15B0  6BE2     CLRF timeout_change_temperature_water, BANKED
15B2  6BE3     CLRF 0xE3, BANKED
68:            				if(M_AI_Get_ADC_Data(CHN_T_WATER)->param < saved_temperature_water)  //если температура уменьшилась
15B4  DB7E     RCALL __pa_25
15B6  010F     MOVLB 0xF
15B8  5100     MOVF _OS_BestTask, W, BANKED
15BA  5C32     SUBWF __tmp_0, W, ACCESS
15BC  E201     BC 0x15C0
69:            				{
70:            					return TEMPERATURE_DECREASED;
15BE  0C01     RETLW 0x1
71:            				}
72:            				else
73:            				{
74:            					 //если температура выросла или не изменилась, перезаписать её новое значение
75:            					saved_temperature_water = M_AI_Get_ADC_Data(CHN_T_WATER)->param; 
15C0  DB7C     RCALL __pa_26
76:            					return TEMPERATURE_INCREASED_OR_EQUAL;
15C2  0C00     RETLW 0x0
77:            				}
78:            			}
79:            			else
80:            			{
81:            				return TEMPERATURE_INCREASED_OR_EQUAL;
15C4  0C00     RETLW 0x0
82:            			}
83:            		}
84:            		else
85:            		{
86:            			return TEMPERATURE_INCREASED_OR_EQUAL;	
15C6  0C00     RETLW 0x0
87:            		}
88:            	}
89:            	else
90:            	{
91:            		timeout_change_temperature_water = 0;
15C8  6BE2     CLRF timeout_change_temperature_water, BANKED
15CA  6BE3     CLRF 0xE3, BANKED
92:            		return TEMPERATURE_INCREASED_OR_EQUAL;
93:            	}
94:            }
15CC  0C00     RETLW 0x0
95:            
96:            void M_Mngm_set_saved_temperature_water(uint8_t value)
15CE  DB6E     RCALL __pa_24
97:            {
98:            	saved_temperature_water = value;	
15D0  CFDB     MOVFF PLUSW2, saved_temperature_water
15D2  FF00     NOP
99:            }
15D4  D2F5     BRA __pa_6
100:           
101:           
102:           void M_Mngm_clear_timeouts(void)
103:           {
104:           	timeout_supply_fuel = timeout_check_gas_sensor = /*burning_state = */timeout_change_temperature_water = timeout = 0;
15D6  0E00     MOVLW 0x0
15D8  010F     MOVLB 0xF
15DA  6F38     MOVWF 0x38, BANKED
15DC  6B39     CLRF 0x39, BANKED
15DE  0100     MOVLB 0x0
15E0  6FE2     MOVWF timeout_change_temperature_water, BANKED
15E2  6BE3     CLRF 0xE3, BANKED
15E4  6FE0     MOVWF timeout_check_gas_sensor, BANKED
15E6  6BE1     CLRF 0xE1, BANKED
15E8  6FDE     MOVWF timeout_supply_fuel, BANKED
15EA  6BDF     CLRF 0xDF, BANKED
105:           }
15EC  0012     RETURN 0
106:           
107:           uint8_t M_Mngm_get_burning_state(void)
108:           {
109:           	return burning_state;
15EE  0100     MOVLB 0x0
15F0  51DD     MOVF burning_state, W, BANKED
110:           }
15F2  0012     RETURN 0
111:           
112:           void M_Mngm_set_burning_state(uint8_t value)
15F4  DB5B     RCALL __pa_24
113:           {
114:           	burning_state = value;
15F6  CFDB     MOVFF PLUSW2, burning_state
15F8  F0DD     NOP
115:           }
15FA  D2E2     BRA __pa_6
116:           
117:           
118:           ParametersBuffer* M_Mngm_Get_parameters_buffer(void)
119:           {
120:           	return &M_Mngm_parameters_buffer;
15FC  0E01     MOVLW 0x1
15FE  6E32     MOVWF __tmp_0, ACCESS
1600  0E0F     MOVLW 0xF
1602  C032     MOVFF __tmp_0, PROD
1604  FFF3     NOP
1606  6EF4     MOVWF PRODH, ACCESS
121:           }
1608  0012     RETURN 0
122:           
123:           void M_Mngm_Set_state(uint8_t value)
160A  DB50     RCALL __pa_24
124:           {
125:           	M_Mngm_State = value;
160C  CFDB     MOVFF PLUSW2, M_Mngm_State
160E  F0DA     NOP
126:           }
1610  D2D7     BRA __pa_6
127:           
128:           uint8_t M_Mngm_Get_previous_state(void)
129:           {
130:           	return M_Mngm_Previous_State;
1612  0100     MOVLB 0x0
1614  51DC     MOVF M_Mngm_Previous_State, W, BANKED
131:           }
1616  0012     RETURN 0
132:           
133:           uint8_t M_Mngm_Get_state(void)
134:           {
135:           	return M_Mngm_State;
1618  0100     MOVLB 0x0
161A  51DA     MOVF M_Mngm_State, W, BANKED
136:           }
161C  0012     RETURN 0
137:           
138:           uint8_t M_Mngm_Get_Code_Failure(void)
139:           {
140:           	return M_Mngm_Code_Failure;
161E  0100     MOVLB 0x0
1620  51DB     MOVF M_Mngm_Code_Failure, W, BANKED
141:           }
1622  0012     RETURN 0
142:           
143:           void M_Mngm_Set_Code_Failure(uint8_t value)
1624  DB43     RCALL __pa_24
144:           {
145:           	M_Mngm_Code_Failure = value;	
1626  CFDB     MOVFF PLUSW2, M_Mngm_Code_Failure
1628  F0DB     NOP
146:           }
162A  D2CA     BRA __pa_6
147:           
148:           void M_Mngm_Set_state_draught(BOOL value)
162C  DB3F     RCALL __pa_24
1BC8  CFD9     MOVFF FSR2, POSTINC1
1BCA  FFE6     NOP
1BCC  CFE1     MOVFF FSR1, FSR2
1BCE  FFD9     NOP
1BD0  0012     RETURN 0
1CAC  DF8D     RCALL __pa_7
149:           {
150:           	M_Mngm_state_draught = value;
162E  CFDB     MOVFF PLUSW2, M_Mngm_state_draught
1630  F0E4     NOP
1CAE  0EFE     MOVLW 0xFE
1CB0  0012     RETURN 0
151:           }
1632  D2C6     BRA __pa_6
152:           
153:           
154:           /* 
155:           Функция проверки аварии тяги (по критерию: через 10 минут после начала процесса горения 
156:           температура исходящего газа менее 60 градусов) 
157:           */
158:           void  M_Mngm_check_draught_failure(void)
159:           {
160:           	 if(M_Motor_get_state() == STATE_MODULE_MOTOR_WAITING)
1634  ECD2     CALL 0x1A4, 0
1636  F000     NOP
1638  0801     SUBLW 0x1
163A  E11A     BNZ 0x1670
161:           	{
162:           		if(timeout_check_gas_sensor++ == TIMEOUT_CHECK_FAILURE_DRAUGHT)
163C  0100     MOVLB 0x0
163E  C0E0     MOVFF timeout_check_gas_sensor, __tmp_0
1640  F032     NOP
1642  C0E1     MOVFF 0xE1, 0x33
1644  F033     NOP
1646  2BE0     INCF timeout_check_gas_sensor, F, BANKED
1648  0E00     MOVLW 0x0
164A  23E1     ADDWFC 0xE1, F, BANKED
164C  0E70     MOVLW 0x70
164E  1832     XORWF __tmp_0, W, ACCESS
1650  E10F     BNZ 0x1670
1652  0E17     MOVLW 0x17
1654  1833     XORWF 0x33, W, ACCESS
1656  E10C     BNZ 0x1670
163:           		{
164:           			timeout_check_gas_sensor = 0;	
1658  6BE0     CLRF timeout_check_gas_sensor, BANKED
165A  6BE1     CLRF 0xE1, BANKED
165:           			if(M_AI_Get_ADC_Data(CHN_T_GAS)->param < LOW_THRESHOLD_IN_BURNING_TEMPER_GAS)
165C  6AE6     CLRF POSTINC1, ACCESS
165E  DA7F     RCALL __pa_0
1660  CFEF     MOVFF INDF0, __tmp_0
1662  F032     NOP
1664  0E06     MOVLW 0x6
1666  5C32     SUBWF __tmp_0, W, ACCESS
1668  E203     BC 0x1670
166:           			{
167:           				M_Mngm_state_draught = NO_DRAUGHT;
166A  0100     MOVLB 0x0
166C  6BE4     CLRF M_Mngm_state_draught, BANKED
168:           				M_fan_set_ctrl_fan(OFF);
166E  DADD     RCALL __pa_12
169:           			}
170:           		}
171:           	}
172:           }
1670  0012     RETURN 0
173:           
174:           
175:           /*
176:           Функция проверки аварии
177:           Возвращает код аварии (0 - её отсутствие)
178:           */
179:           
180:           uint8_t M_Mngm_Check_Failure(void)
181:           {
182:           	if(M_Mngm_parameters_buffer.menu_parameters.code_failure == NO_FAILURE)
1672  010F     MOVLB 0xF
1674  5133     MOVF 0x33, W, BANKED
1676  E174     BNZ 0x1760
183:           	{
184:           		
185:           		if(M_Mngm_state_draught == NO_DRAUGHT)		//авария тяги в дымоход
1678  0100     MOVLB 0x0
167A  51E4     MOVF M_Mngm_state_draught, W, BANKED
167C  E101     BNZ 0x1680
186:           		{	
187:           			return CODE_FAILURE_DRAUGHT; 	
167E  0C10     RETLW 0x10
188:           		}
189:           		if((M_AI_Get_ADC_Data(CHN_T_GAS)->param) == BREAK_SENSOR_VALUE) 				//обрыв датчика температуры газа
1680  6AE6     CLRF POSTINC1, ACCESS
1682  DA6D     RCALL __pa_0
1684  50EF     MOVF INDF0, W, ACCESS
1686  08FA     SUBLW 0xFA
1688  E101     BNZ 0x168C
190:           		{
191:           			return CODE_FAILURE_BREAK_T_GAS_SENSOR;		
168A  0C01     RETLW 0x1
192:           		}	
193:           		 if((M_AI_Get_ADC_Data(CHN_T_GAS)->param) == SHORT_CIRCUIT_SENSOR_VALUE) 	//КЗ датчика температуры газа
168C  6AE6     CLRF POSTINC1, ACCESS
168E  DA67     RCALL __pa_0
1690  50EF     MOVF INDF0, W, ACCESS
1692  08FB     SUBLW 0xFB
1694  E101     BNZ 0x1698
194:           		{
195:           			return  CODE_FAILURE_SHORT_CIRCUIT_T_GAS_SENSOR;	
1696  0C02     RETLW 0x2
196:           		}
197:           		if((M_AI_Get_ADC_Data(CHN_T_WATER)->param) == BREAK_SENSOR_VALUE) 			//обрыв датчика температуры воды
1698  DADF     RCALL __pa_17
169A  50EF     MOVF INDF0, W, ACCESS
169C  08FA     SUBLW 0xFA
169E  E101     BNZ 0x16A2
198:           		{
199:           			return CODE_FAILURE_BREAK_T_WATER_SENSOR;		
16A0  0C03     RETLW 0x3
200:           		}	
201:           		if((M_AI_Get_ADC_Data(CHN_T_WATER)->param) == SHORT_CIRCUIT_SENSOR_VALUE) 	//КЗ датчика температуры воды
16A2  DADA     RCALL __pa_17
16A4  50EF     MOVF INDF0, W, ACCESS
16A6  08FB     SUBLW 0xFB
16A8  E101     BNZ 0x16AC
202:           		{
203:           			return CODE_FAILURE_SHORT_CIRCUIT_T_WATER_SENSOR;
16AA  0C04     RETLW 0x4
204:           		} 
205:           		if(M_Motor_get_state_failure(INDEX_OF_AGITATOR)->is_failure)									//авария датчика ворошителя
16AC  0E01     MOVLW 0x1
16AE  6EE6     MOVWF POSTINC1, ACCESS
16B0  DA6C     RCALL __pa_2
16B2  50EF     MOVF INDF0, W, ACCESS
16B4  E005     BZ 0x16C0
206:           		{
207:           			if(M_Motor_get_state_failure(INDEX_OF_AGITATOR)->type_ls == AGITATOR_LS)	
16B6  0E01     MOVLW 0x1
16B8  DAEA     RCALL __pa_21
16BA  0804     SUBLW 0x4
16BC  E101     BNZ 0x16C0
208:           				return CODE_FAILURE_MOTOR_LS_AGITATOR;
16BE  0C0F     RETLW 0xF
209:           		}
210:           		if(M_Motor_get_state_failure(INDEX_OF_DISPENSER)->is_failure)
16C0  6AE6     CLRF POSTINC1, ACCESS
16C2  DA63     RCALL __pa_2
16C4  50EF     MOVF INDF0, W, ACCESS
16C6  E00D     BZ 0x16E2
211:           		{
212:           			if(M_Motor_get_state_failure(INDEX_OF_DISPENSER)->type_ls == START_LS)				//авария стартового концевика дозатора	
16C8  6AE6     CLRF POSTINC1, ACCESS
16CA  DA5F     RCALL __pa_2
16CC  52EE     MOVF POSTINC0, F, ACCESS
16CE  04EF     DECF INDF0, W, ACCESS
16D0  E101     BNZ 0x16D4
213:           				return CODE_FAILURE_MOTOR_LS_DISPENSER_START;
16D2  0C05     RETLW 0x5
214:           			if( M_Motor_get_state_failure( INDEX_OF_DISPENSER )->type_ls == FINISH_LS )				//авария финишного концевика дозатора
16D4  6AE6     CLRF POSTINC1, ACCESS
16D6  DA59     RCALL __pa_2
16D8  52EE     MOVF POSTINC0, F, ACCESS
16DA  50EF     MOVF INDF0, W, ACCESS
16DC  0802     SUBLW 0x2
16DE  E101     BNZ 0x16E2
215:           				return CODE_FAILURE_MOTOR_LS_DISPENSER_FINISH;	
16E0  0C06     RETLW 0x6
216:           		}
217:           		if(M_Motor_get_state_failure( INDEX_OF_SHATTER )->is_failure)
16E2  0E02     MOVLW 0x2
16E4  6EE6     MOVWF POSTINC1, ACCESS
16E6  DA51     RCALL __pa_2
16E8  50EF     MOVF INDF0, W, ACCESS
16EA  E011     BZ 0x170E
1B8A  ECDE     CALL 0x1BC, 0
1B8C  F000     NOP
1B8E  52E5     MOVF POSTDEC1, F, ACCESS
1B90  EF4C     GOTO 0x1C98
1B92  F00E     NOP
218:           		{
219:           			if( M_Motor_get_state_failure(INDEX_OF_SHATTER)->type_ls == START_LS )				//авария стартового концевика заслонки
16EC  0E02     MOVLW 0x2
16EE  6EE6     MOVWF POSTINC1, ACCESS
16F0  DA4C     RCALL __pa_2
16F2  52EE     MOVF POSTINC0, F, ACCESS
16F4  04EF     DECF INDF0, W, ACCESS
16F6  E101     BNZ 0x16FA
220:           				return CODE_FAILURE_MOTOR_LS_SHATTER_START;
16F8  0C07     RETLW 0x7
221:           			 if( M_Motor_get_state_failure(INDEX_OF_SHATTER)->type_ls == FINISH_LS )			//авария финишного концевика заслонки		
16FA  0E02     MOVLW 0x2
16FC  DAC8     RCALL __pa_21
16FE  0802     SUBLW 0x2
1700  E101     BNZ 0x1704
222:           				return CODE_FAILURE_MOTOR_LS_SHATTER_FINISH;	
1702  0C08     RETLW 0x8
223:           			 if( M_Motor_get_state_failure(INDEX_OF_SHATTER)->type_ls == AFTER_FINISH_LS ) 	//авария "после"финишного концевика заслонки
1704  0E02     MOVLW 0x2
1706  DAC3     RCALL __pa_21
1708  0803     SUBLW 0x3
170A  E101     BNZ 0x170E
1C8E  6EE6     MOVWF POSTINC1, ACCESS
1C90  DF7C     RCALL __pa_2
1C92  52EE     MOVF POSTINC0, F, ACCESS
1C94  50EF     MOVF INDF0, W, ACCESS
1C96  0012     RETURN 0
224:           				return CODE_FAILURE_MOTOR_LS_AFTER_SHATTER_FINISH;	
170C  0C09     RETLW 0x9
225:           		}
226:           		if (*(M_Motor_get_false_state_LS() + INDEX_FALSE_STATE_LS_START_DISPENSER))		//авария "Ложное состояние стартового концевика дозатора"
170E  DA54     RCALL __pa_5
1710  50EF     MOVF INDF0, W, ACCESS
1712  E001     BZ 0x1716
227:           			return CODE_FAILURE_MOTOR_LS_DISPENSER_START_FALSE_ON;
1714  0C0A     RETLW 0xA
228:           		if (*(M_Motor_get_false_state_LS() + INDEX_FALSE_STATE_LS_FINISH_DISPENSER))		//авария "Ложное состояние финишного концевика дозатора"
1716  DA50     RCALL __pa_5
1718  0E01     MOVLW 0x1
171A  DAA2     RCALL __pa_18
171C  E001     BZ 0x1720
229:           			return CODE_FAILURE_MOTOR_LS_DISPENSER_FINISH_FALSE_ON;	
171E  0C0B     RETLW 0xB
230:           		if (*(M_Motor_get_false_state_LS() + INDEX_FALSE_STATE_LS_START_SHATTER))			//авария "Ложное состояние стартового концевика заслонки"	
1720  DA4B     RCALL __pa_5
1722  0E02     MOVLW 0x2
1724  DA9D     RCALL __pa_18
1726  E001     BZ 0x172A
231:           			return  CODE_FAILURE_MOTOR_LS_SHATTER_START_FALSE_ON;
1728  0C0C     RETLW 0xC
232:           		if (*(M_Motor_get_false_state_LS() +  INDEX_FALSE_STATE_LS_FINISH_SHATTER))			//авария "Ложное состояние финишного концевика заслонки"	
172A  DA46     RCALL __pa_5
172C  0E03     MOVLW 0x3
172E  DA98     RCALL __pa_18
1730  E001     BZ 0x1734
233:           			return CODE_FAILURE_MOTOR_LS_SHATTER_FINISH_FALSE_ON;
1732  0C0D     RETLW 0xD
234:           		if (*(M_Motor_get_false_state_LS() + INDEX_FALSE_STATE_LS_AFTER_FINISH_SHATTER))	//авария "Ложное состояние послефинишного концевика заслонки"	
1734  DA41     RCALL __pa_5
1736  0E04     MOVLW 0x4
1738  DA93     RCALL __pa_18
173A  E001     BZ 0x173E
1BB8  ECB9     CALL 0x172, 0
1BBA  F000     NOP
1BBC  EF4C     GOTO 0x1C98
1BBE  F00E     NOP
235:           			return CODE_FAILURE_MOTOR_LS_AFTER_SHATTER_FINISH_FALSE_ON;
173C  0C0E     RETLW 0xE
236:           		#ifndef NO_220V_CONTROL  //если на плату заведено 220В
237:           			if(!M_fan_get_is_220V())																		//авария "Отсутствие 220В" (по синхроимпульсам)
238:           				return CODE_FAILURE_NO_220V;
239:           		#endif	
240:           		M_Menu_write_changed_param(INDEX_OF_CODE_FAILURE, DataEERead (INDEX_OF_CODE_FAILURE), NO_FAILURE);
173E  6AE6     CLRF POSTINC1, ACCESS
1740  0E32     MOVLW 0x32
1742  6EE6     MOVWF POSTINC1, ACCESS
1744  6AE6     CLRF POSTINC1, ACCESS
1746  EC2C     CALL 0x2A58, 0
1748  F015     NOP
174A  52E5     MOVF POSTDEC1, F, ACCESS
174C  52E5     MOVF POSTDEC1, F, ACCESS
174E  6EE6     MOVWF POSTINC1, ACCESS
1750  0E32     MOVLW 0x32
1752  6EE6     MOVWF POSTINC1, ACCESS
1754  EC93     CALL 0x1D26, 0
1756  F00E     NOP
1758  52E5     MOVF POSTDEC1, F, ACCESS
175A  52E5     MOVF POSTDEC1, F, ACCESS
175C  52E5     MOVF POSTDEC1, F, ACCESS
241:           			return NO_FAILURE; 
175E  0C00     RETLW 0x0
242:           	}
243:           	else
244:           	{
245:           		return M_Mngm_parameters_buffer.menu_parameters.code_failure;
1760  5133     MOVF 0x33, W, BANKED
246:           	}
247:           }
1762  0012     RETURN 0
248:           
249:           /* Автомат состояний модуля управленяи */
250:           void M_Mngm_Run (void)
251:           {
252:           	if(M_Ind_Get_state() == STATE_IND_INIT)
1764  ECA5     CALL 0xD4A, 0
1766  F006     NOP
1768  0900     IORLW 0x0
176A  E101     BNZ 0x176E
253:           		return;
176C  0012     RETURN 0
254:           			
255:           	if(M_Mngm_State != STATE_PAUSE)  M_Mngm_Code_Failure = M_Mngm_Check_Failure();  //проверка аварий везде кроме режима "Пауза"
176E  0E03     MOVLW 0x3
1770  0100     MOVLB 0x0
1772  5DDA     SUBWF M_Mngm_State, W, BANKED
1774  E003     BZ 0x177C
1776  DF7D     RCALL M_Mngm_Check_Failure
1778  0100     MOVLB 0x0
177A  6FDB     MOVWF M_Mngm_Code_Failure, BANKED
256:           
257:           		switch(M_Mngm_State)
177C  51DA     MOVF M_Mngm_State, W, BANKED
177E  0A05     XORLW 0x5
1780  E01A     BZ 0x17B6
1782  0A01     XORLW 0x1
1784  E014     BZ 0x17AE
1786  0A07     XORLW 0x7
1788  E010     BZ 0x17AA
178A  0A01     XORLW 0x1
178C  E00A     BZ 0x17A2
178E  0A03     XORLW 0x3
1790  E006     BZ 0x179E
1792  0A01     XORLW 0x1
1794  E001     BZ 0x1798
1796  0012     RETURN 0
258:           		{
259:           			case STATE_WAITING :				//ожидание
260:           				M_Mngm_Previous_State = STATE_WAITING;
1798  6BDC     CLRF M_Mngm_Previous_State, BANKED
261:           				M_Mngm_waiting();					
179A  EFEF     GOTO 0x17DE
179C  F00B     NOP
262:           			break;
263:           			case STATE_FUEL_SUPPLY :			//загрузка топлива
264:           				M_Mngm_fuel_supply();
179E  EFF8     GOTO 0x17F0
17A0  F00B     NOP
265:           			break;
266:           			case STATE_BURNING :				//горение и поддержание температуры воды
267:           				M_Mngm_Previous_State = STATE_BURNING;
17A2  0E02     MOVLW 0x2
17A4  6FDC     MOVWF M_Mngm_Previous_State, BANKED
268:           				M_Mngm_burning();
17A6  EF18     GOTO 0x1830
17A8  F00C     NOP
269:           			break;
270:           			case STATE_PAUSE :				//пауза
271:           				M_Mngm_pause();
17AA  EFC2     GOTO 0x1984
17AC  F00C     NOP
272:           			break;
273:           			case STATE_CLEAN_CHIMNEY :		//очистка дымохода
274:           				M_Mngm_Previous_State = STATE_CLEAN_CHIMNEY;
17AE  0E04     MOVLW 0x4
17B0  6FDC     MOVWF M_Mngm_Previous_State, BANKED
275:           				M_Mngm_clean_chimney();
17B2  EFCE     GOTO 0x199C
17B4  F00C     NOP
276:           			break;
277:           			case STATE_FAILURE :				//авария
278:           				M_Mngm_failure();
17B6  EFD4     GOTO 0x19A8
17B8  F00C     NOP
279:           			break;
280:           		}
281:           }
282:           
283:           /*
284:           Проверка необходимости перехода в режим "Пауза"
285:           Если концевик отпущен - перейти в "Паузу"
286:           */
287:           void M_Mngm_need_to_pause(const uint8_t prev_state)
17BA  DA06     RCALL __pa_7
288:           {
289:           	if(!(M_LI_Get_Limit_Switches()->ls_hopper_cover_state)) //если открыта дверь бункера, перейти в состояние паузы
17BC  DA30     RCALL __pa_11
17BE  E10E     BNZ 0x17DC
1C1E  EC54     CALL 0x26A8, 0
1C20  F013     NOP
1C22  D83A     RCALL __pa_22
1C24  0E06     MOVLW 0x6
1C26  EF30     GOTO 0x1C60
1C28  F00E     NOP
1C60  26E9     ADDWF FSR0, F, ACCESS
1C62  0E00     MOVLW 0x0
1C64  22EA     ADDWFC FSR0H, F, ACCESS
1C66  50EF     MOVF INDF0, W, ACCESS
1C68  0012     RETURN 0
1C98  CFF3     MOVFF PROD, FSR0
1C9A  FFE9     NOP
1C9C  CFF4     MOVFF PRODH, FSR0H
1C9E  FFEA     NOP
1CA0  0012     RETURN 0
290:           	{
291:           		M_Ind_Set_Previous_State(M_Ind_Get_state());
17C0  ECA5     CALL 0xD4A, 0
17C2  F006     NOP
17C4  6EE6     MOVWF POSTINC1, ACCESS
17C6  EC9D     CALL 0xD3A, 0
17C8  F006     NOP
17CA  52E5     MOVF POSTDEC1, F, ACCESS
292:           		M_Ind_Set_state(STATE_VIEW_PAUSE);	
17CC  0E05     MOVLW 0x5
17CE  DA3A     RCALL __pa_15
293:           		M_Mngm_Previous_State = prev_state;
17D0  0EFE     MOVLW 0xFE
17D2  CFDB     MOVFF PLUSW2, M_Mngm_Previous_State
17D4  F0DC     NOP
294:           		M_Mngm_State = STATE_PAUSE; 
17D6  0100     MOVLB 0x0
17D8  0E03     MOVLW 0x3
17DA  6FDA     MOVWF M_Mngm_State, BANKED
295:           	}	
296:           	 
297:           }
17DC  D1F1     BRA __pa_6
298:           
299:           void M_Mngm_waiting(void)
300:           {
301:           	pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.rotational_speed_fan;
17DE  0100     MOVLB 0x0
17E0  DA36     RCALL __pa_16
302:           	fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_INCREASE;
17E2  0E5E     MOVLW 0x5E
17E4  6FE7     MOVWF fan_param_offset, BANKED
303:           	M_Mngm_need_to_pause(STATE_WAITING);	//Проверка необходимости перехода в режим "Пауза"
17E6  6AE6     CLRF POSTINC1, ACCESS
17E8  DA28     RCALL __pa_14
304:           	if (M_Mngm_Code_Failure  != NO_FAILURE)
17EA  E001     BZ 0x17EE
305:           	{	
306:           		M_Mngm_State = STATE_FAILURE;
17EC  D9C1     RCALL __pa_1
307:           		DataEEWrite (M_Mngm_Code_Failure, INDEX_OF_CODE_FAILURE );
308:           	}
309:           	else
310:           	{
311:           		//если нажата кнопка Start\Menu\Stop - переход в состояние Burning
312:           	}
313:           }
17EE  0012     RETURN 0
314:           
315:           
316:           void M_Mngm_fuel_supply(void)
317:           {
318:           	M_Mngm_need_to_pause(STATE_FUEL_SUPPLY);	//Проверка необходимости перехода в режим "Пауза"
17F0  0E01     MOVLW 0x1
17F2  6EE6     MOVWF POSTINC1, ACCESS
17F4  DFE2     RCALL M_Mngm_need_to_pause
17F6  52E5     MOVF POSTDEC1, F, ACCESS
319:           	M_fan_set_ctrl_fan(OFF);
17F8  DA18     RCALL __pa_12
320:           	if (M_Mngm_Code_Failure  != NO_FAILURE)
17FA  0100     MOVLB 0x0
17FC  51DB     MOVF M_Mngm_Code_Failure, W, BANKED
17FE  E004     BZ 0x1808
321:           	{
322:           		M_Mngm_Previous_State = STATE_FUEL_SUPPLY;
1800  0E01     MOVLW 0x1
1802  6FDC     MOVWF M_Mngm_Previous_State, BANKED
323:           		M_Mngm_State = STATE_FAILURE;
1804  EFB8     GOTO 0x1B70
1806  F00D     NOP
324:           		DataEEWrite (M_Mngm_Code_Failure, INDEX_OF_CODE_FAILURE );
325:           		//M_fan_set_ctrl_fan(OFF);
326:           	}
327:           	else
328:           	{
329:           		if(M_Motor_get_state() == STATE_MODULE_MOTOR_WAITING && (M_Mngm_Previous_State == STATE_BURNING || 
1808  ECD2     CALL 0x1A4, 0
180A  F000     NOP
180C  0801     SUBLW 0x1
1810  0E02     MOVLW 0x2
1812  0100     MOVLB 0x0
1814  5DDC     SUBWF M_Mngm_Previous_State, W, BANKED
330:           			(M_Mngm_Previous_State == STATE_FUEL_SUPPLY && !Menu_get_manual_supply()))) //если отсутствует признак работы двигателя
180E  E10F     BNZ 0x182E
1816  E006     BZ 0x1824
1818  05DC     DECF M_Mngm_Previous_State, W, BANKED
181A  E109     BNZ 0x182E
181C  EC64     CALL 0x1CC8, 0
181E  F00E     NOP
1820  0900     IORLW 0x0
1822  E105     BNZ 0x182E
331:           		{
332:           			M_Mngm_State = STATE_BURNING;	
1824  0100     MOVLB 0x0
1826  0E02     MOVLW 0x2
1828  6FDA     MOVWF M_Mngm_State, BANKED
333:           			M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
182A  0E03     MOVLW 0x3
182C  DA0B     RCALL __pa_15
334:           		}
335:           	}
336:           }
182E  0012     RETURN 0
337:           
338:           
339:           /* Реализация алгоритма горения с поддержианием температуры */
340:           void M_Mngm_burning(void)
1830  D9CB     RCALL __pa_7
1832  0E02     MOVLW 0x2
1834  26E1     ADDWF FSR1, F, ACCESS
341:           {
342:           	uint16_t temp;
343:           	
344:           	M_Mngm_need_to_pause(STATE_BURNING);	//Проверка необходимости перехода в режим "Пауза"
1836  6EE6     MOVWF POSTINC1, ACCESS
1838  DA00     RCALL __pa_14
345:           	if (M_Mngm_Code_Failure  != NO_FAILURE)
183A  E005     BZ 0x1846
346:           	{
347:           		M_Mngm_clear_timeouts();
183C  DECC     RCALL M_Mngm_clear_timeouts
348:           		M_Mngm_State = STATE_FAILURE;
183E  0100     MOVLB 0x0
1840  D997     RCALL __pa_1
349:           		DataEEWrite (M_Mngm_Code_Failure, INDEX_OF_CODE_FAILURE );
350:           		M_fan_set_ctrl_fan(OFF);
1842  D9F3     RCALL __pa_12
351:           	}
352:           	else
1844  D098     BRA 0x1976
353:           	{
354:           		// проверка увеличения температуры воды по истечении заданного таймаута
355:           		if(M_Mngm_check_change_temperature_water())
1846  DE9C     RCALL M_Mngm_check_change_temperature_water
1848  0900     IORLW 0x0
184A  E006     BZ 0x1858
356:           		{
357:           			M_fan_set_ctrl_fan(OFF);			//выключить алгоритм работы вентилятора
184C  D9EE     RCALL __pa_12
358:           			M_Mngm_State = STATE_WAITING;	//перейти в режим ожидания при невозможности поддержания температуры
184E  0100     MOVLB 0x0
1850  6BDA     CLRF M_Mngm_State, BANKED
359:           			burning_state =  CALC_PARAMS_PERIOD;
1852  6BDD     CLRF burning_state, BANKED
360:           			M_Mngm_clear_timeouts();
1854  DEC0     RCALL M_Mngm_clear_timeouts
361:           		}	
362:           		else
1856  D08F     BRA 0x1976
363:           		{
364:           			#ifdef NO_CONTROL_DRAUGHT
365:           				M_Mngm_state_draught = IS_DRAUGHT;
1858  0100     MOVLB 0x0
185A  0E01     MOVLW 0x1
185C  6FE4     MOVWF M_Mngm_state_draught, BANKED
366:           			#else
367:           				M_Mngm_check_draught_failure(); 	//проверка тяги в дымоход, если отсутствует - переход в состояние аварии
368:           			#endif	
369:           			if(M_Mngm_state_draught == IS_DRAUGHT)
185E  04E8     DECF WREG, W, ACCESS
1860  E001     BZ 0x1864
1862  D089     BRA 0x1976
370:           			{	
371:           				switch(burning_state)
1864  51DD     MOVF burning_state, W, BANKED
1866  0A05     XORLW 0x5
1868  E06B     BZ 0x1940
186A  0A01     XORLW 0x1
186C  E061     BZ 0x1930
186E  0A07     XORLW 0x7
1870  E048     BZ 0x1902
1872  0A01     XORLW 0x1
1874  E036     BZ 0x18E2
1876  0A03     XORLW 0x3
1878  E01F     BZ 0x18B8
187A  0A01     XORLW 0x1
187C  E001     BZ 0x1880
187E  D07B     BRA 0x1976
372:           				{
373:           					case CALC_PARAMS_PERIOD:
374:           						period_load_fuel = (uint16_t)M_Mngm_parameters_buffer.menu_parameters.period_load_fuel_in_heat
375:           						[M_Mngm_parameters_buffer.menu_parameters.fuel_type] *1000; //вычисление периода загрузок топлива в горении
1880  010F     MOVLB 0xF
1882  5129     MOVF 0x29, W, BANKED
1884  6AEA     CLRF FSR0H, ACCESS
1886  0F2C     ADDLW 0x2C
1888  6EE9     MOVWF FSR0, ACCESS
188A  0E0F     MOVLW 0xF
188C  22EA     ADDWFC FSR0H, F, ACCESS
188E  50EF     MOVF INDF0, W, ACCESS
1890  6F36     MOVWF 0x36, BANKED
1892  6B37     CLRF 0x37, BANKED
1894  0EE8     MOVLW 0xE8
1896  0337     MULWF 0x37, BANKED
1898  CFF3     MOVFF PROD, 0xF37
189A  FF37     NOP
189C  0E03     MOVLW 0x3
189E  0336     MULWF 0x36, BANKED
18A0  50F3     MOVF PROD, W, ACCESS
18A2  2737     ADDWF 0x37, F, BANKED
18A4  0EE8     MOVLW 0xE8
18A6  0336     MULWF 0x36, BANKED
18A8  CFF3     MOVFF PROD, period_load_fuel
18AA  FF36     NOP
18AC  50F4     MOVF PRODH, W, ACCESS
18AE  2737     ADDWF 0x37, F, BANKED
376:           						burning_state = START_BURNING; 
18B0  0100     MOVLB 0x0
18B2  0E01     MOVLW 0x1
18B4  6FDD     MOVWF burning_state, BANKED
377:           					break;  
18B6  D05F     BRA 0x1976
378:           					
379:           					case START_BURNING: 	//начальный этап горения (разгон вентилятора)
380:           						if(M_AI_Get_ADC_Data(CHN_T_WATER)->param < M_Mngm_parameters_buffer.menu_parameters.temper_setup - 
18B8  DA04     RCALL __pa_27
381:           							M_Mngm_parameters_buffer.menu_parameters.Fan.delta_temper_for_econom_mode[M_Mngm_parameters_buffer.menu_parameters.fuel_type])
18BA  E209     BC 0x18CE
382:           						{
383:           							if(M_Mngm_accel_fan()) //если вентилятор разогнан
18BC  D887     RCALL M_Mngm_accel_fan
18BE  0900     IORLW 0x0
18C0  E05A     BZ 0x1976
384:           							{
385:           								burning_state = INCREASE_TEMPERATURE;
18C2  0100     MOVLB 0x0
18C4  0E02     MOVLW 0x2
18C6  6FDD     MOVWF burning_state, BANKED
386:           								saved_temperature_water = M_AI_Get_ADC_Data(CHN_T_WATER)->param;
18C8  D9F8     RCALL __pa_26
387:           								M_Mngm_clear_accel_fan();
18CA  D874     RCALL M_Mngm_clear_accel_fan
388:           							}
389:           						}
390:           						else
18CC  D054     BRA 0x1976
391:           						{
392:           							burning_state = ECONOM_MODE;	
18CE  0100     MOVLB 0x0
18D0  0E03     MOVLW 0x3
18D2  6FDD     MOVWF burning_state, BANKED
393:           							M_Mngm_clear_accel_fan();
18D4  D86F     RCALL M_Mngm_clear_accel_fan
394:           							pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.level_fan_in_econom_mode[M_Mngm_parameters_buffer.menu_parameters.fuel_type];
18D6  D97D     RCALL __pa_8
1BD2  010F     MOVLB 0xF
1BD4  5129     MOVF 0x29, W, BANKED
1BD6  0100     MOVLB 0x0
1BD8  6FE8     MOVWF pFanLevel, BANKED
1BDA  6BE9     CLRF 0xE9, BANKED
1BDC  0E22     MOVLW 0x22
1BDE  27E8     ADDWF pFanLevel, F, BANKED
1BE0  0E0F     MOVLW 0xF
1BE2  23E9     ADDWFC 0xE9, F, BANKED
395:           							fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_ECONOM + M_Mngm_parameters_buffer.menu_parameters.fuel_type * 2;
18D8  D9AD     RCALL __pa_13
1BE4  010F     MOVLB 0xF
1BE6  5129     MOVF 0x29, W, BANKED
1BE8  24E8     ADDWF WREG, W, ACCESS
1BEA  0F42     ADDLW 0x42
1BEC  0100     MOVLB 0x0
1BEE  0012     RETURN 0
1C34  6FE7     MOVWF fan_param_offset, BANKED
396:           							M_fan_set_level_fan(*pFanLevel);
18DA  52E5     MOVF POSTDEC1, F, ACCESS
1C36  EF3F     GOTO 0x1C7E
1C38  F00E     NOP
397:           							M_fan_set_ctrl_fan(ON);			//включить алгоритм работы вентилятора
18DC  0E01     MOVLW 0x1
18DE  6EE6     MOVWF POSTINC1, ACCESS
398:           						}
399:           					break;
18E0  D03A     BRA 0x1956
400:           					
401:           					case INCREASE_TEMPERATURE:  //работа на максимальных оборотах вентилятора до перехода в эконом режим, периодическая загрузка топлива
402:           						if(M_AI_Get_ADC_Data(CHN_T_WATER)->param < M_Mngm_parameters_buffer.menu_parameters.temper_setup - 
18E2  D9EF     RCALL __pa_27
403:           							M_Mngm_parameters_buffer.menu_parameters.Fan.delta_temper_for_econom_mode[M_Mngm_parameters_buffer.menu_parameters.fuel_type])
18E4  E205     BC 0x18F0
404:           						{
405:           							M_fan_set_ctrl_fan(ON);			//включить алгоритм работы вентилятора
18E6  0E01     MOVLW 0x1
18E8  D9DC     RCALL __pa_23
406:           							if(timeout_supply_fuel++ >= period_load_fuel)			
18EA  D98B     RCALL __pa_10
18EC  E344     BNC 0x1976
1C02  0100     MOVLB 0x0
1C04  C0DE     MOVFF timeout_supply_fuel, __tmp_0
1C06  F032     NOP
1C08  C0DF     MOVFF 0xDF, 0x33
1C0A  F033     NOP
1C0C  2BDE     INCF timeout_supply_fuel, F, BANKED
1C0E  0E00     MOVLW 0x0
1C10  23DF     ADDWFC 0xDF, F, BANKED
1C12  010F     MOVLB 0xF
1C14  5136     MOVF 0x36, W, BANKED
1C16  5C32     SUBWF __tmp_0, W, ACCESS
1C18  5137     MOVF 0x37, W, BANKED
1C1A  5833     SUBWFB 0x33, W, ACCESS
1C1C  0012     RETURN 0
407:           							{
408:           								timeout_supply_fuel = 0;
409:           								M_Mngm_State = STATE_FUEL_SUPPLY;
410:           								M_Motor_set_work(ON); 		//включить алгоритм засыпки топлива
411:           							}
412:           						}
413:           						else
18EE  D03A     BRA 0x1964
414:           						{
415:           							burning_state = ECONOM_MODE;
18F0  0100     MOVLB 0x0
18F2  0E03     MOVLW 0x3
18F4  6FDD     MOVWF burning_state, BANKED
416:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
18F6  D9A6     RCALL __pa_15
417:           							timeout_supply_fuel = 0;
18F8  0100     MOVLB 0x0
18FA  6BDE     CLRF timeout_supply_fuel, BANKED
18FC  6BDF     CLRF 0xDF, BANKED
418:           							pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.level_fan_in_econom_mode[M_Mngm_parameters_buffer.menu_parameters.fuel_type]; 
18FE  D969     RCALL __pa_8
419:           							fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_ECONOM + M_Mngm_parameters_buffer.menu_parameters.fuel_type * 2;
420:           							M_fan_set_level_fan(*pFanLevel);
421:           						}
422:           					break;
1900  D015     BRA 0x192C
423:           					case ECONOM_MODE:
424:           						if(M_AI_Get_ADC_Data(CHN_T_WATER)->param >= M_Mngm_parameters_buffer.menu_parameters.temper_setup)
1902  D9D7     RCALL __pa_25
1904  010F     MOVLB 0xF
1906  5128     MOVF 0x28, W, BANKED
1908  5C32     SUBWF __tmp_0, W, ACCESS
190A  E305     BNC 0x1916
425:           						{
426:           							burning_state = MAINTENANCE_TEMPERATURE_CYCLE;	
190C  0100     MOVLB 0x0
190E  0E04     MOVLW 0x4
1910  6FDD     MOVWF burning_state, BANKED
427:           							pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.level_fan_in_smoldering[M_Mngm_parameters_buffer.menu_parameters.fuel_type];
1912  D9AB     RCALL __pa_19
1C6A  010F     MOVLB 0xF
1C6C  5129     MOVF 0x29, W, BANKED
1C6E  0100     MOVLB 0x0
1C70  6FE8     MOVWF pFanLevel, BANKED
1C72  6BE9     CLRF 0xE9, BANKED
1C74  0E25     MOVLW 0x25
1C76  27E8     ADDWF pFanLevel, F, BANKED
1C78  0E0F     MOVLW 0xF
1C7A  23E9     ADDWFC 0xE9, F, BANKED
1C7C  0012     RETURN 0
428:           							M_fan_set_ctrl_fan(OFF);
429:           						}
430:           						else if(M_AI_Get_ADC_Data(CHN_T_WATER)->param < M_Mngm_parameters_buffer.menu_parameters.temper_setup - 
1914  D01F     BRA 0x1954
1916  D9D5     RCALL __pa_27
1B9E  CFEF     MOVFF INDF0, __tmp_0
1BA0  F032     NOP
1CC2  DFCA     RCALL __pa_17
1CC4  EFCF     GOTO 0x1B9E
1CC6  F00D     NOP
431:           							M_Mngm_parameters_buffer.menu_parameters.Fan.delta_temper_for_econom_mode[M_Mngm_parameters_buffer.menu_parameters.fuel_type])
1918  E22E     BC 0x1976
1BA2  010F     MOVLB 0xF
1BA4  5129     MOVF 0x29, W, BANKED
1BA6  6AEA     CLRF FSR0H, ACCESS
1BA8  0F1F     ADDLW 0x1F
1BAA  6EE9     MOVWF FSR0, ACCESS
1BAC  0E0F     MOVLW 0xF
1BAE  22EA     ADDWFC FSR0H, F, ACCESS
1BB0  50EF     MOVF INDF0, W, ACCESS
1BB2  5D28     SUBWF 0x28, W, BANKED
1BB4  5C32     SUBWF __tmp_0, W, ACCESS
1BB6  0012     RETURN 0
432:           						{
433:           							burning_state = INCREASE_TEMPERATURE;
191A  0100     MOVLB 0x0
191C  0E02     MOVLW 0x2
191E  6FDD     MOVWF burning_state, BANKED
434:           							timeout_supply_fuel = period_load_fuel;
1920  CF36     MOVFF period_load_fuel, timeout_supply_fuel
1922  F0DE     NOP
1924  CF37     MOVFF 0xF37, 0xDF
1926  F0DF     NOP
435:           							pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.rotational_speed_fan;
1928  D992     RCALL __pa_16
1C4E  0E30     MOVLW 0x30
1C50  6FE8     MOVWF pFanLevel, BANKED
1C52  0E0F     MOVLW 0xF
1C54  6FE9     MOVWF 0xE9, BANKED
1C56  0012     RETURN 0
436:           							fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_INCREASE;
192A  0E5E     MOVLW 0x5E
192C  D983     RCALL __pa_13
437:           							M_fan_set_level_fan(*pFanLevel);
438:           						}	
439:           						
440:           					break;
192E  D022     BRA 0x1974
441:           					case MAINTENANCE_TEMPERATURE_CYCLE:		//продувка топлива
442:           						if(M_Mngm_cyclic_mode())
1930  D8B5     RCALL M_Mngm_cyclic_mode
1932  0900     IORLW 0x0
1934  E020     BZ 0x1976
443:           						{	
444:           							burning_state = MAINTENANCE_TEMPERATURE_INCR;
1936  0100     MOVLB 0x0
1938  0E05     MOVLW 0x5
193A  6FDD     MOVWF burning_state, BANKED
445:           							saved_temperature_water = M_AI_Get_ADC_Data(CHN_T_WATER)->param;
193C  D9BE     RCALL __pa_26
1CBA  DFCE     RCALL __pa_17
1CBC  CFEF     MOVFF INDF0, saved_temperature_water
1CBE  FF00     NOP
1CC0  0012     RETURN 0
446:           						}
447:           					break;
193E  D01B     BRA 0x1976
448:           					
449:           					case MAINTENANCE_TEMPERATURE_INCR:  	//добор температуры после продувки
450:           						if(M_AI_Get_ADC_Data(CHN_T_WATER)->param >= M_Mngm_parameters_buffer.menu_parameters.temper_setup)
1940  D9B8     RCALL __pa_25
1942  010F     MOVLB 0xF
1944  5128     MOVF 0x28, W, BANKED
1946  5C32     SUBWF __tmp_0, W, ACCESS
1948  E309     BNC 0x195C
451:           						{
452:           							burning_state = MAINTENANCE_TEMPERATURE_CYCLE;
194A  0100     MOVLB 0x0
194C  0E04     MOVLW 0x4
194E  6FDD     MOVWF burning_state, BANKED
453:           							timeout_supply_fuel = 0;
1950  6BDE     CLRF timeout_supply_fuel, BANKED
1952  6BDF     CLRF 0xDF, BANKED
454:           							M_fan_set_ctrl_fan(OFF);
1954  6AE6     CLRF POSTINC1, ACCESS
1956  EC5A     CALL 0x2EB4, 0
1958  F017     NOP
455:           						}
456:           						else
195A  D00C     BRA 0x1974
457:           						{
458:           							M_fan_set_ctrl_fan(ON);			//включить алгоритм работы вентилятора
195C  0E01     MOVLW 0x1
195E  D91A     RCALL __pa_3
1B94  D886     RCALL __pa_23
1CA2  6EE6     MOVWF POSTINC1, ACCESS
1CA4  EC5A     CALL 0x2EB4, 0
1CA6  F017     NOP
1CA8  52E5     MOVF POSTDEC1, F, ACCESS
1CAA  0012     RETURN 0
459:           							pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.level_fan_in_smoldering[M_Mngm_parameters_buffer.menu_parameters.fuel_type];
1B96  D869     RCALL __pa_19
460:           							M_fan_set_level_fan(*pFanLevel);
1B98  D872     RCALL __pa_20
1B9A  52E5     MOVF POSTDEC1, F, ACCESS
1B9C  0012     RETURN 0
1C7E  C0E8     MOVFF pFanLevel, FSR0
1C80  FFE9     NOP
1C82  C0E9     MOVFF 0xE9, FSR0H
1C84  FFEA     NOP
1C86  50EF     MOVF INDF0, W, ACCESS
1C88  6EE6     MOVWF POSTINC1, ACCESS
1C8A  EF56     GOTO 0x2EAC
1C8C  F017     NOP
461:           							if(timeout_supply_fuel++ >= period_load_fuel)			
1960  D950     RCALL __pa_10
1962  E309     BNC 0x1976
462:           							{
463:           								timeout_supply_fuel = 0;
1964  0100     MOVLB 0x0
1966  6BDE     CLRF timeout_supply_fuel, BANKED
1968  6BDF     CLRF 0xDF, BANKED
464:           								M_Mngm_State = STATE_FUEL_SUPPLY;
196A  0E01     MOVLW 0x1
196C  6FDA     MOVWF M_Mngm_State, BANKED
465:           								M_Motor_set_work(ON); 		//включить алгоритм засыпки топлива
196E  6EE6     MOVWF POSTINC1, ACCESS
1970  ECC9     CALL 0x192, 0
1972  F000     NOP
1974  52E5     MOVF POSTDEC1, F, ACCESS
466:           							}
467:           						}
468:           					break;
469:           				}
470:           			}
471:           			else
472:           			{
473:           				
474:           			}
475:           		}
476:           	}
477:           }
1976  0E02     MOVLW 0x2
1978  5CE1     SUBWF FSR1, W, ACCESS
197A  E202     BC 0x1980
197C  6AE1     CLRF FSR1, ACCESS
197E  52E5     MOVF POSTDEC1, F, ACCESS
1980  6EE1     MOVWF FSR1, ACCESS
1982  D11E     BRA __pa_6
478:           
479:           /* Режим "Пауза" */
480:           void M_Mngm_pause(void)
481:           {
482:           	if(M_LI_Get_Limit_Switches()->ls_hopper_cover_state) //если закрыта дверь бункера, выйти из состояния паузы
1984  D94C     RCALL __pa_11
1986  E005     BZ 0x1992
483:           	{
484:           		M_Mngm_State = M_Mngm_Previous_State;
1988  C0DC     MOVFF M_Mngm_Previous_State, M_Mngm_State
198A  F0DA     NOP
485:           		M_Ind_Set_state(M_Ind_Get_Previous_State());	
198C  EC9A     CALL 0xD34, 0
198E  F006     NOP
1990  D959     RCALL __pa_15
1C44  6EE6     MOVWF POSTINC1, ACCESS
1C46  ECA1     CALL 0xD42, 0
1C48  F006     NOP
1C4A  52E5     MOVF POSTDEC1, F, ACCESS
1C4C  0012     RETURN 0
486:           	}		
487:           	if (M_Mngm_Code_Failure  != NO_FAILURE)
1992  0100     MOVLB 0x0
1994  51DB     MOVF M_Mngm_Code_Failure, W, BANKED
1996  E001     BZ 0x199A
488:           	{
489:           		M_Mngm_State = STATE_FAILURE;
1998  D8EB     RCALL __pa_1
490:           		DataEEWrite (M_Mngm_Code_Failure, INDEX_OF_CODE_FAILURE );
491:           	}
492:           	else
493:           	{
494:           	
495:           	}
496:           }
199A  0012     RETURN 0
497:           
498:           /*Режим "Очистка дымохода" */
499:           void M_Mngm_clean_chimney(void)
500:           {
501:           	M_Mngm_need_to_pause(STATE_CLEAN_CHIMNEY);	//Проверка необходимости перехода в режим "Пауза"
199C  0E04     MOVLW 0x4
199E  6EE6     MOVWF POSTINC1, ACCESS
19A0  D94C     RCALL __pa_14
1C3A  DDBF     RCALL M_Mngm_need_to_pause
1C3C  52E5     MOVF POSTDEC1, F, ACCESS
502:           	if (M_Mngm_Code_Failure  != NO_FAILURE)
19A2  E001     BZ 0x19A6
1C3E  0100     MOVLB 0x0
1C40  51DB     MOVF M_Mngm_Code_Failure, W, BANKED
1C42  0012     RETURN 0
503:           	{
504:           		M_Mngm_State = STATE_FAILURE;
19A4  D8E5     RCALL __pa_1
1B70  0E05     MOVLW 0x5
1B72  6FDA     MOVWF M_Mngm_State, BANKED
505:           		DataEEWrite (M_Mngm_Code_Failure, INDEX_OF_CODE_FAILURE );
1B74  0E32     MOVLW 0x32
1B76  6EE6     MOVWF POSTINC1, ACCESS
1B78  51DB     MOVF M_Mngm_Code_Failure, W, BANKED
1B7A  6EE6     MOVWF POSTINC1, ACCESS
1B7C  6AE6     CLRF POSTINC1, ACCESS
1B7E  EC41     CALL 0x2A82, 0
1B80  F015     NOP
1B82  52E5     MOVF POSTDEC1, F, ACCESS
1B84  52E5     MOVF POSTDEC1, F, ACCESS
1B86  52E5     MOVF POSTDEC1, F, ACCESS
1B88  0012     RETURN 0
506:           	}
507:           	else
508:           	{
509:           	
510:           	}
511:           }
19A6  0012     RETURN 0
512:           
513:           
514:           void M_Mngm_failure(void)
515:           {
516:           	if (M_Mngm_Code_Failure  == NO_FAILURE)
19A8  0100     MOVLB 0x0
19AA  51DB     MOVF M_Mngm_Code_Failure, W, BANKED
19AC  E102     BNZ 0x19B2
517:           	{
518:           		M_Mngm_State = M_Mngm_Previous_State;
19AE  C0DC     MOVFF M_Mngm_Previous_State, M_Mngm_State
19B0  F0DA     NOP
519:           	}
520:           	else
521:           	{
522:           		
523:           	}
524:           }
19B2  0012     RETURN 0
525:           
526:           /*
527:           Cброс переменных разгона вентилятора
528:           */
529:           void M_Mngm_clear_accel_fan(void)
530:           {
531:           	state_accel_fan = CALCULATE;
19B4  0100     MOVLB 0x0
19B6  6BE5     CLRF state_accel_fan, BANKED
532:           	timeout = 0;
19B8  010F     MOVLB 0xF
19BA  6B38     CLRF 0x38, BANKED
19BC  6B39     CLRF 0x39, BANKED
533:           }
19BE  0012     RETURN 0
534:           
535:           /*
536:           Cброс переменных циклического режима
537:           */
538:           void M_Mngm_clear_cyclic_mode(void)
539:           {
540:           	phase_cycle = PAUSE_IN_CYCLE;;
19C0  0100     MOVLB 0x0
19C2  6BE6     CLRF phase_cycle, BANKED
541:           	timeout = 0;
19C4  010F     MOVLB 0xF
19C6  6B38     CLRF 0x38, BANKED
19C8  6B39     CLRF 0x39, BANKED
542:           }
19CA  0012     RETURN 0
543:           
544:           
545:           /* 
546:           Функция разгона вентилятора от миимального до максимального уровня при начальном разгорании котла
547:           */
548:           BOOL M_Mngm_accel_fan(void)
19CC  D8FD     RCALL __pa_7
19CE  52E6     MOVF POSTINC1, F, ACCESS
549:           {
550:           	uint8_t  num_steps;
551:           	static uint16_t time_step; 
552:           	//static uint8_t level;
553:           		
554:           	switch (state_accel_fan)
19D0  0100     MOVLB 0x0
19D2  51E5     MOVF state_accel_fan, W, BANKED
19D4  0A01     XORLW 0x1
19D6  E038     BZ 0x1A48
19D8  0A01     XORLW 0x1
19DA  E15D     BNZ 0x1A96
555:           	{
556:           		case CALCULATE:		//состояние вычисления параметров
557:           			num_steps = (M_Mngm_parameters_buffer.menu_parameters.Fan.max_turn_percent - 
558:           						M_Mngm_parameters_buffer.menu_parameters.Fan.min_turn_percent) + 1; 	//получаем количество шагов разгона
19DC  010F     MOVLB 0xF
19DE  5111     MOVF 0x11, W, BANKED
19E0  5D12     SUBWF 0x12, W, BANKED
19E2  0F01     ADDLW 0x1
19E4  6EDF     MOVWF INDF2, ACCESS
559:           			//получаем шаг времени для одного уровня вращения вентилятора
560:           			time_step = (uint16_t)M_Mngm_parameters_buffer.menu_parameters.Fan.time_accel_fan
561:           						[M_Mngm_parameters_buffer.menu_parameters.fuel_type] * 100 / num_steps; 	
19E6  50DF     MOVF INDF2, W, ACCESS
19E8  6E34     MOVWF 0x34, ACCESS
19EA  6A35     CLRF 0x35, ACCESS
19EC  5129     MOVF 0x29, W, BANKED
19EE  6AEA     CLRF FSR0H, ACCESS
19F0  0F1C     ADDLW 0x1C
19F2  6EE9     MOVWF FSR0, ACCESS
19F4  0E0F     MOVLW 0xF
19F6  22EA     ADDWFC FSR0H, F, ACCESS
19F8  50EF     MOVF INDF0, W, ACCESS
19FA  0D64     MULLW 0x64
19FC  CFF3     MOVFF PROD, __tmp_0
19FE  F032     NOP
1A00  CFF4     MOVFF PRODH, 0x33
1A02  F033     NOP
1A04  CFF3     MOVFF PROD, 0x26
1A06  F026     NOP
1A08  CFF4     MOVFF PRODH, 0x27
1A0A  F027     NOP
1A0C  C034     MOVFF 0x34, 0x2B
1A0E  F02B     NOP
1A10  C035     MOVFF 0x35, 0x2C
1A12  F02C     NOP
1A14  EC63     CALL 0x36C6, 0
1A16  F01B     NOP
1A18  C026     MOVFF 0x26, 0xF3B
1A1A  FF3B     NOP
1A1C  C027     MOVFF 0x27, 0xF3C
1A1E  FF3C     NOP
562:           			pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.min_turn_percent;
1A20  0100     MOVLB 0x0
1A22  0E11     MOVLW 0x11
1A24  6FE8     MOVWF pFanLevel, BANKED
1A26  0E0F     MOVLW 0xF
1A28  6FE9     MOVWF 0xE9, BANKED
563:           			level = *pFanLevel;
1A2A  C0E8     MOVFF pFanLevel, FSR0
1A2C  FFE9     NOP
1A2E  6EEA     MOVWF FSR0H, ACCESS
1A30  CFEF     MOVFF INDF0, level
1A32  FF3A     NOP
564:           			M_fan_set_level_fan(level);				
1A34  CF3A     MOVFF level, POSTINC1
1A36  FFE6     NOP
1A38  EC56     CALL 0x2EAC, 0
1A3A  F017     NOP
1A3C  52E5     MOVF POSTDEC1, F, ACCESS
565:           			M_fan_set_ctrl_fan(ON);
1A3E  0E01     MOVLW 0x1
1A40  D930     RCALL __pa_23
566:           			state_accel_fan++;	//переход к следующему состоянию автомата
1A42  0100     MOVLB 0x0
1A44  2BE5     INCF state_accel_fan, F, BANKED
567:           			break;
1A46  D027     BRA 0x1A96
568:           		case ROTATE:  //состояние вращения при разгоне
569:           			if(timeout++ == time_step)
1A48  D8D3     RCALL __pa_9
1A4A  513B     MOVF _OS_Temp, W, BANKED
1A4C  1832     XORWF __tmp_0, W, ACCESS
1A4E  E123     BNZ 0x1A96
1A50  513C     MOVF _OS_TempH, W, BANKED
1A52  1833     XORWF 0x33, W, ACCESS
1A54  E120     BNZ 0x1A96
570:           			{
571:           				timeout = 0;	
1A56  6B38     CLRF 0x38, BANKED
1A58  6B39     CLRF 0x39, BANKED
572:           				if(level++ == M_Mngm_parameters_buffer.menu_parameters.Fan.max_turn_percent)
1A5A  513A     MOVF _OS_Flags, W, BANKED
1A5C  2B3A     INCF _OS_Flags, F, BANKED
1A5E  5D12     SUBWF 0x12, W, BANKED
1A60  E110     BNZ 0x1A82
573:           				{	
574:           					state_accel_fan = CALCULATE;
1A62  0100     MOVLB 0x0
1A64  6BE5     CLRF state_accel_fan, BANKED
575:           					pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.rotational_speed_fan;
1A66  D8F3     RCALL __pa_16
576:           					M_fan_set_level_fan(*pFanLevel);	
1A68  C0E8     MOVFF pFanLevel, FSR0
1A6A  FFE9     NOP
1A6C  6EEA     MOVWF FSR0H, ACCESS
1A6E  50EF     MOVF INDF0, W, ACCESS
1A70  6EE6     MOVWF POSTINC1, ACCESS
1A72  EC56     CALL 0x2EAC, 0
1A74  F017     NOP
1A76  52E5     MOVF POSTDEC1, F, ACCESS
577:           					fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_INCREASE;
1A78  0100     MOVLB 0x0
1A7A  0E5E     MOVLW 0x5E
1A7C  6FE7     MOVWF fan_param_offset, BANKED
578:           					return  FAN_IS_ACCEL; 
1A7E  0E01     MOVLW 0x1
1A80  D00B     BRA 0x1A98
579:           				}
580:           				else
581:           				{
582:           					pFanLevel = &level;
1A82  0100     MOVLB 0x0
1A84  0E3A     MOVLW 0x3A
1A86  6FE8     MOVWF pFanLevel, BANKED
1A88  0E0F     MOVLW 0xF
1A8A  6FE9     MOVWF 0xE9, BANKED
583:           					M_fan_set_level_fan(level);	
1A8C  CF3A     MOVFF level, POSTINC1
1A8E  FFE6     NOP
1A90  EC56     CALL 0x2EAC, 0
1A92  F017     NOP
1A94  52E5     MOVF POSTDEC1, F, ACCESS
584:           				}
585:           			}	
586:           			break;
587:           	}
588:           	return FAN_NOT_ACCEL;
1A96  0E00     MOVLW 0x0
589:           }
1A98  52E5     MOVF POSTDEC1, F, ACCESS
1A9A  D092     BRA __pa_6
1BC0  52E5     MOVF POSTDEC1, F, ACCESS
1BC2  CFE7     MOVFF INDF1, FSR2
1BC4  FFD9     NOP
1BC6  0012     RETURN 0
590:           
591:           
592:           
593:           /*
594:           Функция работы вентилятора в циклическом режиме работа-пауза в режиме тления топлива алгоритма горения
595:           Возвращает 1 - если температура упала и нужно возвращаться в режим загрузки топлива для увеличения температуры
596:           0 - продолжаем оставаться в этом режиме
597:           */
598:           BOOL M_Mngm_cyclic_mode(void)
599:           {
600:           	if(M_AI_Get_ADC_Data(CHN_T_WATER)->param <= M_Mngm_parameters_buffer.menu_parameters.temper_setup - 
1A9C  D90A     RCALL __pa_25
1B5E  EC8C     CALL 0x2318, 0
1B60  F011     NOP
1B62  52E5     MOVF POSTDEC1, F, ACCESS
1B64  D899     RCALL __pa_22
1B66  0E05     MOVLW 0x5
1B68  26E9     ADDWF FSR0, F, ACCESS
1B6A  0E00     MOVLW 0x0
1B6C  22EA     ADDWFC FSR0H, F, ACCESS
1B6E  0012     RETURN 0
1C58  0E01     MOVLW 0x1
1C5A  6EE6     MOVWF POSTINC1, ACCESS
1C5C  EFAF     GOTO 0x1B5E
1C5E  F00D     NOP
1CB2  DFD2     RCALL __pa_17
1CB4  CFEF     MOVFF INDF0, __tmp_0
1CB6  F032     NOP
1CB8  0012     RETURN 0
601:           	M_Mngm_parameters_buffer.menu_parameters.Fan.delta_from_cycle_to_heat[M_Mngm_parameters_buffer.menu_parameters.fuel_type])
1A9E  010F     MOVLB 0xF
1AA0  5129     MOVF 0x29, W, BANKED
1AA2  6AEA     CLRF FSR0H, ACCESS
1AA4  0F19     ADDLW 0x19
1AA6  6EE9     MOVWF FSR0, ACCESS
1AA8  0E0F     MOVLW 0xF
1AAA  22EA     ADDWFC FSR0H, F, ACCESS
1AAC  50EF     MOVF INDF0, W, ACCESS
1AAE  5D28     SUBWF 0x28, W, BANKED
1AB0  80D8     BSF STATUS, 0, ACCESS
1AB2  5432     SUBFWB __tmp_0, W, ACCESS
1AB4  E30A     BNC 0x1ACA
602:           	{
603:           		phase_cycle = PAUSE_IN_CYCLE;
1AB6  0100     MOVLB 0x0
1AB8  6BE6     CLRF phase_cycle, BANKED
604:           		timeout_supply_fuel = period_load_fuel; //переход в другой режим начнётся с подкидывания топлива
1ABA  CF36     MOVFF period_load_fuel, timeout_supply_fuel
1ABC  F0DE     NOP
1ABE  CF37     MOVFF 0xF37, 0xDF
1AC0  F0DF     NOP
605:           		timeout = 0;
1AC2  010F     MOVLB 0xF
1AC4  6B38     CLRF 0x38, BANKED
1AC6  6B39     CLRF 0x39, BANKED
606:           		return TRUE; //температура упала до значения не более установленной минус 2oC 
1AC8  0C01     RETLW 0x1
607:           	}
608:           	else
609:           	{
610:           		switch (phase_cycle)
1ACA  0100     MOVLB 0x0
1ACC  51E6     MOVF phase_cycle, W, BANKED
1ACE  0A01     XORLW 0x1
1AD0  E02D     BZ 0x1B2C
1AD2  0A01     XORLW 0x1
1AD4  E143     BNZ 0x1B5C
611:           		{
612:           			case PAUSE_IN_CYCLE: //отсчёт времени паузы вентилятора в подрежиме тления топлива	
613:           				if( timeout++ == ( uint16_t ) M_Mngm_parameters_buffer.menu_parameters.Fan.time_pause_in_cycle
1AD6  D88C     RCALL __pa_9
614:           										[ M_Mngm_parameters_buffer.menu_parameters.fuel_type ]*1000)
1AD8  5129     MOVF 0x29, W, BANKED
1ADA  6AEA     CLRF FSR0H, ACCESS
1ADC  0F16     ADDLW 0x16
1ADE  6EE9     MOVWF FSR0, ACCESS
1AE0  0E0F     MOVLW 0xF
1AE2  22EA     ADDWFC FSR0H, F, ACCESS
1AE4  50EF     MOVF INDF0, W, ACCESS
1AE6  6E34     MOVWF 0x34, ACCESS
1AE8  6A35     CLRF 0x35, ACCESS
1AEA  0EE8     MOVLW 0xE8
1AEC  0235     MULWF 0x35, ACCESS
1AEE  CFF3     MOVFF PROD, 0x35
1AF0  F035     NOP
1AF2  0E03     MOVLW 0x3
1AF4  0234     MULWF 0x34, ACCESS
1AF6  50F3     MOVF PROD, W, ACCESS
1AF8  2635     ADDWF 0x35, F, ACCESS
1AFA  0EE8     MOVLW 0xE8
1AFC  0234     MULWF 0x34, ACCESS
1AFE  CFF3     MOVFF PROD, 0x34
1B00  F034     NOP
1B02  50F4     MOVF PRODH, W, ACCESS
1B04  2635     ADDWF 0x35, F, ACCESS
1B06  50F3     MOVF PROD, W, ACCESS
1B08  1832     XORWF __tmp_0, W, ACCESS
1B0A  E128     BNZ 0x1B5C
1B0C  5035     MOVF 0x35, W, ACCESS
1B0E  1833     XORWF 0x33, W, ACCESS
1B10  E125     BNZ 0x1B5C
615:           				{
616:           					timeout = 0;
1B12  6B38     CLRF 0x38, BANKED
1B14  6B39     CLRF 0x39, BANKED
617:           					phase_cycle = WORK_IN_CYCLE;
1B16  0100     MOVLB 0x0
1B18  0E01     MOVLW 0x1
1B1A  6FE6     MOVWF phase_cycle, BANKED
618:           					M_fan_set_ctrl_fan(ON);
1B1C  D83B     RCALL __pa_3
619:           					pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.level_fan_in_smoldering
620:           										[M_Mngm_parameters_buffer.menu_parameters.fuel_type];
621:           					M_fan_set_level_fan(*pFanLevel);
622:           					fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_SMOLDERING + M_Mngm_parameters_buffer.menu_parameters.fuel_type * 2;
1B1E  010F     MOVLB 0xF
1B20  5129     MOVF 0x29, W, BANKED
1B22  24E8     ADDWF WREG, W, ACCESS
1B24  0F48     ADDLW 0x48
1B26  0100     MOVLB 0x0
1B28  6FE7     MOVWF fan_param_offset, BANKED
623:           				}
624:           			break;
1B2A  0C00     RETLW 0x0
625:           			case WORK_IN_CYCLE:	//отсчёт времени работы вентилятора в подрежиме тления топлива
626:           				if( timeout++ == ( uint16_t ) M_Mngm_parameters_buffer.menu_parameters.Fan.time_work_in_cycle
1B2C  D861     RCALL __pa_9
1BF0  010F     MOVLB 0xF
1BF2  CF38     MOVFF timeout, __tmp_0
1BF4  F032     NOP
1BF6  CF39     MOVFF 0xF39, 0x33
1BF8  F033     NOP
1BFA  2B38     INCF 0x38, F, BANKED
1BFC  0E00     MOVLW 0x0
1BFE  2339     ADDWFC 0x39, F, BANKED
1C00  0012     RETURN 0
627:           										[ M_Mngm_parameters_buffer.menu_parameters.fuel_type ]*10 )
1B2E  5129     MOVF 0x29, W, BANKED
1B30  6AEA     CLRF FSR0H, ACCESS
1B32  0F13     ADDLW 0x13
1B34  6EE9     MOVWF FSR0, ACCESS
1B36  0E0F     MOVLW 0xF
1B38  22EA     ADDWFC FSR0H, F, ACCESS
1B3A  50EF     MOVF INDF0, W, ACCESS
1B3C  0D0A     MULLW 0xA
1B3E  CFF3     MOVFF PROD, 0x34
1B40  F034     NOP
1B42  CFF4     MOVFF PRODH, 0x35
1B44  F035     NOP
1B46  50F3     MOVF PROD, W, ACCESS
1B48  1832     XORWF __tmp_0, W, ACCESS
1B4A  E108     BNZ 0x1B5C
1B4C  5035     MOVF 0x35, W, ACCESS
1B4E  1833     XORWF 0x33, W, ACCESS
1B50  E105     BNZ 0x1B5C
628:           				{
629:           					timeout = 0;
1B52  6B38     CLRF 0x38, BANKED
1B54  6B39     CLRF 0x39, BANKED
630:           					phase_cycle = PAUSE_IN_CYCLE;
1B56  0100     MOVLB 0x0
1B58  6BE6     CLRF phase_cycle, BANKED
631:           					M_fan_set_ctrl_fan(OFF);
1B5A  D867     RCALL __pa_12
1C2A  6AE6     CLRF POSTINC1, ACCESS
1C2C  EC5A     CALL 0x2EB4, 0
1C2E  F017     NOP
1C30  52E5     MOVF POSTDEC1, F, ACCESS
1C32  0012     RETURN 0
632:           				}	
633:           			break;
634:           		}
635:           		return FALSE;
636:           	}
637:           }
1B5C  0C00     RETLW 0x0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_logic_inputs/module_logic_inputs.c  -------
1:             #include "module_logic_inputs.h"
2:             #include "module_management.h"
3:             #include "module_sound.h"
4:             #include "menu.h"
5:             #include <p18cxxx.h>
6:             
7:             
8:             /*Определения*/
9:             //Ножки портов в/в концевиков(через указатели не выходит, делаем говнокодом)
10:            #define LS_DISPENSER_START_PIN 		 PORTBbits.RB5       //дозатор(стартовый)
11:            #define LS_DISPENSER_START_TRIS		 TRISBbits.TRISB5
12:            #define LS_DISPENSER_FINISH_PIN		 PORTJbits.RJ7       //дозатор(финишный)
13:            #define LS_DISPENSER_FINISH_TRIS     TRISJbits.TRISJ7
14:            #define LS_SHATTER_START_PIN		 PORTCbits.RC0       //заслонка(стартовый)
15:            #define LS_SHATTER_START_TRIS		 TRISCbits.TRISC0       
16:            #define LS_SHATTER_FINISH_PIN		 PORTJbits.RJ4       //заслонка(финишный)
17:            #define LS_SHATTER_FINISH_TRIS		 TRISJbits.TRISJ4
18:            #define LS_HOPPER_COVER_PIN			 PORTBbits.RB4       //крышка
19:            #define LS_HOPPER_COVER_TRIS		 TRISBbits.TRISB4
20:            #define LS_AGITATOR_PIN				 PORTBbits.RB1       //ворошитель
21:            #define LS_AGITATOR_TRIS			 TRISBbits.TRISB1 
22:            #define LS_SHATTER_AFTER_FINISH_PIN	 PORTJbits.RJ6       //заслонка(после финишного)
23:            #define LS_SHATTER_AFTER_FINISH_TRIS TRISJbits.TRISJ6
24:            
25:            #ifdef ENABLE_ASH_CLEANER_INDUCTIVE_SENSORS
26:                #define LS_CLEAN_ASH_START_PIN       PORTCbits.RC1       //чистка золы (стартовый)
27:                #define LS_CLEAN_ASH_START_TRIS      TRISCbits.TRISC1   
28:                #define LS_CLEAN_ASH_FINISH_PIN      PORTCbits.RC2       //чистка золы (финишный)
29:                #define LS_CLEAN_ASH_FINISH_TRIS     TRISCbits.TRISC2
30:            #else
31:                #define SENSOR_OVERHEAT_PIN       PORTCbits.RC1       //чистка золы (стартовый)
32:                #define SENSOR_OVERHEAT_TRIS      TRISCbits.TRISC1
33:            #endif
34:            
35:            #define KEY_INC_TRIS                 TRISJbits.TRISJ3
36:            #define KEY_DEC_TRIS                 TRISBbits.TRISB0   
37:            #define KEY_MENU_TRIS                TRISJbits.TRISJ2
38:            #define KEY_ESC_TRIS                 TRISJbits.TRISJ1
39:            
40:            #define LS_IS_WORKED_TO_NC              1
41:            #define LS_IS_WORKED_TO_NO              0
42:            
43:            
44:            #define NO_KEY_PRESSED_ON_PORTJ         0b00001110U
45:            #define NO_KEY_PRESSED_ON_PORTB         0b00000001U
46:            #define THRESHOLD_LONG_PRESSED          5000U
47:            #define THRESHOLD_ACCUMULATION          10U
48:            
49:            
50:            //Разрешение внутренних подтягивающих резисторов на PORTB, PORTJ
51:            #define PULLUPS_ENABLE \
52:            {                       \
53:                INTCON2bits.RBPU = 0; \
54:            	PORTGbits.RJPU = 1; \
55:            }
56:            
57:            //Запрет внутренних подтягивающих резисторов на PORTB, PORTJ
58:            #define PULLUPS_DISABLE \
59:            {                       \
60:                INTCON2bits.RBPU = 1; \
61:            	PORTGbits.RJPU = 0; \
62:            }
63:            
64:            
65:            KeyState M_LI_Key_State = {0, 0, 0};
66:            
67:            LimitSwitch M_LI_Limit_Sw = {0};
68:            BOOL* ptr_to_ls = &(M_LI_Limit_Sw.ls_shatter_after_finish_state);
69:            
70:            //Функция инициализации модуля обработки логических входов
71:            void M_LI_ctor( void )
72:            {
73:            
74:                LS_DISPENSER_START_TRIS	     = IN;
2674  8A93     BSF TRISB, 5, ACCESS
75:                LS_DISPENSER_FINISH_TRIS     = IN;
2676  8E9A     BSF TRISJ, 7, ACCESS
76:                LS_SHATTER_START_TRIS		 = IN; 
2678  8094     BSF TRISC, 0, ACCESS
77:                LS_SHATTER_FINISH_TRIS		 = IN; 
267A  889A     BSF TRISJ, 4, ACCESS
78:                LS_HOPPER_COVER_TRIS		 = IN; 
267C  8893     BSF TRISB, 4, ACCESS
79:                LS_AGITATOR_TRIS			 = IN; 
267E  8293     BSF TRISB, 1, ACCESS
80:                LS_SHATTER_AFTER_FINISH_TRIS = IN;
2680  8C9A     BSF TRISJ, 6, ACCESS
81:                
82:                #ifdef ENABLE_ASH_CLEANER_INDUCTIVE_SENSORS
83:                    LS_CLEAN_ASH_START_TRIS      = IN;
84:                    LS_CLEAN_ASH_FINISH_TRIS     = IN;
85:                #else
86:                    SENSOR_OVERHEAT_TRIS = IN;  //чистка золы (стартовый)
2682  8294     BSF TRISC, 1, ACCESS
87:                #endif 
88:                KEY_INC_TRIS  = IN;
2684  869A     BSF TRISJ, 3, ACCESS
89:                KEY_DEC_TRIS  = IN;
2686  8093     BSF TRISB, 0, ACCESS
90:                KEY_MENU_TRIS = IN;
2688  849A     BSF TRISJ, 2, ACCESS
91:                KEY_ESC_TRIS  = IN;
268A  829A     BSF TRISJ, 1, ACCESS
92:            }
268C  0012     RETURN 0
93:            
94:            BOOL* M_LI_get_ptr_to_ls(void)
95:            {
96:            	return ptr_to_ls;
268E  C0F5     MOVFF ptr_to_ls, PROD
2690  FFF3     NOP
2692  C0F6     MOVFF 0xF6, PRODH
2694  FFF4     NOP
97:            }
2696  0012     RETURN 0
98:            
99:            void M_LI_set_ptr_to_ls(BOOL* ls)
2698  D8DA     RCALL __pa_3
100:           {
101:           	ptr_to_ls = ls;
269A  0EFD     MOVLW 0xFD
269C  CFDB     MOVFF PLUSW2, ptr_to_ls
269E  F0F5     NOP
26A0  0EFE     MOVLW 0xFE
26A2  CFDB     MOVFF PLUSW2, 0xF6
26A4  F0F6     NOP
102:           }
26A6  D0CF     BRA __pa_2
103:           
104:           LimitSwitch* M_LI_Get_Limit_Switches(void)
105:           {
106:           	return &M_LI_Limit_Sw;
26A8  0EED     MOVLW 0xED
26AA  6E32     MOVWF __tmp_0, ACCESS
26AC  0E00     MOVLW 0x0
26AE  C032     MOVFF __tmp_0, PROD
26B0  FFF3     NOP
26B2  6EF4     MOVWF PRODH, ACCESS
107:           }
26B4  0012     RETURN 0
108:           
109:           KeyState* M_LI_Get_Key_State(void) 
110:           {
111:           	return &M_LI_Key_State;
26B6  0EEA     MOVLW 0xEA
26B8  6E32     MOVWF __tmp_0, ACCESS
26BA  0E00     MOVLW 0x0
26BC  C032     MOVFF __tmp_0, PROD
26BE  FFF3     NOP
26C0  6EF4     MOVWF PRODH, ACCESS
112:           }
26C2  0012     RETURN 0
113:           
114:           
115:           BOOL M_LI_is_LS_worked(uint8_t ls_pin, BOOL ls_direction) 
26C4  D8C4     RCALL __pa_3
284E  CFD9     MOVFF FSR2, POSTINC1
2850  FFE6     NOP
2852  CFE1     MOVFF FSR1, FSR2
2854  FFD9     NOP
2856  0012     RETURN 0
116:           {
117:           	return ls_pin ^ ls_direction;
26C6  0EFD     MOVLW 0xFD
26C8  CFDB     MOVFF PLUSW2, POSTINC1
26CA  FFE6     NOP
26CC  0EFE     MOVLW 0xFE
26CE  50DB     MOVF PLUSW2, W, ACCESS
26D0  52E5     MOVF POSTDEC1, F, ACCESS
26D2  18E7     XORWF INDF1, W, ACCESS
118:           }
26D4  D0B8     BRA __pa_2
119:           
120:           //Опрос концевиков (или индуктивных датчиков)
121:           void M_LI_ls_question(void)
122:           {
123:           	#ifdef  ENABLE_PULLUPS_ON_PORTB_AND_PORTJ
124:                   PULLUPS_ENABLE;
26D6  9EF1     BCF INTCON2, 7, ACCESS
26D8  8A86     BSF PORTG, 5, ACCESS
125:               #endif
126:               M_LI_Limit_Sw.ls_dispenser_start_state =      M_LI_is_LS_worked(LS_DISPENSER_START_PIN, LS_IS_WORKED_TO_NC);  
26DA  0E01     MOVLW 0x1
26DC  6EE6     MOVWF POSTINC1, ACCESS
26DE  5081     MOVF PORTB, W, ACCESS
26E0  0B20     ANDLW 0x20
26E2  E001     BZ 0x26E6
26E4  0E01     MOVLW 0x1
26E6  D8A2     RCALL __pa_0
26E8  0100     MOVLB 0x0
26EA  6FED     MOVWF M_LI_Limit_Sw, BANKED
127:           	M_LI_Limit_Sw.ls_dispenser_finish_state =     M_LI_is_LS_worked(LS_DISPENSER_FINISH_PIN, LS_IS_WORKED_TO_NC);
26EC  0E01     MOVLW 0x1
26EE  6EE6     MOVWF POSTINC1, ACCESS
26F0  5088     MOVF PORTJ, W, ACCESS
26F2  0B80     ANDLW 0x80
26F4  E001     BZ 0x26F8
26F6  0E01     MOVLW 0x1
26F8  D899     RCALL __pa_0
26FA  0100     MOVLB 0x0
26FC  6FEE     MOVWF 0xEE, BANKED
128:           	M_LI_Limit_Sw.ls_shatter_start_state =        M_LI_is_LS_worked(LS_SHATTER_START_PIN, LS_IS_WORKED_TO_NC);  
26FE  0E01     MOVLW 0x1
2700  6EE6     MOVWF POSTINC1, ACCESS
2702  5082     MOVF PORTC, W, ACCESS
2704  0B01     ANDLW 0x1
2706  D892     RCALL __pa_0
2708  0100     MOVLB 0x0
270A  6FEF     MOVWF 0xEF, BANKED
129:           	M_LI_Limit_Sw.ls_shatter_finish_state =       M_LI_is_LS_worked(LS_SHATTER_FINISH_PIN, LS_IS_WORKED_TO_NC);
270C  0E01     MOVLW 0x1
270E  6EE6     MOVWF POSTINC1, ACCESS
2710  5088     MOVF PORTJ, W, ACCESS
2712  0B10     ANDLW 0x10
2714  E001     BZ 0x2718
2716  0E01     MOVLW 0x1
2718  D889     RCALL __pa_0
271A  0100     MOVLB 0x0
271C  6FF0     MOVWF 0xF0, BANKED
130:           	M_LI_Limit_Sw.ls_agitator_state =             M_LI_is_LS_worked(LS_AGITATOR_PIN, LS_IS_WORKED_TO_NC);  
271E  0E01     MOVLW 0x1
2720  6EE6     MOVWF POSTINC1, ACCESS
2722  5081     MOVF PORTB, W, ACCESS
2724  0B02     ANDLW 0x2
2726  E001     BZ 0x272A
2728  0E01     MOVLW 0x1
272A  D880     RCALL __pa_0
272C  0100     MOVLB 0x0
272E  6FF2     MOVWF 0xF2, BANKED
131:           	M_LI_Limit_Sw.ls_hopper_cover_state =         M_LI_is_LS_worked(LS_HOPPER_COVER_PIN, LS_IS_WORKED_TO_NC);
2730  0E01     MOVLW 0x1
2732  6EE6     MOVWF POSTINC1, ACCESS
2734  5081     MOVF PORTB, W, ACCESS
2736  0B10     ANDLW 0x10
2738  E001     BZ 0x273C
273A  0E01     MOVLW 0x1
273C  D877     RCALL __pa_0
273E  0100     MOVLB 0x0
2740  6FF3     MOVWF 0xF3, BANKED
132:           	//M_LI_Limit_Sw.ls_hopper_cover_state = 1;  //!!!for debug
133:               M_LI_Limit_Sw.ls_shatter_after_finish_state = M_LI_is_LS_worked(LS_SHATTER_AFTER_FINISH_PIN, LS_IS_WORKED_TO_NC);
2742  0E01     MOVLW 0x1
2744  6EE6     MOVWF POSTINC1, ACCESS
2746  5088     MOVF PORTJ, W, ACCESS
2748  0B40     ANDLW 0x40
274A  E001     BZ 0x274E
274C  0E01     MOVLW 0x1
274E  D86E     RCALL __pa_0
2750  0100     MOVLB 0x0
2752  6FF1     MOVWF 0xF1, BANKED
134:               #ifdef  ENABLE_PULLUPS_ON_PORTB_AND_PORTJ
135:                   PULLUPS_DISABLE;
2754  8EF1     BSF INTCON2, 7, ACCESS
2756  9A86     BCF PORTG, 5, ACCESS
136:               #endif
137:               #ifdef ENABLE_ASH_CLEANER_INDUCTIVE_SENSORS
138:                   M_LI_Limit_Sw.ls_clean_ash_start_state =      M_LI_is_LS_worked(LS_CLEAN_ASH_START_PIN, LS_IS_WORKED_TO_NC);
139:                   M_LI_Limit_Sw.ls_clean_ash_finish_state =     M_LI_is_LS_worked(LS_CLEAN_ASH_FINISH_PIN, LS_IS_WORKED_TO_NC);
140:               #else
141:                   M_LI_Limit_Sw.overheat =  M_LI_is_LS_worked(SENSOR_OVERHEAT_PIN, LS_IS_WORKED_TO_NC);
2758  0E01     MOVLW 0x1
275A  6EE6     MOVWF POSTINC1, ACCESS
275C  5082     MOVF PORTC, W, ACCESS
275E  0B02     ANDLW 0x2
2760  E001     BZ 0x2764
2762  0E01     MOVLW 0x1
2764  D863     RCALL __pa_0
2766  0100     MOVLB 0x0
2768  6FF4     MOVWF 0xF4, BANKED
282C  6EE6     MOVWF POSTINC1, ACCESS
282E  DF4A     RCALL M_LI_is_LS_worked
2830  52E5     MOVF POSTDEC1, F, ACCESS
2832  52E5     MOVF POSTDEC1, F, ACCESS
2834  0012     RETURN 0
142:               #endif     
143:           }
276A  0012     RETURN 0
144:           
145:           //Опров кнопок
146:           void M_LI_Key_Question(void)
276C  D870     RCALL __pa_3
276E  0E02     MOVLW 0x2
2770  26E1     ADDWF FSR1, F, ACCESS
147:           {
148:           	uint8_t temp_PORTB, temp_PORTJ;
149:           	static uint16_t M_LI_accum_pressed = 0;
150:           	
151:           	#ifdef  ENABLE_PULLUPS_ON_PORTB_AND_PORTJ
152:                   PULLUPS_ENABLE;
2772  9EF1     BCF INTCON2, 7, ACCESS
2774  8A86     BSF PORTG, 5, ACCESS
153:               #endif
154:           	temp_PORTB = PORTB & NO_KEY_PRESSED_ON_PORTB;
2776  0E01     MOVLW 0x1
2778  1481     ANDWF PORTB, W, ACCESS
277A  6EDF     MOVWF INDF2, ACCESS
155:           	temp_PORTJ = PORTJ & NO_KEY_PRESSED_ON_PORTJ;
277C  0E0E     MOVLW 0xE
277E  1488     ANDWF PORTJ, W, ACCESS
2780  6EE7     MOVWF INDF1, ACCESS
2782  0E01     MOVLW 0x1
2784  CFE7     MOVFF INDF1, PLUSW2
2786  FFDB     NOP
156:           	#ifdef  ENABLE_PULLUPS_ON_PORTB_AND_PORTJ
157:                   PULLUPS_DISABLE;
2788  8EF1     BSF INTCON2, 7, ACCESS
278A  9A86     BCF PORTG, 5, ACCESS
158:               #endif
159:               
160:               temp_PORTB += temp_PORTJ; 	//упаковка в temp_PORTB прочитанных кнопок (биты 3,2,1,0)
278C  50DB     MOVF PLUSW2, W, ACCESS
278E  26DF     ADDWF INDF2, F, ACCESS
161:           	temp_PORTB <<= 1; 
2790  9EDF     BCF INDF2, 7, ACCESS
2792  46DF     RLNCF INDF2, F, ACCESS
162:           	if(!M_LI_Key_State.Any_Key_pressed) //если никакая кнопка не была нажата ранее
2794  0100     MOVLB 0x0
2796  51EA     MOVF M_LI_Key_State, W, BANKED
2798  E111     BNZ 0x27BC
163:           	{
164:           		if (temp_PORTB != NO_KEY_PRESSED)   //какая-либо кнопка нажата
279A  0E1E     MOVLW 0x1E
279C  5CDF     SUBWF INDF2, W, ACCESS
279E  E030     BZ 0x2800
165:           		{
166:           			if(M_LI_accum_pressed++ == THRESHOLD_ACCUMULATION) //накоплен порог нажатия на кнопку
27A0  D84A     RCALL __pa_1
27A2  0E0A     MOVLW 0xA
27A4  1832     XORWF __tmp_0, W, ACCESS
27A6  E12C     BNZ 0x2800
27A8  5033     MOVF 0x33, W, ACCESS
27AA  E12A     BNZ 0x2800
2836  C0F7     MOVFF 0xF7, __tmp_0
2838  F032     NOP
283A  C0F8     MOVFF 0xF8, 0x33
283C  F033     NOP
283E  2BF7     INCF 0xF7, F, BANKED
2840  0E00     MOVLW 0x0
2842  23F8     ADDWFC 0xF8, F, BANKED
2844  0012     RETURN 0
167:           			{
168:           				
169:           				M_LI_Key_State.M_LI_Code_Key = temp_PORTB; 
27AC  CFDF     MOVFF INDF2, 0xEC
27AE  F0EC     NOP
170:           				M_LI_Key_State.Any_Key_pressed = ON;	
27B0  0E01     MOVLW 0x1
27B2  6FEA     MOVWF M_LI_Key_State, BANKED
171:           				M_LI_Key_State.Long_pressed = ON; //установить флаг длительного нажатия
27B4  6FEB     MOVWF 0xEB, BANKED
172:           				M_LI_accum_pressed = 0; 
27B6  6BF7     CLRF 0xF7, BANKED
27B8  6BF8     CLRF 0xF8, BANKED
173:           				M_Sound_set_button_submergence (ON);  //установить флаг подзвучки кнопки
174:           			}
175:           		}
176:           	}
177:           	else 
27BA  D01E     BRA 0x27F8
178:           	{
179:           			if (temp_PORTB == NO_KEY_PRESSED) //кнопка нажата и отпущена (короткое нажатие)
27BC  0E1E     MOVLW 0x1E
27BE  5CDF     SUBWF INDF2, W, ACCESS
27C0  E10B     BNZ 0x27D8
180:           			{
181:           				if(M_LI_Key_State.Long_pressed)
27C2  51EB     MOVF 0xEB, W, BANKED
27C4  E004     BZ 0x27CE
182:           				{	
183:           					M_LI_Key_State.M_LI_Code_Key &= 0x7E;
27C6  0E7E     MOVLW 0x7E
27C8  17EC     ANDWF 0xEC, F, BANKED
184:           					M_LI_Key_State.M_LI_Code_Key += 0x80;  //маркер того, что кнопка нажата и отпущена
27CA  0E80     MOVLW 0x80
27CC  27EC     ADDWF 0xEC, F, BANKED
185:           				}
186:           				M_LI_Key_State.Any_Key_pressed = FALSE;	
27CE  6BEA     CLRF M_LI_Key_State, BANKED
187:           				M_LI_accum_pressed = 0;
27D0  6BF7     CLRF 0xF7, BANKED
27D2  6BF8     CLRF 0xF8, BANKED
188:           				M_LI_Key_State.Long_pressed = FALSE;
27D4  6BEB     CLRF 0xEB, BANKED
189:           			}
190:           			else //если кнопка нажата и не была отпущена при коротком нажатии/отпускании 
27D6  D014     BRA 0x2800
191:           			{
192:           				if(M_LI_Key_State.Long_pressed)
27D8  51EB     MOVF 0xEB, W, BANKED
27DA  E012     BZ 0x2800
193:           				{
194:           					if(M_LI_accum_pressed++ >= THRESHOLD_LONG_PRESSED) // прошло время длительного нажатия CountLongPressed 
27DC  D82C     RCALL __pa_1
27DE  0E88     MOVLW 0x88
27E0  5C32     SUBWF __tmp_0, W, ACCESS
27E2  0E13     MOVLW 0x13
27E4  5833     SUBWFB 0x33, W, ACCESS
27E6  E30C     BNC 0x2800
195:           					{
196:           						M_LI_accum_pressed = 0;
27E8  6BF7     CLRF 0xF7, BANKED
27EA  6BF8     CLRF 0xF8, BANKED
197:           						M_LI_Key_State.Long_pressed = FALSE;
27EC  6BEB     CLRF 0xEB, BANKED
198:           						M_LI_Key_State.M_LI_Code_Key &= 0x7E;
27EE  0E7E     MOVLW 0x7E
27F0  17EC     ANDWF 0xEC, F, BANKED
199:           						M_LI_Key_State.M_LI_Code_Key += 0x01;
27F2  2BEC     INCF 0xEC, F, BANKED
200:           						M_LI_Key_State.Any_Key_pressed = TRUE;	
27F4  0E01     MOVLW 0x1
27F6  6FEA     MOVWF M_LI_Key_State, BANKED
201:           						M_Sound_set_button_submergence (ON);  //установить флаг подзвучки кнопки
27F8  6EE6     MOVWF POSTINC1, ACCESS
27FA  EC93     CALL 0x3126, 0
27FC  F018     NOP
27FE  52E5     MOVF POSTDEC1, F, ACCESS
202:           					}
203:           				}
204:           			}
205:           	}
206:           }
2800  0E02     MOVLW 0x2
2802  5CE1     SUBWF FSR1, W, ACCESS
2804  E202     BC 0x280A
2806  6AE1     CLRF FSR1, ACCESS
2808  52E5     MOVF POSTDEC1, F, ACCESS
280A  6EE1     MOVWF FSR1, ACCESS
280C  D01C     BRA __pa_2
2846  52E5     MOVF POSTDEC1, F, ACCESS
2848  CFE7     MOVFF INDF1, FSR2
284A  FFD9     NOP
284C  0012     RETURN 0
207:           
208:           void M_LI_Run(void)
209:           {
210:           		
211:           	//Опрос кнопок (не опрашивать в режиме "Пауза")
212:           	if(M_Mngm_Get_state() != STATE_PAUSE)
280E  EC0C     CALL 0x1618, 0
2810  F00B     NOP
2812  0803     SUBLW 0x3
2814  E009     BZ 0x2828
213:           	{
214:           		//Опрос кнопок
215:                   M_LI_Key_Question();
2816  DFAA     RCALL M_LI_Key_Question
216:           		
217:           		//Отработка кнопок
218:           		Menu_Key_handler(&M_LI_Key_State);	
2818  0EEA     MOVLW 0xEA
281A  6EE6     MOVWF POSTINC1, ACCESS
281C  0E00     MOVLW 0x0
281E  6EE6     MOVWF POSTINC1, ACCESS
2820  ECD5     CALL 0x1DAA, 0
2822  F00E     NOP
2824  52E5     MOVF POSTDEC1, F, ACCESS
2826  52E5     MOVF POSTDEC1, F, ACCESS
219:           	}	
220:           		/*Опрос концевиков и заполнение структуры состояний концевиков 
221:                   (сделано говнокодом, так как при работе с портами через 
222:           		указатели лажа) */
223:           		M_LI_ls_question();
2828  EF6B     GOTO 0x26D6
282A  F013     NOP
224:           	
225:           }
226:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_indication/module_indication.c  -----------
1:             #include "module_indication.h"
2:             #include "module_management.h"
3:             #include "module_analog_inputs.h"
4:             #include "menu.h"
5:             #include "module_motor.h"
6:             #include "module_logic_inputs.h"
7:             #include "main.h"
8:             #include <p18cxxx.h>
9:             #include "osa.h"
10:            #include "spi.h"
11:            #include "logicAnalyzer.h"
12:            #include "boardModes.h"
13:            
14:            #define INDEX_OF_BLANK_SYMBOL	(sizeof (M_Ind_PortraitsFirstInd) / sizeof (M_Ind_PortraitsFirstInd[0])) - 1 
15:            #define IT_IS_A_TEXT_SYM_AREA 	(sizeof (M_Ind_PortraitsFirstInd) / sizeof (M_Ind_PortraitsFirstInd[0])) - 14
16:            #define INDEX_OF_AREA_FUEL_TYPE (sizeof (M_Ind_PortraitsFirstInd) / sizeof (M_Ind_PortraitsFirstInd[0])) - 7
17:            
18:            #define ANODE_FIRST_PORT			  LATE
19:            #define ANODE_SECOND_PORT			  LATD
20:            #define ANODES_ARE_OFF_ON_FIRST_PORT  0b11000000
21:            #define ANODES_ARE_OFF_ON_SECOND_PORT 0b00001111
22:            #define ANODE_1_PIN                   LATEbits.LATE6
23:            #define ANODE_1_TRIS                  TRISEbits.TRISE6
24:            #define ANODE_2_PIN                   LATEbits.LATE7
25:            #define ANODE_2_TRIS                  TRISEbits.TRISE7
26:            #define ANODE_3_PIN                   LATDbits.LATD0
27:            #define ANODE_3_TRIS                  TRISDbits.TRISD0
28:            #define ANODE_4_PIN                   LATDbits.LATD1
29:            #define ANODE_4_TRIS                  TRISDbits.TRISD1
30:            #define ANODE_5_PIN                   LATDbits.LATD2
31:            #define ANODE_5_TRIS                  TRISDbits.TRISD2
32:            #define ANODE_6_PIN                   LATDbits.LATD3
33:            #define ANODE_6_TRIS                  TRISDbits.TRISD3
34:            
35:            #define QUANTITY_OF_LEDS		 	  3U
36:            #define LED_BICOLOR_GREEN_PIN		  LATEbits.LATE5
37:            #define LED_BICOLOR_GREEN_TRIS        TRISEbits.TRISE5
38:            #define LED_BICOLOR_RED_PIN           LATEbits.LATE4
39:            #define LED_BICOLOR_RED_TRIS          TRISEbits.TRISE4
40:            #define LED_FAN_PIN					  LATEbits.LATE3
41:            #define LED_FAN_TRIS                  TRISEbits.TRISE3
42:            #define LED_PUMP_PIN                  LATEbits.LATE2
43:            #define LED_PUMP_TRIS                 TRISEbits.TRISE2
44:            
45:            #define ANODE_IS_OFF                  1
46:            #define ANODE_IS_ON                   0
47:            
48:            
49:            
50:            
51:            #define LEFT_INDICATOR				  0
52:            #define MIDDLE_INDICATOR			  1
53:            #define RIGHT_INDICATOR				  2
54:            
55:            #define NO_BLINKING					  0U
56:            #define BLINKING_RED				  1
57:            #define BLINKING_GREEN				  2
58:            #define BLINKING_YELLOW				  3
59:            #define BLINKING_FAN_PIN			  4
60:            #define BLINKING_PUMP_PIN             5
61:            #define INDEX_OF_BICOLOR_LED		  0
62:            #define INDEX_OF_FAN_LED			  1
63:            #define INDEX_OF_PUMP_LED			  2
64:            
65:            
66:            //****** КОНСТАНТЫ***********************************
67:            
68:            /*Таблица портретов для семисегментного индикатора с общим катодом
69:               _ A _
70:              |     |
71:              F     B
72:              |_ G _|
73:              |     |
74:              E     C
75:              |_ D _|.H 
76:              
77:              |Символ   | Сегменты   |
78:                 0	 	 	ABCDEF	 		
79:                 1	   		BC	
80:                 2	   		ABDEG	
81:                 3  		ABCDG
82:                 4     		BCFG
83:                 5  		ACDFG
84:                 6     		ACDEFG
85:                 7  		ABC
86:                 8  		ABCDEFG
87:                 9     		ABCDFG
88:                 А  		ABCEFG
89:                 P 		 	ABEFG
90:                 U 			BCDEF
91:                 Е   		ADEFG
92:                 C    		ADEF
93:                 L    		DEF     
94:                 У	    	BCDFG	
95:                 Б	    	ACDEFG
96:                 П	    	ABCEF
97:                 t	    	DEFG
98:              	 F			AEFG
99:              	 d			BCDEG
100:             	 
101:             |Бит|		| Сегмент | - первый индикатор (HL4)
102:               7     		B
103:               6   		E	
104:               5	  		F
105:               4	  		A
106:               3	  		D
107:               2	  		H
108:               1	  		C
109:               0	  		G
110:            
111:              |Бит|	| Сегмент | - второй индикатор (HL5)
112:               7     		A
113:               6   		G	
114:               5	  		F
115:               4	  		B
116:               3	  		C
117:               2	  		H
118:               1	  		D
119:               0	  		E
120:            */
121:           const rom uint8_t M_Ind_PortraitsFirstInd[] =
122:           {
123:               0b00000101,		//0 ABCDEF 
124:               0b01111101,		//1 BC	
125:               0b00100110, 	//2 ABDEG 
126:               0b01100100,		//3 ABCDG 
127:               0b01011100,		//4 BCFG
128:               0b11000100,		//5 ACDFG
129:               0b10000100,		//6 ACDEFG
130:               0b01101101,		//7 ABC
131:               0b00000100,		//8	ABCDEFG
132:               0b01000100,		//9 ABCDFG
133:               0b00001100,		//A ABCEFG
134:               0b00001110,		//P ABEFG
135:               0b00010101,		//U BCDEF
136:               0b10000110,		//E ADEFG 
137:               0b10000111,		//C ADEF
138:               0b10010111,		//L DEF
139:               0b11000100,		//S (как 5) ACDFG
140:               0b01010100,		//У BCDFG
141:               0b10000100,		//Б (как 6) ACDEFG
142:               0b00001101,		//П ABCEF
143:               0b10010110,		//типа t DEFG
144:               0b10001110, 	//символ F AEFG
145:               0b00110100,		//символ d BCDEG
146:               0b11111111  	//пустой символ
147:           }; 
148:           
149:           const rom uint8_t M_Ind_PortraitsSecondInd[] =
150:           {
151:               0b01000100,		//0 ABCDEF 
152:               0b11100111,		//1 BC	
153:               0b00101100, 	//2 ABDEG 
154:               0b00100101,		//3 ABCDG 
155:               0b10000111,		//4 BCFG
156:               0b00010101,		//5 ACDFG
157:               0b00010100,		//6 ACDEFG
158:               0b01100111,		//7 ABC
159:               0b00000100,		//8	ABCDEFG
160:               0b00000101,		//9 ABCDFG
161:               0b00000110,		//A ABCEFG
162:               0b00001110,		//P ABEFG
163:               0b11000100,		//U BCDEF
164:               0b00011100,		//E ADEFG 
165:               0b01011100,		//C ADEF
166:               0b11011100,		//L DEF
167:               0b00010101,		//S (как 5) ACDFG
168:               0b10000101,		//У BCDFG
169:               0b00010100,		//Б (как 6) ACDEFG
170:               0b01000110,		//П ABCEF
171:               0b10011100,		//типа t DEFG
172:               0b00011110, 	//символ F AEFG
173:               0b10100100,		//символ d BCDEG
174:               0b11111111  	//пустой символ
175:           };
176:           const rom uint8_t* ptrTablePortraits [QUANTITY_OF_SEVEN_SEGMENT_INDICATORS] = { M_Ind_PortraitsFirstInd, M_Ind_PortraitsSecondInd };
177:             
178:           
179:           const rom uint8_t decimals[] = {100,10,1,0};
180:           
181:           //Константа времён для отсчёта временных интервалов, использующихся в модуле индикации
182:           const rom uint16_t M_Ind_time_const[] = 
183:           {
184:           	5,  //5 секунд для отсчёта времени отображения версии ПО
185:           	500  //500 мс для отсчёта времени мигания (как семисегментного индикатора, так и светодиодов)
186:           };
187:           
188:           #define NO_DOT								0b11111111
189:           #define IS_DOT								0b11111011
190:           #define INDEX_IS_DOT						0
191:           #define INDEX_NO_DOT						1
192:           #define OFFSET_TO_SYMBOL_A                  0
193:           #define OFFSET_TO_SYMBOL_P                  1
194:           #define OFFSET_TO_SYMBOL_U                  2
195:           #define OFFSET_TO_SYMBOL_E					3
196:           #define OFFSET_TO_SYMBOL_C                  4
197:           #define OFFSET_TO_SYMBOL_L					5
198:           #define OFFSET_TO_SYMBOL_S                  6
199:           #define OFFSET_TO_SYMBOL_t					10
200:           #define OFFSET_TO_SYMBOL_F					11
201:           #define OFFSET_TO_SYMBOL_d					12
202:           #define LEFT_SYMBOL_WITH_DOT				1
203:           #define LEFT_SYMBOL_NO_DOT                  0
204:           
205:           
206:           typedef struct 
207:           {
208:           	uint16_t time_init;
209:           	uint16_t time_blink;
210:           	uint16_t time_auto_exit;
211:           	uint16_t time_blink_LED;
212:           }TIME_M_Ind;
213:           
214:           typedef struct 
215:           {
216:           	BOOL Flag_Blink_seven_segm;                                     //флаг мигания 7-сегментного индикатора
217:           	int8_t index_of_text_sym[QUANTITY_OF_FAMILIARITY];             //смещение до поля текстовых символов A,P,U,E,C,L
218:           	uint8_t data[QUANTITY_OF_FAMILIARITY];                          //выводимые данные
219:           	uint8_t	dot[QUANTITY_OF_FAMILIARITY];                           //для вывода точки	
220:           	const rom uint8_t const_dot[2];
221:           }Ind;
222:           
223:           //*******ПЕРЕЧИСЛЕНИЯ*********
224:           
225:           typedef enum {
226:           	e_Time_Init = 0,
227:           	e_Time_Blink 
228:           } eIndexConst_Mod_Ind;
229:           
230:           
231:           //Функции модуля индикации
232:           
233:           static void		M_Ind_bin2dec (uint16_t value, uint8_t numInd); 
234:           static void		M_Ind_7_Segment_Out(void);  
235:           static void 	M_Ind_View_SW_version(void);  
236:           static void 	M_Ind_temperature_real(void);   
237:           static void		M_Ind_view_num_page_menu(void); 
238:           static void		M_Ind_view_parameter_menu(void);    
239:           static void	 	M_Ind_blinking_7segm(BOOL state_left_symbol_dot, BOOL need_blink, uint8_t numInd); 
240:           static void		M_Ind_view_temperature_or_fan_level_setup(const uint8_t offset_to_symb, uint8_t parameter);
241:           static void		M_Ind_view_failure(void); 
242:           static void		M_Ind_view_text(const uint8_t left_ind_offset_to_symb, const uint8_t middle_ind_offset_to_symb, 
243:                                           const uint8_t right_ind_offset_to_symb, BOOL need_blink, uint8_t numInd);
244:           static void		M_Ind_LED_blinking(uint8_t action, const uint8_t index);
245:           static void		M_Ind_TimerAutoExit( void );
246:           
247:           
248:           //*********СТРУКТУРЫ******************************************
249:           
250:           Ind M_Ind_data[QUANTITY_OF_SEVEN_SEGMENT_INDICATORS] = { {0, {0,0,0}, {0,0,0}, {0,0,0}, {IS_DOT, NO_DOT}}, 
251:                                                                   {0, {0,0,0}, {0,0,0}, {0,0,0}, {IS_DOT, NO_DOT}} };
252:           
253:           TIME_M_Ind time_M_Ind = {0};
254:           
255:           
256:           //***********ПЕРЕМЕННЫЕ****************************************
257:           uint8_t M_Ind_State = 0;
258:           uint8_t M_Ind_Previous_State = 0;
259:           BOOL blink_mode = OFF;
260:           BOOL Flag_Blink_led[QUANTITY_OF_LEDS];    //флаг мигания светодиодов 	
261:           
262:           void M_Ind_ctor(void)
263:           {
264:               ANODE_1_PIN  = ANODE_IS_OFF;  
0CEA  8C8D     BSF LATE, 6, ACCESS
265:               ANODE_1_TRIS = OUT;
0CEC  9C96     BCF TRISE, 6, ACCESS
266:               ANODE_2_PIN  = ANODE_IS_OFF; 
0CEE  8E8D     BSF LATE, 7, ACCESS
267:               ANODE_2_TRIS = OUT; 
0CF0  9E96     BCF TRISE, 7, ACCESS
268:               ANODE_3_PIN  = ANODE_IS_OFF; 
0CF2  808C     BSF LATD, 0, ACCESS
269:               ANODE_3_TRIS = OUT; 
0CF4  9095     BCF TRISD, 0, ACCESS
270:               ANODE_4_PIN  = ANODE_IS_OFF; 
0CF6  828C     BSF LATD, 1, ACCESS
271:               ANODE_4_TRIS = OUT; 
0CF8  9295     BCF TRISD, 1, ACCESS
272:               ANODE_5_PIN  = ANODE_IS_OFF; 
0CFA  848C     BSF LATD, 2, ACCESS
273:               ANODE_5_TRIS = OUT; 
0CFC  9495     BCF TRISD, 2, ACCESS
274:               ANODE_6_PIN  = ANODE_IS_OFF; 
0CFE  868C     BSF LATD, 3, ACCESS
275:               ANODE_6_TRIS = OUT; 
0D00  9695     BCF TRISD, 3, ACCESS
276:               LED_BICOLOR_GREEN_TRIS = OUT; 
0D02  9A96     BCF TRISE, 5, ACCESS
277:               LED_BICOLOR_RED_TRIS = OUT;   
0D04  9896     BCF TRISE, 4, ACCESS
278:               LED_FAN_TRIS = OUT;           
0D06  9696     BCF TRISE, 3, ACCESS
279:               LED_PUMP_TRIS = OUT;           
0D08  9496     BCF TRISE, 2, ACCESS
280:               LED_BICOLOR_GREEN_PIN = OFF; 
0D0A  9A8D     BCF LATE, 5, ACCESS
281:               LED_BICOLOR_RED_PIN = OFF;   
0D0C  988D     BCF LATE, 4, ACCESS
282:               LED_FAN_PIN = OFF;           
0D0E  968D     BCF LATE, 3, ACCESS
283:               LED_PUMP_PIN = OFF; 
0D10  948D     BCF LATE, 2, ACCESS
284:               M_Ind_data[0].dot[LEFT_INDICATOR]   = M_Ind_data[0].const_dot[INDEX_NO_DOT];
0D12  C0A8     MOVFF 0xA8, 0xA4
0D14  F0A4     NOP
285:               M_Ind_data[0].dot[MIDDLE_INDICATOR] = M_Ind_data[0].const_dot[INDEX_NO_DOT];
0D16  C0A8     MOVFF 0xA8, 0xA5
0D18  F0A5     NOP
286:               M_Ind_data[0].dot[RIGHT_INDICATOR]  = M_Ind_data[0].const_dot[INDEX_NO_DOT];
0D1A  C0A8     MOVFF 0xA8, 0xA6
0D1C  F0A6     NOP
287:               M_Ind_data[1].dot[LEFT_INDICATOR]   = M_Ind_data[1].const_dot[INDEX_NO_DOT];
0D1E  C0B4     MOVFF 0xB4, 0xB0
0D20  F0B0     NOP
288:               M_Ind_data[1].dot[MIDDLE_INDICATOR] = M_Ind_data[1].const_dot[INDEX_NO_DOT];
0D22  C0B4     MOVFF 0xB4, 0xB1
0D24  F0B1     NOP
289:               M_Ind_data[1].dot[RIGHT_INDICATOR]  = M_Ind_data[1].const_dot[INDEX_NO_DOT];
0D26  C0B4     MOVFF 0xB4, 0xB2
0D28  F0B2     NOP
290:           }
0D2A  0012     RETURN 0
291:           
292:           void  M_Ind_Set_blink_mode(BOOL value)
0D2C  DBED     RCALL __pa_26
293:           {
294:           	blink_mode = value;
0D2E  CFDB     MOVFF PLUSW2, blink_mode
0D30  F0BF     NOP
295:           }
0D32  D36B     BRA __pa_5
296:           
297:           //**************ФУНКЦИИ**********************************
298:           
299:           uint8_t M_Ind_Get_Previous_State(void)
300:           {
301:           	return M_Ind_Previous_State;
0D34  0100     MOVLB 0x0
0D36  51BE     MOVF M_Ind_Previous_State, W, BANKED
302:           }
0D38  0012     RETURN 0
303:           
304:           void M_Ind_Set_Previous_State(uint8_t state) 
0D3A  DBE6     RCALL __pa_26
305:           {
306:           	M_Ind_Previous_State = state;
0D3C  CFDB     MOVFF PLUSW2, M_Ind_Previous_State
0D3E  F0BE     NOP
307:           }
0D40  D364     BRA __pa_5
308:           
309:           void M_Ind_Set_state(uint8_t value)
0D42  DBE2     RCALL __pa_26
310:           {
311:           	M_Ind_State = value;
0D44  CFDB     MOVFF PLUSW2, M_Ind_State
0D46  F0BD     NOP
312:           }
0D48  D360     BRA __pa_5
313:           
314:           uint8_t M_Ind_Get_state(void)
315:           {
316:           	return M_Ind_State;
0D4A  0100     MOVLB 0x0
0D4C  51BD     MOVF M_Ind_State, W, BANKED
317:           }
0D4E  0012     RETURN 0
318:           
319:           /* Вывод на семисегментный индикатор */
320:           static void M_Ind_7_Segment_Out (void)
321:           {
322:           	static uint8_t count_s = 0, numAnode = 0;
323:               static uint8_t count_indicators = 0;
324:               
325:               //Сброс пинов с общими анодами и установка нужного
326:               ANODE_FIRST_PORT |= ANODES_ARE_OFF_ON_FIRST_PORT;
0D50  0EC0     MOVLW 0xC0
0D52  128D     IORWF LATE, F, ACCESS
327:               ANODE_SECOND_PORT |= ANODES_ARE_OFF_ON_SECOND_PORT;
0D54  0E0F     MOVLW 0xF
0D56  128C     IORWF LATD, F, ACCESS
328:           
329:                   //Загружаем данные в сдвиговый регистр
330:                   SW_SPI_writeByte( *(ptrTablePortraits[count_indicators] + M_Ind_data[count_indicators].data[count_s] ) 
0D70  DB85     RCALL __pa_13
0D72  0E04     MOVLW 0x4
0D74  DB37     RCALL __pa_1
0D76  CFE9     MOVFF FSR0, 0x34
0D78  F034     NOP
0D7A  CFEA     MOVFF FSR0H, 0x35
0D7C  F035     NOP
0D7E  51C0     MOVF 0xC0, W, BANKED
0D80  010F     MOVLB 0xF
0D82  DB4C     RCALL __pa_7
0D84  50EF     MOVF INDF0, W, ACCESS
0D86  6E32     MOVWF __tmp_0, ACCESS
0D88  6A33     CLRF 0x33, ACCESS
0D8A  0100     MOVLB 0x0
0D8C  51C2     MOVF 0xC2, W, BANKED
0D8E  6EE9     MOVWF FSR0, ACCESS
0D90  6AEA     CLRF FSR0H, ACCESS
0D92  90D8     BCF STATUS, 0, ACCESS
0D94  36E9     RLCF FSR0, F, ACCESS
0D96  36EA     RLCF FSR0H, F, ACCESS
0D98  0E99     MOVLW 0x99
0D9A  26E9     ADDWF FSR0, F, ACCESS
0D9C  0E00     MOVLW 0x0
0D9E  22EA     ADDWFC FSR0H, F, ACCESS
0DA0  5032     MOVF __tmp_0, W, ACCESS
0DA2  24EE     ADDWF POSTINC0, W, ACCESS
0DA4  6EF6     MOVWF TBLPTR, ACCESS
0DA6  5033     MOVF 0x33, W, ACCESS
0DA8  20EE     ADDWFC POSTINC0, W, ACCESS
0DAA  6EF7     MOVWF TBLPTRH, ACCESS
0DAC  0008     TBLRD*
0DAE  50F5     MOVF TABLAT, W, ACCESS
331:                                     & M_Ind_data[count_indicators].dot[count_s]);
0D58  DB91     RCALL __pa_13
0D5A  0E07     MOVLW 0x7
0D5C  DB43     RCALL __pa_1
0D5E  CFE9     MOVFF FSR0, 0x37
0D60  F037     NOP
0D62  CFEA     MOVFF FSR0H, 0x38
0D64  F038     NOP
0D66  51C0     MOVF 0xC0, W, BANKED
0D68  010F     MOVLB 0xF
0D6A  DB58     RCALL __pa_7
0D6C  CFEF     MOVFF INDF0, 0x36
0D6E  F036     NOP
0DB0  1436     ANDWF 0x36, W, ACCESS
0DB2  6EE6     MOVWF POSTINC1, ACCESS
0DB4  EC3B     CALL 0x3476, 0
0DB6  F01A     NOP
0DB8  52E5     MOVF POSTDEC1, F, ACCESS
147C  0100     MOVLB 0x0
147E  51C2     MOVF 0xC2, W, BANKED
1480  D066     BRA __pa_34
14D6  CFF3     MOVFF PROD, FSR0
14D8  FFE9     NOP
14DA  CFF4     MOVFF PRODH, FSR0H
14DC  FFEA     NOP
14DE  0012     RETURN 0
332:                   switch( numAnode )
0DBA  0100     MOVLB 0x0
0DBC  51C1     MOVF 0xC1, W, BANKED
0DBE  0A05     XORLW 0x5
0DC0  E014     BZ 0xDEA
0DC2  0A01     XORLW 0x1
0DC4  E010     BZ 0xDE6
0DC6  0A07     XORLW 0x7
0DC8  E00C     BZ 0xDE2
0DCA  0A01     XORLW 0x1
0DCC  E008     BZ 0xDDE
0DCE  0A03     XORLW 0x3
0DD0  E004     BZ 0xDDA
0DD2  0A01     XORLW 0x1
0DD4  E10B     BNZ 0xDEC
333:                   {
334:                       case 0:
335:                           ANODE_1_PIN  = ANODE_IS_ON;
0DD6  9C8D     BCF LATE, 6, ACCESS
336:                           break;
0DD8  D009     BRA 0xDEC
337:                       case 1:
338:                           ANODE_2_PIN  = ANODE_IS_ON;
0DDA  9E8D     BCF LATE, 7, ACCESS
339:                           break;
0DDC  D007     BRA 0xDEC
340:                       case 2:
341:                           ANODE_3_PIN  = ANODE_IS_ON;
0DDE  908C     BCF LATD, 0, ACCESS
342:                           break;    
0DE0  D005     BRA 0xDEC
343:                       case 3:
344:                           ANODE_4_PIN  = ANODE_IS_ON;
0DE2  928C     BCF LATD, 1, ACCESS
345:                           break;
0DE4  D003     BRA 0xDEC
346:                       case 4:
347:                           ANODE_5_PIN  = ANODE_IS_ON;
0DE6  948C     BCF LATD, 2, ACCESS
348:                           break;
0DE8  D001     BRA 0xDEC
349:                       case 5:
350:                           ANODE_6_PIN  = ANODE_IS_ON;
0DEA  968C     BCF LATD, 3, ACCESS
351:                   }  
352:                   numAnode++;
0DEC  2BC1     INCF 0xC1, F, BANKED
353:                   if(++count_s == QUANTITY_OF_FAMILIARITY ) 
0DEE  2BC0     INCF 0xC0, F, BANKED
0DF0  0E03     MOVLW 0x3
0DF2  5DC0     SUBWF 0xC0, W, BANKED
0DF4  E107     BNZ 0xE04
354:                   {    
355:                       count_s = 0;
0DF6  6BC0     CLRF 0xC0, BANKED
356:                       if(++count_indicators == QUANTITY_OF_SEVEN_SEGMENT_INDICATORS )
0DF8  2BC2     INCF 0xC2, F, BANKED
0DFA  0E02     MOVLW 0x2
0DFC  5DC2     SUBWF 0xC2, W, BANKED
0DFE  E102     BNZ 0xE04
357:                       {    
358:                           count_indicators = 0;
0E00  6BC2     CLRF 0xC2, BANKED
359:                           numAnode = 0;
0E02  6BC1     CLRF 0xC1, BANKED
360:                       }
361:                   }
362:           }
0E04  0012     RETURN 0
363:           
364:           /* 
365:           Функция преобразования int числа value  из двоичного в двоично-десятичный формат с заполнением массива data
366:           - гасит незначащие нули в искомом числе
367:           - отрабатывает режим мигания
368:           - определяет число или текстовый символ нужно выводить
369:           Входные параметры:
370:           unsigned  int value - искомое число
371:           */
372:           
373:           static void M_Ind_bin2dec (uint16_t value, uint8_t numInd)
0E06  DB05     RCALL __pa_6
0E08  0E02     MOVLW 0x2
0E0A  26E1     ADDWF FSR1, F, ACCESS
374:           {
375:            	uint8_t count = 0;
0E0C  6ADF     CLRF INDF2, ACCESS
376:            	uint8_t decimals_temp = decimals[0];
0E0E  0EF4     MOVLW 0xF4
0E10  6EF6     MOVWF TBLPTR, ACCESS
0E12  0E35     MOVLW 0x35
0E14  6EF7     MOVWF TBLPTRH, ACCESS
0E16  0008     TBLRD*
0E18  0E01     MOVLW 0x1
0E1A  CFF5     MOVFF TABLAT, PLUSW2
0E1C  FFDB     NOP
377:                  
378:                   if (M_Ind_data[numInd].Flag_Blink_seven_segm)		 //если нужно мигать, то выводим пустые символы
0E1E  DB8D     RCALL __pa_32
0E20  50EF     MOVF INDF0, W, ACCESS
0E22  E00A     BZ 0xE38
379:                       M_Ind_data[numInd].data[LEFT_INDICATOR] = M_Ind_data[numInd].data[MIDDLE_INDICATOR] = M_Ind_data[numInd].data[RIGHT_INDICATOR] 
0E24  DB48     RCALL __pa_19
0E26  DB86     RCALL __pa_31
0E2C  DB97     RCALL __pa_35
0E32  DB83     RCALL __pa_32
0E34  0E04     MOVLW 0x4
380:                       = INDEX_OF_BLANK_SYMBOL;		
0E28  0E17     MOVLW 0x17
0E2A  6EEF     MOVWF INDF0, ACCESS
0E2E  0E17     MOVLW 0x17
0E30  6EEF     MOVWF INDF0, ACCESS
381:                   else
0E36  D055     BRA 0xEE2
382:                   {
383:                       M_Ind_data[numInd].data[LEFT_INDICATOR] = M_Ind_data[numInd].data[MIDDLE_INDICATOR] 
0E3E  DB8E     RCALL __pa_35
0E42  DB39     RCALL __pa_19
384:                       = M_Ind_data[numInd].data[RIGHT_INDICATOR] = 0;
0E38  DB3E     RCALL __pa_19
0E3A  DB7C     RCALL __pa_31
0E3C  6AEF     CLRF INDF0, ACCESS
0E40  6AEF     CLRF INDF0, ACCESS
0E44  6EEF     MOVWF INDF0, ACCESS
385:                       while(count < QUANTITY_OF_FAMILIARITY) 		// цикл по всем цифрам
0E46  0E03     MOVLW 0x3
0E48  5CDF     SUBWF INDF2, W, ACCESS
0E4A  E240     BC 0xECC
0ECA  D7BD     BRA 0xE46
386:                       {
387:                               if (M_Ind_data[numInd].index_of_text_sym[count] >= IT_IS_A_TEXT_SYM_AREA) //если нужно выводить не цифру, а текстовый символ
0E4C  DB50     RCALL __pa_24
0E4E  CFEF     MOVFF INDF0, __tmp_0
0E50  F032     NOP
0E52  6A33     CLRF 0x33, ACCESS
0E54  BE32     BTFSC __tmp_0, 7, ACCESS
0E56  6833     SETF 0x33, ACCESS
0E58  0E0A     MOVLW 0xA
0E5A  5C32     SUBWF __tmp_0, W, ACCESS
0E5C  0E00     MOVLW 0x0
0E5E  5833     SUBWFB 0x33, W, ACCESS
0E60  E308     BNC 0xE72
14EE  D825     RCALL __pa_32
14F0  52EE     MOVF POSTINC0, F, ACCESS
14F2  50DF     MOVF INDF2, W, ACCESS
14F4  EF0E     GOTO 0x141C
14F6  F00A     NOP
388:                                   M_Ind_data[numInd].data[count] = M_Ind_data[numInd].index_of_text_sym[count];
0E62  DB45     RCALL __pa_24
0E64  50EF     MOVF INDF0, W, ACCESS
0E66  6EE6     MOVWF POSTINC1, ACCESS
0E68  DB26     RCALL __pa_19
0E6A  50DF     MOVF INDF2, W, ACCESS
0E6C  DAD7     RCALL __pa_7
0E6E  DB09     RCALL __pa_14
389:                           else
0E70  D021     BRA 0xEB4
390:                           {
391:                               while(value >= decimals_temp) 
0E72  0EFD     MOVLW 0xFD
0E74  CFDB     MOVFF PLUSW2, __tmp_0
0E76  F032     NOP
0E78  0EFE     MOVLW 0xFE
0E7A  CFDB     MOVFF PLUSW2, 0x33
0E7C  F033     NOP
0E7E  0E01     MOVLW 0x1
0E80  50DB     MOVF PLUSW2, W, ACCESS
0E82  6A35     CLRF 0x35, ACCESS
0E84  50E8     MOVF WREG, W, ACCESS
0E86  5C32     SUBWF __tmp_0, W, ACCESS
0E88  5035     MOVF 0x35, W, ACCESS
0E8A  5833     SUBWFB 0x33, W, ACCESS
0E8C  E313     BNC 0xEB4
0EB2  D7DF     BRA 0xE72
392:                               { 
393:                                   value -= decimals_temp;  
0E8E  0E01     MOVLW 0x1
0E90  50DB     MOVF PLUSW2, W, ACCESS
0E92  6E32     MOVWF __tmp_0, ACCESS
0E94  6A33     CLRF 0x33, ACCESS
0E96  50D9     MOVF FSR2, W, ACCESS
0E98  0FFD     ADDLW 0xFD
0E9A  6EE9     MOVWF FSR0, ACCESS
0E9C  0EFF     MOVLW 0xFF
0E9E  20DA     ADDWFC FSR2H, W, ACCESS
0EA0  6EEA     MOVWF FSR0H, ACCESS
0EA2  5032     MOVF __tmp_0, W, ACCESS
0EA4  5EEE     SUBWF POSTINC0, F, ACCESS
0EA6  5033     MOVF 0x33, W, ACCESS
0EA8  5AED     SUBWFB POSTDEC0, F, ACCESS
394:                                   M_Ind_data[numInd].data[count]++;
0EAA  DB05     RCALL __pa_19
0EAC  50DF     MOVF INDF2, W, ACCESS
0EAE  DAB6     RCALL __pa_7
0EB0  2AEF     INCF INDF0, F, ACCESS
141C  24E9     ADDWF FSR0, W, ACCESS
141E  6EE9     MOVWF FSR0, ACCESS
1420  0E00     MOVLW 0x0
1422  20EA     ADDWFC FSR0H, W, ACCESS
1424  6EEA     MOVWF FSR0H, ACCESS
1426  0012     RETURN 0
395:                               }			
396:                           }
397:                           count++;
0EB4  2ADF     INCF INDF2, F, ACCESS
398:                           decimals_temp = decimals[count];	
0EB6  50DF     MOVF INDF2, W, ACCESS
0EB8  6AF7     CLRF TBLPTRH, ACCESS
0EBA  0FF4     ADDLW 0xF4
0EBC  6EF6     MOVWF TBLPTR, ACCESS
0EBE  0E35     MOVLW 0x35
0EC0  22F7     ADDWFC TBLPTRH, F, ACCESS
0EC2  0008     TBLRD*
0EC4  0E01     MOVLW 0x1
0EC6  CFF5     MOVFF TABLAT, PLUSW2
0EC8  FFDB     NOP
399:                       }
400:                       if(M_Ind_data[numInd].data[LEFT_INDICATOR] == 0U) //формирование гашения незначащих нулей
0ECC  DAF4     RCALL __pa_19
0ECE  50EF     MOVF INDF0, W, ACCESS
0ED0  E10B     BNZ 0xEE8
401:                       {		
402:                           M_Ind_data[numInd].data[LEFT_INDICATOR] = INDEX_OF_BLANK_SYMBOL;
0ED2  DAF1     RCALL __pa_19
0ED4  0E17     MOVLW 0x17
0ED6  6EEF     MOVWF INDF0, ACCESS
403:                           if(M_Ind_data[numInd].data[MIDDLE_INDICATOR] == 0U)
0ED8  DB41     RCALL __pa_35
0EDA  50EF     MOVF INDF0, W, ACCESS
0EDC  E105     BNZ 0xEE8
155C  DFAC     RCALL __pa_19
155E  0E01     MOVLW 0x1
1560  EFF2     GOTO 0x13E4
1562  F009     NOP
404:                               M_Ind_data[numInd].data[MIDDLE_INDICATOR] = INDEX_OF_BLANK_SYMBOL;
0EDE  DAEB     RCALL __pa_19
0EE0  0E01     MOVLW 0x1
0EE2  DA80     RCALL __pa_1
0EE4  0E17     MOVLW 0x17
0EE6  6EEF     MOVWF INDF0, ACCESS
14B6  D841     RCALL __pa_32
14B8  0E04     MOVLW 0x4
14BA  EFF2     GOTO 0x13E4
14BC  F009     NOP
405:                       } 	
406:               }    
407:           }
0EE8  0E02     MOVLW 0x2
0EEA  5CE1     SUBWF FSR1, W, ACCESS
0EEC  E202     BC 0xEF2
0EEE  6AE1     CLRF FSR1, ACCESS
0EF0  52E5     MOVF POSTDEC1, F, ACCESS
0EF2  6EE1     MOVWF FSR1, ACCESS
0EF4  D28A     BRA __pa_5
408:           
409:           /* Индикация светодиода "Вентилятор" */
410:           static void M_Ind_led_fan_mode(void)
411:           {
412:           	switch(M_Mngm_get_burning_state())
0EF6  ECF7     CALL 0x15EE, 0
0EF8  F00A     NOP
0EFA  0A04     XORLW 0x4
0EFC  E00F     BZ 0xF1C
0EFE  0A05     XORLW 0x5
0F00  E00B     BZ 0xF18
0F02  0A02     XORLW 0x2
0F04  E009     BZ 0xF18
0F06  0A01     XORLW 0x1
0F08  E007     BZ 0xF18
0F0A  0A07     XORLW 0x7
0F0C  E005     BZ 0xF18
0F0E  0A05     XORLW 0x5
0F10  E001     BZ 0xF14
0F12  0012     RETURN 0
413:           	{
414:           		case CALC_PARAMS_PERIOD:
415:           			LED_FAN_PIN = OFF;
0F14  968D     BCF LATE, 3, ACCESS
416:           		break;
0F16  0012     RETURN 0
417:           		case START_BURNING:
418:           		case ECONOM_MODE:
419:           		case INCREASE_TEMPERATURE:
420:           		case MAINTENANCE_TEMPERATURE_INCR:
421:           			LED_FAN_PIN = ON;
0F18  868D     BSF LATE, 3, ACCESS
422:           		break;
0F1A  0012     RETURN 0
423:           		case MAINTENANCE_TEMPERATURE_CYCLE:
424:           			switch(M_Mngm_get_phase_cycle())
0F1C  ECBD     CALL 0x157A, 0
0F1E  F00A     NOP
0F20  0A01     XORLW 0x1
0F22  E009     BZ 0xF36
0F24  0A01     XORLW 0x1
0F26  E001     BZ 0xF2A
0F28  0012     RETURN 0
425:           			{
426:           				case PAUSE_IN_CYCLE:
427:           					M_Ind_LED_blinking(BLINKING_FAN_PIN, INDEX_OF_FAN_LED);
0F2A  0E01     MOVLW 0x1
0F2C  6EE6     MOVWF POSTINC1, ACCESS
0F2E  0E04     MOVLW 0x4
0F30  6EE6     MOVWF POSTINC1, ACCESS
0F32  EF73     GOTO 0x14E6
0F34  F00A     NOP
428:           				break;
429:           				case WORK_IN_CYCLE:
430:           					LED_FAN_PIN = ON;
0F36  868D     BSF LATE, 3, ACCESS
431:           				break;
432:           			}
433:           		break;
434:           	}
435:           }	
0F38  0012     RETURN 0
436:           
437:           
438:           /* Автомат состояний модуля индикации */
439:           void M_Ind_Run (void)
440:           {
441:           	switch(M_Ind_State)
0F3A  0100     MOVLB 0x0
0F3C  51BD     MOVF M_Ind_State, W, BANKED
0F3E  0A08     XORLW 0x8
0F40  E101     BNZ 0xF44
0F42  D099     BRA 0x1076
0F44  0A0F     XORLW 0xF
0F46  E101     BNZ 0xF4A
0F48  D078     BRA 0x103A
0F4A  0A01     XORLW 0x1
0F4C  E065     BZ 0x1018
0F4E  0A03     XORLW 0x3
0F50  E05A     BZ 0x1006
0F52  0A0C     XORLW 0xC
0F54  E04B     BZ 0xFEC
0F56  0A0D     XORLW 0xD
0F58  E041     BZ 0xFDC
0F5A  0A07     XORLW 0x7
0F5C  E01A     BZ 0xF92
0F5E  0A01     XORLW 0x1
0F60  E010     BZ 0xF82
0F62  0A03     XORLW 0x3
0F64  E007     BZ 0xF74
0F66  0A01     XORLW 0x1
0F68  E001     BZ 0xF6C
0F6A  D089     BRA 0x107E
442:           	{
443:           		case STATE_IND_INIT :						//инициализация (мигание версии ПО), все светоиоды отключены
444:           			M_Ind_View_SW_version();					
0F6C  D9B9     RCALL M_Ind_View_SW_version
445:           			LED_BICOLOR_GREEN_PIN = OFF;
0F6E  9A8D     BCF LATE, 5, ACCESS
446:           			LED_BICOLOR_RED_PIN = OFF;
0F70  988D     BCF LATE, 4, ACCESS
447:           			LED_FAN_PIN = OFF;
448:           			M_Ind_LED_blinking(NO_BLINKING, INDEX_OF_BICOLOR_LED);
449:                       break;
0F72  D05F     BRA 0x1032
450:           		case STATE_VIEW_NUM_PAGE_MENU :		//отображение номера страницы пользовательского меню
451:           			M_Ind_Previous_State = STATE_VIEW_NUM_PAGE_MENU;
0F74  0E01     MOVLW 0x1
0F76  6FBE     MOVWF M_Ind_Previous_State, BANKED
452:           			M_Ind_LED_blinking(BLINKING_YELLOW, INDEX_OF_BICOLOR_LED);
0F78  6AE6     CLRF POSTINC1, ACCESS
0F7A  0E03     MOVLW 0x3
0F7C  DA66     RCALL __pa_9
453:           			LED_FAN_PIN = OFF;
454:           			M_Ind_view_num_page_menu();
0F7E  D947     RCALL M_Ind_view_num_page_menu
455:           			M_Ind_TimerAutoExit();
456:           		break;
0F80  D006     BRA 0xF8E
457:           		case STATE_VIEW_PARAMETER_MENU :	//отображение параметра меню на выбранной странице (мигаем Ж+З)
458:           			M_Ind_Previous_State = STATE_VIEW_PARAMETER_MENU;
0F82  0E02     MOVLW 0x2
0F84  6FBE     MOVWF M_Ind_Previous_State, BANKED
459:           			M_Ind_LED_blinking(BLINKING_YELLOW, INDEX_OF_BICOLOR_LED);
0F86  6AE6     CLRF POSTINC1, ACCESS
0F88  0E03     MOVLW 0x3
0F8A  DA5F     RCALL __pa_9
460:           			LED_FAN_PIN = OFF;
461:           			M_Ind_view_parameter_menu();
0F8C  D953     RCALL M_Ind_view_parameter_menu
462:           			M_Ind_TimerAutoExit();
0F8E  D919     RCALL M_Ind_TimerAutoExit
463:           		break;
0F90  D076     BRA 0x107E
464:           		case STATE_VIEW_TEMPERATURE_REAL :		//отображение типа топлива и текущей температуры воды в контуре отопления
465:           			M_Ind_Previous_State = STATE_VIEW_TEMPERATURE_REAL;
0F92  0E03     MOVLW 0x3
0F94  6FBE     MOVWF M_Ind_Previous_State, BANKED
466:           			M_Ind_temperature_real();
0F96  D970     RCALL M_Ind_temperature_real
467:           			switch(M_Mngm_Get_state())
0F98  EC0C     CALL 0x1618, 0
0F9A  F00B     NOP
0F9C  0A02     XORLW 0x2
0F9E  E007     BZ 0xFAE
0FA0  0A02     XORLW 0x2
0FA2  E16D     BNZ 0x107E
468:           			{
469:           				case STATE_WAITING:		//мигать 2-цветным светодиодом в режиме "Ожидание"
470:           					M_Ind_LED_blinking(BLINKING_GREEN, INDEX_OF_BICOLOR_LED);
0FA4  6AE6     CLRF POSTINC1, ACCESS
0FA6  0E02     MOVLW 0x2
0FA8  DA50     RCALL __pa_9
471:           					LED_FAN_PIN = OFF;
472:           					LED_BICOLOR_RED_PIN = OFF;
0FAA  988D     BCF LATE, 4, ACCESS
473:           				break;
0FAC  D068     BRA 0x107E
474:           				case STATE_BURNING:		//светить 2-цветным светодиодом в режиме "Горение"
475:           					switch(M_Mngm_get_burning_state())
0FAE  ECF7     CALL 0x15EE, 0
0FB0  F00A     NOP
0FB2  0A05     XORLW 0x5
0FB4  E00F     BZ 0xFD4
0FB6  0A01     XORLW 0x1
0FB8  E00D     BZ 0xFD4
0FBA  0A05     XORLW 0x5
0FBC  E008     BZ 0xFCE
0FBE  0A03     XORLW 0x3
0FC0  E006     BZ 0xFCE
0FC2  0A01     XORLW 0x1
0FC4  E004     BZ 0xFCE
0FC6  0A03     XORLW 0x3
0FC8  E107     BNZ 0xFD8
476:           					{
477:           						case CALC_PARAMS_PERIOD:
478:           							LED_BICOLOR_RED_PIN = OFF;
0FCA  988D     BCF LATE, 4, ACCESS
479:           							LED_BICOLOR_GREEN_PIN = OFF;
480:           						break;
0FCC  D001     BRA 0xFD0
481:           						case START_BURNING:
482:           						case INCREASE_TEMPERATURE:
483:           						case ECONOM_MODE:
484:           							LED_BICOLOR_RED_PIN = ON;
0FCE  888D     BSF LATE, 4, ACCESS
485:           							LED_BICOLOR_GREEN_PIN = OFF;
0FD0  9A8D     BCF LATE, 5, ACCESS
486:           						break;
0FD2  D002     BRA 0xFD8
487:           						case MAINTENANCE_TEMPERATURE_INCR:
488:           						case MAINTENANCE_TEMPERATURE_CYCLE:	
489:           							LED_BICOLOR_RED_PIN = OFF;
0FD4  988D     BCF LATE, 4, ACCESS
490:           							LED_BICOLOR_GREEN_PIN = ON;
0FD6  8A8D     BSF LATE, 5, ACCESS
491:           						break;
492:           					}
493:           					M_Ind_led_fan_mode();
0FD8  DF8E     RCALL M_Ind_led_fan_mode
494:           				break;
495:           			}
496:           		break;
0FDA  D051     BRA 0x107E
497:           		case STATE_VIEW_TEMPERATURE_SETUP :				//отображение мигающего значения устанавливаемого пользователем значения температуры (мигаем К+З)
498:           			M_Ind_Previous_State = STATE_VIEW_TEMPERATURE_SETUP;
0FDC  0E04     MOVLW 0x4
0FDE  6FBE     MOVWF M_Ind_Previous_State, BANKED
499:           			M_Ind_view_temperature_or_fan_level_setup(OFFSET_TO_SYMBOL_t, M_Mngm_Get_parameters_buffer()->menu_parameters.temper_setup);
0FE0  DA10     RCALL __pa_4
0FE2  0E27     MOVLW 0x27
0FE4  DABF     RCALL __pa_36
0FE6  6EE6     MOVWF POSTINC1, ACCESS
0FE8  0E0A     MOVLW 0xA
500:           			M_Ind_LED_blinking(BLINKING_YELLOW, INDEX_OF_BICOLOR_LED);
501:           		break;
0FEA  D008     BRA 0xFFC
502:           		case STATE_VIEW_SPEED_FAN_SETUP:		//отображение мигающего значения устанавливаемого пользователем значения уровня оборотов вентилятора (мигаем К+З)	
503:           			M_Ind_Previous_State = STATE_VIEW_SPEED_FAN_SETUP;
0FEC  0E09     MOVLW 0x9
0FEE  6FBE     MOVWF M_Ind_Previous_State, BANKED
504:           			M_Ind_view_temperature_or_fan_level_setup(OFFSET_TO_SYMBOL_F, (*M_Mngm_get_pFanLevel()) - 1);
0FF0  ECB8     CALL 0x1570, 0
0FF2  F00A     NOP
0FF4  DA70     RCALL __pa_21
0FF6  04EF     DECF INDF0, W, ACCESS
0FF8  6EE6     MOVWF POSTINC1, ACCESS
0FFA  0E0B     MOVLW 0xB
0FFC  6EE6     MOVWF POSTINC1, ACCESS
0FFE  D8C7     RCALL M_Ind_view_temperature_or_fan_level_setup
1000  52E5     MOVF POSTDEC1, F, ACCESS
1002  52E5     MOVF POSTDEC1, F, ACCESS
505:           			M_Ind_LED_blinking(BLINKING_YELLOW, INDEX_OF_BICOLOR_LED);
506:           		break;
1004  D02D     BRA 0x1060
507:           		case STATE_VIEW_PAUSE :								//отображение в режиме "Пауза" (открыта крышка бункера, светим К+З)
508:           			M_Ind_view_text(IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_P, 
1014  0E0B     MOVLW 0xB
509:           			IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_A, IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_U, NEED_BLINK, 0);
1006  6AE6     CLRF POSTINC1, ACCESS
1008  0E01     MOVLW 0x1
100A  6EE6     MOVWF POSTINC1, ACCESS
100C  0E0C     MOVLW 0xC
100E  6EE6     MOVWF POSTINC1, ACCESS
1010  0E0A     MOVLW 0xA
1012  6EE6     MOVWF POSTINC1, ACCESS
510:           			LED_BICOLOR_GREEN_PIN = ON;
511:           			LED_BICOLOR_RED_PIN = ON;
512:           			LED_FAN_PIN = OFF;
513:           			M_Ind_LED_blinking(NO_BLINKING, INDEX_OF_BICOLOR_LED);
514:           		break;
1016  D00A     BRA 0x102C
515:           		case STATE_VIEW_CLEAN_CHIMNEY :					//отображение в режиме "Чистка дымохода" (светим К+З)
516:           			M_Ind_Previous_State = STATE_VIEW_CLEAN_CHIMNEY;
1018  0E06     MOVLW 0x6
101A  6FBE     MOVWF M_Ind_Previous_State, BANKED
517:           			M_Ind_view_text(IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_C, 
102A  0E0E     MOVLW 0xE
102C  DA19     RCALL __pa_11
518:           			IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_L, IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_E, blink_mode, 0);
101C  6AE6     CLRF POSTINC1, ACCESS
101E  C0BF     MOVFF blink_mode, POSTINC1
1020  FFE6     NOP
1022  0E0D     MOVLW 0xD
1024  6EE6     MOVWF POSTINC1, ACCESS
1026  0E0F     MOVLW 0xF
1028  6EE6     MOVWF POSTINC1, ACCESS
519:           			LED_BICOLOR_GREEN_PIN = ON;
102E  8A8D     BSF LATE, 5, ACCESS
520:           			LED_BICOLOR_RED_PIN = ON;
1030  888D     BSF LATE, 4, ACCESS
521:           			LED_FAN_PIN = OFF;
1032  968D     BCF LATE, 3, ACCESS
522:           			M_Ind_LED_blinking(NO_BLINKING, INDEX_OF_BICOLOR_LED);
1034  6AE6     CLRF POSTINC1, ACCESS
1036  6AE6     CLRF POSTINC1, ACCESS
523:           		break;
1038  D016     BRA 0x1066
524:           		case STATE_VIEW_SUPPLY_FUEL :						//отображение в режиме "Загрузка топлива"
525:           			M_Ind_Previous_State = STATE_VIEW_SUPPLY_FUEL;
103A  0E07     MOVLW 0x7
103C  6FBE     MOVWF M_Ind_Previous_State, BANKED
526:           			M_Ind_view_text(IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_S, 
104C  0E10     MOVLW 0x10
104E  DA08     RCALL __pa_11
527:           			IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_U, IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_P, blink_mode, 0);
103E  6AE6     CLRF POSTINC1, ACCESS
1040  C0BF     MOVFF blink_mode, POSTINC1
1042  FFE6     NOP
1044  0E0B     MOVLW 0xB
1046  6EE6     MOVWF POSTINC1, ACCESS
1048  0E0C     MOVLW 0xC
104A  6EE6     MOVWF POSTINC1, ACCESS
528:           			if(M_Motor_get_direction() == TIME_PAUSE_DISPENSER || M_Motor_get_direction() == TIME_PAUSE_SHATTER)
1050  ECC6     CALL 0x18C, 0
1052  F000     NOP
1054  0803     SUBLW 0x3
1056  E004     BZ 0x1060
1058  ECC6     CALL 0x18C, 0
105A  F000     NOP
105C  0806     SUBLW 0x6
105E  E105     BNZ 0x106A
529:           				M_Ind_LED_blinking(BLINKING_YELLOW, INDEX_OF_BICOLOR_LED); 
1060  6AE6     CLRF POSTINC1, ACCESS
1062  0E03     MOVLW 0x3
1064  6EE6     MOVWF POSTINC1, ACCESS
1066  DA3F     RCALL __pa_23
530:           			else
1068  D00A     BRA 0x107E
531:           			{
532:           				M_Ind_LED_blinking(NO_BLINKING, INDEX_OF_BICOLOR_LED);
106A  6AE6     CLRF POSTINC1, ACCESS
106C  6AE6     CLRF POSTINC1, ACCESS
106E  DA3B     RCALL __pa_23
533:           				LED_BICOLOR_GREEN_PIN = ON;
1070  8A8D     BSF LATE, 5, ACCESS
534:           				LED_BICOLOR_RED_PIN = ON;
1072  888D     BSF LATE, 4, ACCESS
535:           			}
536:           		break;
1074  D004     BRA 0x107E
537:           		case STATE_VIEW_FAILURE :						//отображение в режиме "Авария "
538:           			M_Ind_view_failure();
1076  D833     RCALL M_Ind_view_failure
539:           			M_Ind_LED_blinking(BLINKING_RED, INDEX_OF_BICOLOR_LED);
1078  6AE6     CLRF POSTINC1, ACCESS
107A  0E01     MOVLW 0x1
107C  D9E6     RCALL __pa_9
144A  6EE6     MOVWF POSTINC1, ACCESS
144C  D84C     RCALL __pa_23
14E6  DF27     RCALL M_Ind_LED_blinking
14E8  52E5     MOVF POSTDEC1, F, ACCESS
14EA  52E5     MOVF POSTDEC1, F, ACCESS
14EC  0012     RETURN 0
540:           			LED_FAN_PIN = OFF;
144E  968D     BCF LATE, 3, ACCESS
1450  0012     RETURN 0
541:           		break;
542:           		//default:
543:           	}
544:           	M_Ind_7_Segment_Out();
107E  EFA8     GOTO 0xD50
1080  F006     NOP
545:           }
546:           
547:           /*Отображение текстовых символов на индикаторе */
548:           static void M_Ind_view_text(const uint8_t left_ind_offset_to_symb, const uint8_t middle_ind_offset_to_symb, 
1082  D9C7     RCALL __pa_6
1084  52E6     MOVF POSTINC1, F, ACCESS
549:           						const uint8_t right_ind_offset_to_symb, BOOL need_blink, uint8_t numInd)
550:           {
551:           	uint8_t i;
552:               
553:               if(M_Mngm_Get_Code_Failure() != CODE_FAILURE_IS_NO_FAILURE)
1086  DA01     RCALL __pa_15
1088  E002     BZ 0x108E
554:           		M_Ind_State = STATE_VIEW_FAILURE;
108A  DA11     RCALL __pa_18
555:           	else
108C  D026     BRA 0x10DA
556:           	{
557:                   M_Ind_data[numInd].index_of_text_sym[LEFT_INDICATOR] = left_ind_offset_to_symb;
108E  0EFA     MOVLW 0xFA
1090  D9A7     RCALL __pa_0
1092  52EE     MOVF POSTINC0, F, ACCESS
1094  0EFE     MOVLW 0xFE
1096  DA3E     RCALL __pa_28
1514  CFDB     MOVFF PLUSW2, INDF0
1516  FFEF     NOP
558:                   M_Ind_data[numInd].index_of_text_sym[MIDDLE_INDICATOR] = middle_ind_offset_to_symb;
1098  0E01     MOVLW 0x1
109A  D9A4     RCALL __pa_1
109C  0EFD     MOVLW 0xFD
109E  DA3A     RCALL __pa_28
1518  0EFA     MOVLW 0xFA
151A  DF62     RCALL __pa_0
151C  52EE     MOVF POSTINC0, F, ACCESS
151E  0012     RETURN 0
559:                   M_Ind_data[numInd].index_of_text_sym[RIGHT_INDICATOR] = right_ind_offset_to_symb;
10A0  DA49     RCALL __pa_31
10A2  0EFC     MOVLW 0xFC
10A4  CFDB     MOVFF PLUSW2, INDF0
10A6  FFEF     NOP
560:                   M_Ind_data[numInd].dot[LEFT_INDICATOR] = M_Ind_data[numInd].const_dot[INDEX_NO_DOT];
10A8  DA0A     RCALL __pa_20
10AA  D9EB     RCALL __pa_14
561:                   M_Ind_data[numInd].dot[MIDDLE_INDICATOR] = M_Ind_data[numInd].const_dot[INDEX_NO_DOT];
10AC  DA08     RCALL __pa_20
10AE  0E01     MOVLW 0x1
10B0  D999     RCALL __pa_1
10B2  D9E7     RCALL __pa_14
562:                   M_Ind_data[numInd].dot[RIGHT_INDICATOR] = M_Ind_data[numInd].const_dot[INDEX_NO_DOT];
10B4  DA04     RCALL __pa_20
10B6  DA3E     RCALL __pa_31
10B8  D9E4     RCALL __pa_14
14BE  0EFA     MOVLW 0xFA
14C0  DF8F     RCALL __pa_0
14C2  0E0A     MOVLW 0xA
14C4  DF8F     RCALL __pa_1
14C6  0E01     MOVLW 0x1
14C8  D84D     RCALL __pa_36
14CA  6EE6     MOVWF POSTINC1, ACCESS
14CC  0EFA     MOVLW 0xFA
14CE  DF88     RCALL __pa_0
14D0  0E07     MOVLW 0x7
14D2  EFF2     GOTO 0x13E4
14D4  F009     NOP
1564  DF3F     RCALL __pa_1
1566  50EF     MOVF INDF0, W, ACCESS
1568  0012     RETURN 0
563:                   M_Ind_blinking_7segm(LEFT_SYMBOL_NO_DOT, need_blink, numInd);
10BA  0EFA     MOVLW 0xFA
10BC  CFDB     MOVFF PLUSW2, POSTINC1
10BE  FFE6     NOP
10C0  0EFB     MOVLW 0xFB
10C2  CFDB     MOVFF PLUSW2, POSTINC1
10C4  FFE6     NOP
10C6  6AE6     CLRF POSTINC1, ACCESS
10C8  D823     RCALL M_Ind_blinking_7segm
10CA  52E5     MOVF POSTDEC1, F, ACCESS
10CC  52E5     MOVF POSTDEC1, F, ACCESS
10CE  52E5     MOVF POSTDEC1, F, ACCESS
564:                   M_Ind_bin2dec(IT_IS_A_TEXT_SYM_AREA, numInd);
10D0  0EFA     MOVLW 0xFA
10D2  CFDB     MOVFF PLUSW2, POSTINC1
10D4  FFE6     NOP
10D6  0E0A     MOVLW 0xA
10D8  D989     RCALL __pa_2
565:               }
566:           }
10DA  52E5     MOVF POSTDEC1, F, ACCESS
10DC  D196     BRA __pa_5
567:           
568:           /*Индикация в режиме "Авария" */
569:           void M_Ind_view_failure(void)
570:           {
571:           	if(M_Mngm_Get_Code_Failure() == CODE_FAILURE_IS_NO_FAILURE)
10DE  D9D5     RCALL __pa_15
10E0  E103     BNZ 0x10E8
572:           		M_Ind_State = M_Ind_Previous_State;
10E2  C0BE     MOVFF M_Ind_Previous_State, M_Ind_State
10E4  F0BD     NOP
573:           	else
10E6  0012     RETURN 0
574:           	{
575:           		M_Ind_data[0].index_of_text_sym[LEFT_INDICATOR] = IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_E; 
10E8  0100     MOVLB 0x0
10EA  0E0D     MOVLW 0xD
10EC  6F9E     MOVWF 0x9E, BANKED
576:           		M_Ind_data[0].index_of_text_sym[MIDDLE_INDICATOR] = M_Ind_data[0].index_of_text_sym[RIGHT_INDICATOR] = 0;
10EE  6BA0     CLRF 0xA0, BANKED
10F0  C0A0     MOVFF 0xA0, 0x9F
10F2  F09F     NOP
577:           		M_Ind_data[0].dot[LEFT_INDICATOR] = M_Ind_data[0].const_dot[INDEX_IS_DOT];
10F4  C0A7     MOVFF 0xA7, 0xA4
10F6  F0A4     NOP
578:           		M_Ind_data[0].dot[MIDDLE_INDICATOR] = M_Ind_data[0].const_dot[INDEX_NO_DOT];
10F8  C0A8     MOVFF 0xA8, 0xA5
10FA  F0A5     NOP
579:                   M_Ind_data[0].dot[RIGHT_INDICATOR] = M_Ind_data[0].const_dot[INDEX_NO_DOT];
10FC  C0A8     MOVFF 0xA8, 0xA6
10FE  F0A6     NOP
580:                   M_Ind_blinking_7segm(LEFT_SYMBOL_WITH_DOT, NEED_BLINK, 0);
1100  6AE6     CLRF POSTINC1, ACCESS
1102  0E01     MOVLW 0x1
1104  D9B4     RCALL __pa_12
581:           		M_Ind_bin2dec(M_Mngm_Get_Code_Failure(), 0);	
1106  6AE6     CLRF POSTINC1, ACCESS
1108  EC0F     CALL 0x161E, 0
110A  F00B     NOP
110C  EFF6     GOTO 0x13EC
110E  F009     NOP
582:           	}	
583:           }
584:           
585:           
586:           //Реализация мигания символов
587:           static void M_Ind_blinking_7segm(BOOL state_left_symbol_dot, BOOL need_blink, uint8_t numInd)
1110  D9FB     RCALL __pa_26
588:           {	
589:           	if(state_left_symbol_dot) //если в мигании участвует левое из 3-х знакомест с точкой
1112  50DB     MOVF PLUSW2, W, ACCESS
1114  E012     BZ 0x113A
590:           		M_Ind_data[numInd].dot[LEFT_INDICATOR] = M_Ind_data[numInd].const_dot[M_Ind_data[numInd].Flag_Blink_seven_segm];
1116  DA04     RCALL __pa_29
1118  CFE9     MOVFF FSR0, __tmp_0
111A  F032     NOP
111C  CFEA     MOVFF FSR0H, 0x33
111E  F033     NOP
1120  DA0C     RCALL __pa_32
1122  CFEF     MOVFF INDF0, 0x34
1124  F034     NOP
1126  6A35     CLRF 0x35, ACCESS
1128  BE34     BTFSC 0x34, 7, ACCESS
112A  6835     SETF 0x35, ACCESS
112C  5032     MOVF __tmp_0, W, ACCESS
112E  2434     ADDWF 0x34, W, ACCESS
1130  6EE9     MOVWF FSR0, ACCESS
1132  5033     MOVF 0x33, W, ACCESS
1134  2035     ADDWFC 0x35, W, ACCESS
1136  6EEA     MOVWF FSR0H, ACCESS
1520  D80C     RCALL __pa_32
1522  0E0A     MOVLW 0xA
1524  EFF2     GOTO 0x13E4
1526  F009     NOP
591:           	else
1138  D005     BRA 0x1144
592:           		M_Ind_data[numInd].dot[LEFT_INDICATOR] = M_Ind_data[numInd].const_dot[INDEX_NO_DOT];
113A  D9F2     RCALL __pa_29
113C  0E01     MOVLW 0x1
113E  26E9     ADDWF FSR0, F, ACCESS
1140  0E00     MOVLW 0x0
1142  22EA     ADDWFC FSR0H, F, ACCESS
1144  50EF     MOVF INDF0, W, ACCESS
1146  6EE6     MOVWF POSTINC1, ACCESS
1148  D9F8     RCALL __pa_32
114A  0E07     MOVLW 0x7
114C  D94B     RCALL __pa_1
114E  D999     RCALL __pa_14
593:           	if(need_blink)
1150  0EFD     MOVLW 0xFD
1152  50DB     MOVF PLUSW2, W, ACCESS
1154  E019     BZ 0x1188
594:           	{
595:           		if(time_M_Ind.time_blink++ == M_Ind_time_const[e_Time_Blink])
1156  0100     MOVLB 0x0
1158  C0B7     MOVFF 0xB7, __tmp_0
115A  F032     NOP
115C  C0B8     MOVFF 0xB8, 0x33
115E  F033     NOP
1160  2BB7     INCF 0xB7, F, BANKED
1162  0E00     MOVLW 0x0
1164  23B8     ADDWFC 0xB8, F, BANKED
1166  D975     RCALL __pa_10
1168  E111     BNZ 0x118C
116A  5035     MOVF 0x35, W, ACCESS
116C  1833     XORWF 0x33, W, ACCESS
116E  E10E     BNZ 0x118C
1452  0EFA     MOVLW 0xFA
1454  6EF6     MOVWF TBLPTR, ACCESS
1456  0E35     MOVLW 0x35
1458  D84F     RCALL __pa_25
145A  5034     MOVF 0x34, W, ACCESS
145C  1832     XORWF __tmp_0, W, ACCESS
145E  0012     RETURN 0
596:           		{
597:           			time_M_Ind.time_blink = 0;
1170  6BB7     CLRF 0xB7, BANKED
1172  6BB8     CLRF 0xB8, BANKED
598:           			M_Ind_data[numInd].Flag_Blink_seven_segm = !M_Ind_data[numInd].Flag_Blink_seven_segm;
1174  D9E2     RCALL __pa_32
1176  50EF     MOVF INDF0, W, ACCESS
1178  E002     BZ 0x117E
117A  0E00     MOVLW 0x0
117C  D001     BRA 0x1180
117E  0E01     MOVLW 0x1
1180  6EE6     MOVWF POSTINC1, ACCESS
1182  D9DB     RCALL __pa_32
1184  D97E     RCALL __pa_14
13E0  50DB     MOVF PLUSW2, W, ACCESS
13E2  D0B5     BRA __pa_34
1482  52E5     MOVF POSTDEC1, F, ACCESS
1484  50E7     MOVF INDF1, W, ACCESS
1486  6EEF     MOVWF INDF0, ACCESS
1488  0012     RETURN 0
153A  0EFC     MOVLW 0xFC
153C  EFF0     GOTO 0x13E0
153E  F009     NOP
154E  0D0C     MULLW 0xC
1550  DFC2     RCALL __pa_21
1552  0E9D     MOVLW 0x9D
1554  26E9     ADDWF FSR0, F, ACCESS
1556  0E00     MOVLW 0x0
1558  22EA     ADDWFC FSR0H, F, ACCESS
155A  0012     RETURN 0
599:           		}
600:           	}	
601:           	else
1186  D002     BRA 0x118C
602:           		M_Ind_data[numInd].Flag_Blink_seven_segm = OFF;
1188  D9D8     RCALL __pa_32
118A  6AEF     CLRF INDF0, ACCESS
603:           }
118C  D13E     BRA __pa_5
604:           
605:           /* Отображение в режиме "Индикация установленной температуры", "Индикация установленных оборотов вентилятора" */
606:           static void M_Ind_view_temperature_or_fan_level_setup(const uint8_t offset_to_symb, uint8_t parameter)
118E  D941     RCALL __pa_6
607:           {
608:           	if(M_Mngm_Get_Code_Failure() != CODE_FAILURE_IS_NO_FAILURE)
1190  D97C     RCALL __pa_15
1192  E002     BZ 0x1198
609:           		M_Ind_State = STATE_VIEW_FAILURE;
1194  D98C     RCALL __pa_18
610:           	else
1196  D00E     BRA 0x11B4
611:           	{
612:           		M_Ind_data[1].index_of_text_sym[LEFT_INDICATOR] = IT_IS_A_TEXT_SYM_AREA + offset_to_symb; 
1198  0EFE     MOVLW 0xFE
119A  CFDB     MOVFF PLUSW2, __tmp_0
119C  F032     NOP
119E  0E0A     MOVLW 0xA
11A0  2432     ADDWF __tmp_0, W, ACCESS
11A2  0100     MOVLB 0x0
11A4  D976     RCALL __pa_16
1492  6FAA     MOVWF 0xAA, BANKED
613:           		M_Ind_data[1].index_of_text_sym[MIDDLE_INDICATOR] = M_Ind_data[1].index_of_text_sym[RIGHT_INDICATOR] = 0;
1494  6BAC     CLRF 0xAC, BANKED
1496  C0AC     MOVFF 0xAC, 0xAB
1498  F0AB     NOP
614:           		M_Ind_blinking_7segm(LEFT_SYMBOL_WITH_DOT, NEED_BLINK, 1);
11A6  D963     RCALL __pa_12
149A  0E01     MOVLW 0x1
149C  6EE6     MOVWF POSTINC1, ACCESS
149E  0012     RETURN 0
615:           		M_Ind_bin2dec(parameter, 1);
11A8  0E01     MOVLW 0x1
11AA  6EE6     MOVWF POSTINC1, ACCESS
11AC  0EFD     MOVLW 0xFD
11AE  CFDB     MOVFF PLUSW2, POSTINC1
11B0  FFE6     NOP
11B2  D9BA     RCALL __pa_30
1528  6AE6     CLRF POSTINC1, ACCESS
152A  DC6D     RCALL M_Ind_bin2dec
152C  52E5     MOVF POSTDEC1, F, ACCESS
152E  52E5     MOVF POSTDEC1, F, ACCESS
1530  52E5     MOVF POSTDEC1, F, ACCESS
1532  0012     RETURN 0
616:           	}
617:           }
11B4  D12A     BRA __pa_5
618:           
619:           /* Установка счётчикак таймера автовыхода по енажатию ни на одну из кнопок в меню*/
620:           void M_Ind_setTimeAutoExit( uint8_t value )
11B6  D9A8     RCALL __pa_26
621:           {
622:           	time_M_Ind.time_auto_exit = value;
11B8  50DB     MOVF PLUSW2, W, ACCESS
11BA  0100     MOVLB 0x0
11BC  6FB9     MOVWF 0xB9, BANKED
11BE  6BBA     CLRF 0xBA, BANKED
623:           }
11C0  D124     BRA __pa_5
624:           
625:           /* Организация таймера автовыхода по ненажатию ни на одну из кнопок в меню */
626:           void M_Ind_TimerAutoExit( void )
627:           {
628:           	//Организация автоматического выхода по таймеру, если не нажата ни одна из кнопок
629:           	if(time_M_Ind.time_auto_exit++ == (M_Mngm_Get_parameters_buffer()->menu_parameters.time_auto_exit) * 1000U)
11C2  0100     MOVLB 0x0
11C4  C0B9     MOVFF 0xB9, __tmp_0
11C6  F032     NOP
11C8  C0BA     MOVFF 0xBA, 0x33
11CA  F033     NOP
11CC  2BB9     INCF 0xB9, F, BANKED
11CE  0E00     MOVLW 0x0
11D0  23BA     ADDWFC 0xBA, F, BANKED
11D2  C032     MOVFF __tmp_0, POSTINC1
11D4  FFE6     NOP
11D6  C033     MOVFF 0x33, POSTINC1
11D8  FFE6     NOP
11DA  ECFE     CALL 0x15FC, 0
11DC  F00A     NOP
11DE  D960     RCALL __pa_17
11E0  D97A     RCALL __pa_21
11E2  0E2A     MOVLW 0x2A
11E4  D9BF     RCALL __pa_36
11E6  6E34     MOVWF 0x34, ACCESS
11E8  6A35     CLRF 0x35, ACCESS
11EA  D91E     RCALL __pa_8
11EC  E10F     BNZ 0x120C
11EE  5035     MOVF 0x35, W, ACCESS
11F0  1833     XORWF 0x33, W, ACCESS
11F2  E10C     BNZ 0x120C
1428  0EE8     MOVLW 0xE8
142A  0235     MULWF 0x35, ACCESS
142C  CFF3     MOVFF PROD, 0x35
142E  F035     NOP
1430  0E03     MOVLW 0x3
1432  0234     MULWF 0x34, ACCESS
1434  50F3     MOVF PROD, W, ACCESS
1436  2635     ADDWF 0x35, F, ACCESS
1438  0EE8     MOVLW 0xE8
143A  0234     MULWF 0x34, ACCESS
143C  CFF3     MOVFF PROD, 0x34
143E  F034     NOP
1440  50F4     MOVF PRODH, W, ACCESS
1442  2635     ADDWF 0x35, F, ACCESS
1444  50F3     MOVF PROD, W, ACCESS
1446  1832     XORWF __tmp_0, W, ACCESS
1448  0012     RETURN 0
14A0  52E5     MOVF POSTDEC1, F, ACCESS
14A2  CFE7     MOVFF INDF1, 0x33
14A4  F033     NOP
14A6  52E5     MOVF POSTDEC1, F, ACCESS
14A8  CFE7     MOVFF INDF1, __tmp_0
14AA  F032     NOP
14AC  0012     RETURN 0
630:           	{
631:           		time_M_Ind.time_auto_exit = 0;
11F4  0100     MOVLB 0x0
11F6  6BB9     CLRF 0xB9, BANKED
11F8  6BBA     CLRF 0xBA, BANKED
632:           		if((M_LI_Get_Key_State()->M_LI_Code_Key) == 0U) //если по истечении времени автовыхода не нажата ни одна из кнопок
11FA  EC5B     CALL 0x26B6, 0
11FC  F013     NOP
11FE  D96B     RCALL __pa_21
1200  D999     RCALL __pa_31
1202  50EF     MOVF INDF0, W, ACCESS
1204  E103     BNZ 0x120C
1534  0E02     MOVLW 0x2
1536  EFF2     GOTO 0x13E4
1538  F009     NOP
633:           			M_Ind_State = STATE_VIEW_TEMPERATURE_REAL;	
1206  0100     MOVLB 0x0
1208  0E03     MOVLW 0x3
120A  6FBD     MOVWF M_Ind_State, BANKED
634:           	}
635:           }
120C  0012     RETURN 0
636:           
637:           /* Отображение номера страницы инженерного меню  */
638:           static void M_Ind_view_num_page_menu(void) 
639:           {
640:           	if(M_Mngm_Get_Code_Failure() != CODE_FAILURE_IS_NO_FAILURE)
120E  D93D     RCALL __pa_15
1210  E004     BZ 0x121A
641:           	{
642:           		M_Ind_State = STATE_VIEW_FAILURE;
1212  D94D     RCALL __pa_18
643:           		time_M_Ind.time_auto_exit = 0;
1214  6BB9     CLRF 0xB9, BANKED
1216  6BBA     CLRF 0xBA, BANKED
644:           	}
645:           	else
1218  0012     RETURN 0
646:           	{
647:           		M_Ind_data[0].index_of_text_sym[LEFT_INDICATOR] = IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_P; 	
121A  0100     MOVLB 0x0
121C  0E0B     MOVLW 0xB
121E  6F9E     MOVWF 0x9E, BANKED
648:           		M_Ind_data[0].index_of_text_sym[MIDDLE_INDICATOR] = M_Ind_data[0].index_of_text_sym[RIGHT_INDICATOR] = 0;
1220  6BA0     CLRF 0xA0, BANKED
1222  C0A0     MOVFF 0xA0, 0x9F
1224  F09F     NOP
649:           		M_Ind_bin2dec(Menu_Get_Num_Page_Menu(), 0);
1226  6AE6     CLRF POSTINC1, ACCESS
1228  EC6A     CALL 0x1CD4, 0
122A  F00E     NOP
122C  D8DF     RCALL __pa_2
650:           		M_Ind_data[0].dot[LEFT_INDICATOR] = M_Ind_data[0].const_dot[INDEX_IS_DOT];
122E  C0A7     MOVFF 0xA7, 0xA4
1230  F0A4     NOP
651:           	}
652:           }
1232  0012     RETURN 0
653:           
654:           /* Отображение параметра инженерного меню, подлежащего изменению и сохранению */
655:           static void M_Ind_view_parameter_menu(void)
656:           {
657:           	
658:           	if(M_Mngm_Get_Code_Failure() != CODE_FAILURE_IS_NO_FAILURE)
1234  D92A     RCALL __pa_15
1236  E002     BZ 0x123C
659:           		M_Ind_State = STATE_VIEW_FAILURE;
1238  EF57     GOTO 0x14AE
123A  F00A     NOP
660:           	else
661:           	{
662:           		M_Ind_data[1].dot[LEFT_INDICATOR] = NO_DOT;
123C  0100     MOVLB 0x0
123E  69B0     SETF 0xB0, BANKED
663:           		M_Ind_data[1].index_of_text_sym[LEFT_INDICATOR] = M_Ind_data[1].index_of_text_sym[MIDDLE_INDICATOR]
664:           		= M_Ind_data[1].index_of_text_sym[RIGHT_INDICATOR] = 0; //в этом режиме выводятся только цифры
1240  6BAC     CLRF 0xAC, BANKED
1242  C0AC     MOVFF 0xAC, 0xAB
1244  F0AB     NOP
1246  C0AC     MOVFF 0xAC, 0xAA
1248  F0AA     NOP
665:           		M_Ind_bin2dec(M_Mngm_Get_parameters_buffer()->buffer[Menu_Get_Num_Page_Menu()], 1);
124A  0E01     MOVLW 0x1
124C  6EE6     MOVWF POSTINC1, ACCESS
124E  D8D9     RCALL __pa_4
1250  CFF3     MOVFF PROD, __tmp_0
1252  F032     NOP
1254  CFF4     MOVFF PRODH, 0x33
1256  F033     NOP
1258  CFF3     MOVFF PROD, POSTINC1
125A  FFE6     NOP
125C  CFF4     MOVFF PRODH, POSTINC1
125E  FFE6     NOP
1260  EC6A     CALL 0x1CD4, 0
1262  F00E     NOP
1264  D91D     RCALL __pa_17
1266  010F     MOVLB 0xF
1268  2432     ADDWF __tmp_0, W, ACCESS
126A  6EE9     MOVWF FSR0, ACCESS
126C  0E00     MOVLW 0x0
126E  2033     ADDWFC 0x33, W, ACCESS
1270  6EEA     MOVWF FSR0H, ACCESS
1272  50EF     MOVF INDF0, W, ACCESS
1274  EFF6     GOTO 0x13EC
1276  F009     NOP
666:           	}
667:           }
668:           
669:           /* Вывод на индикатор температуры воды и типа топлива с точкой */
670:           static void M_Ind_temperature_real(void)
671:           {
672:           	if(M_Mngm_Get_Code_Failure() != CODE_FAILURE_IS_NO_FAILURE)
1278  D908     RCALL __pa_15
127A  E002     BZ 0x1280
148A  EC0F     CALL 0x161E, 0
148C  F00B     NOP
148E  0900     IORLW 0x0
1490  0012     RETURN 0
673:           	    M_Ind_State = STATE_VIEW_FAILURE;
127C  EF57     GOTO 0x14AE
127E  F00A     NOP
14AE  0100     MOVLB 0x0
14B0  0E08     MOVLW 0x8
14B2  6FBD     MOVWF M_Ind_State, BANKED
14B4  0012     RETURN 0
674:           	else
675:           	{	
676:           		M_Ind_data[0].index_of_text_sym[MIDDLE_INDICATOR] = M_Ind_data[0].index_of_text_sym[RIGHT_INDICATOR] = 0; 
1280  0100     MOVLB 0x0
1282  6BA0     CLRF 0xA0, BANKED
1284  C0A0     MOVFF 0xA0, 0x9F
1286  F09F     NOP
677:           		if(Menu_get_temper_water_or_gas())
1288  EC67     CALL 0x1CCE, 0
128A  F00E     NOP
128C  0900     IORLW 0x0
128E  E007     BZ 0x129E
678:           		{
679:           			M_Ind_data[0].index_of_text_sym[LEFT_INDICATOR] = IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_d;
1290  0100     MOVLB 0x0
1292  0E16     MOVLW 0x16
1294  6F9E     MOVWF 0x9E, BANKED
680:           			M_Ind_bin2dec(M_AI_Get_ADC_Data(CHN_T_GAS)->param, 0);
1296  6AE6     CLRF POSTINC1, ACCESS
1298  6AE6     CLRF POSTINC1, ACCESS
129A  D952     RCALL __pa_33
1540  EC8C     CALL 0x2318, 0
1542  F011     NOP
1544  52E5     MOVF POSTDEC1, F, ACCESS
1546  DFC7     RCALL __pa_21
1548  0E05     MOVLW 0x5
154A  EF70     GOTO 0x14E0
154C  F00A     NOP
681:           		}
682:           		else
129C  D013     BRA 0x12C4
683:           		{
684:           			M_Ind_bin2dec(M_AI_Get_ADC_Data(CHN_T_WATER)->param, 0);
129E  6AE6     CLRF POSTINC1, ACCESS
12A0  0E01     MOVLW 0x1
12A2  6EE6     MOVWF POSTINC1, ACCESS
12A4  D94D     RCALL __pa_33
685:           			M_Ind_data[0].index_of_text_sym[LEFT_INDICATOR] = M_Mngm_Get_parameters_buffer()->menu_parameters.fuel_type 
12A6  D8AD     RCALL __pa_4
12A8  0E28     MOVLW 0x28
12AA  D95C     RCALL __pa_36
686:           				+ INDEX_OF_AREA_FUEL_TYPE;
12AC  6E32     MOVWF __tmp_0, ACCESS
12AE  6A33     CLRF 0x33, ACCESS
12B0  0E18     MOVLW 0x18
12B2  2632     ADDWF __tmp_0, F, ACCESS
12B4  0E00     MOVLW 0x0
12B6  2233     ADDWFC 0x33, F, ACCESS
12B8  0E07     MOVLW 0x7
12BA  5E32     SUBWF __tmp_0, F, ACCESS
12BC  0E00     MOVLW 0x0
12BE  5A33     SUBWFB 0x33, F, ACCESS
12C0  C032     MOVFF __tmp_0, 0x9E
12C2  F09E     NOP
687:           		}
688:           		M_Ind_data[0].dot[LEFT_INDICATOR] = M_Ind_data[1].dot[LEFT_INDICATOR] = M_Ind_data[0].const_dot[INDEX_IS_DOT];
12C4  C0A7     MOVFF 0xA7, 0xB0
12C6  F0B0     NOP
12C8  C0A7     MOVFF 0xA7, 0xA4
12CA  F0A4     NOP
689:           		M_Ind_data[0].Flag_Blink_seven_segm = M_Ind_data[1].Flag_Blink_seven_segm = FALSE;
12CC  0100     MOVLB 0x0
12CE  6BA9     CLRF 0xA9, BANKED
12D0  C0A9     MOVFF 0xA9, M_Ind_data
12D2  F09D     NOP
690:                   M_Ind_data[1].index_of_text_sym[LEFT_INDICATOR] = IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_t; 
12D4  0E14     MOVLW 0x14
12D6  D8DD     RCALL __pa_16
691:           		M_Ind_data[1].index_of_text_sym[MIDDLE_INDICATOR] = M_Ind_data[1].index_of_text_sym[RIGHT_INDICATOR] = 0;
692:           		M_Ind_bin2dec(M_Mngm_Get_parameters_buffer()->menu_parameters.temper_setup, 1);
12D8  D894     RCALL __pa_4
12DA  0E27     MOVLW 0x27
12DC  EF70     GOTO 0x14E0
12DE  F00A     NOP
1402  ECFE     CALL 0x15FC, 0
1404  F00A     NOP
1406  EF6B     GOTO 0x14D6
1408  F00A     NOP
693:               }
694:           }
695:           
696:           /* Отображение номера версии ПО по старту программы  */
697:           static void M_Ind_View_SW_version(void)
698:           {
699:           	//Проверка - прошло ли время инициализации модуля индикации
700:           	if(time_M_Ind.time_init++ == M_Ind_time_const[e_Time_Init]*1000U)
12E0  0100     MOVLB 0x0
12E2  C0B5     MOVFF time_M_Ind, __tmp_0
12E4  F032     NOP
12E6  C0B6     MOVFF 0xB6, 0x33
12E8  F033     NOP
12EA  2BB5     INCF time_M_Ind, F, BANKED
12EC  0E00     MOVLW 0x0
12EE  23B6     ADDWFC 0xB6, F, BANKED
12F0  0EF8     MOVLW 0xF8
12F2  6EF6     MOVWF TBLPTR, ACCESS
12F4  0E35     MOVLW 0x35
12F6  D900     RCALL __pa_25
12F8  D897     RCALL __pa_8
12FA  E10A     BNZ 0x1310
12FC  5035     MOVF 0x35, W, ACCESS
12FE  1833     XORWF 0x33, W, ACCESS
1300  E107     BNZ 0x1310
14F8  6EF7     MOVWF TBLPTRH, ACCESS
14FA  0009     TBLRD*+
14FC  CFF5     MOVFF TABLAT, 0x34
14FE  F034     NOP
1500  0008     TBLRD*
1502  CFF5     MOVFF TABLAT, 0x35
1504  F035     NOP
1506  0012     RETURN 0
701:           	{
702:           		time_M_Ind.time_init = 0;
1302  6BB5     CLRF time_M_Ind, BANKED
1304  6BB6     CLRF 0xB6, BANKED
703:           		M_Ind_data[0].Flag_Blink_seven_segm = FALSE;
1306  6B9D     CLRF M_Ind_data, BANKED
704:           		M_Ind_data[0].dot[LEFT_INDICATOR] = NO_DOT;
1308  69A4     SETF 0xA4, BANKED
705:           		M_Ind_State = STATE_VIEW_TEMPERATURE_REAL;
130A  0E03     MOVLW 0x3
130C  6FBD     MOVWF M_Ind_State, BANKED
706:           		//разрешить внешние прерывания INT2 (для детектирования переходов через нуль сетевого напряжения) 
707:           		//INTCON3 = 0xD8;		//и INT1 (для опроса датчика ворошителя)
708:           	}
709:           	else //иначе мигаем версией программного обеспечения
130E  0012     RETURN 0
710:           	{
711:           		M_Ind_blinking_7segm(LEFT_SYMBOL_WITH_DOT, NEED_BLINK, 0);
1310  6AE6     CLRF POSTINC1, ACCESS
1312  0E01     MOVLW 0x1
1314  D8AC     RCALL __pa_12
146E  6EE6     MOVWF POSTINC1, ACCESS
1470  6EE6     MOVWF POSTINC1, ACCESS
1472  DE4E     RCALL M_Ind_blinking_7segm
1474  52E5     MOVF POSTDEC1, F, ACCESS
1476  52E5     MOVF POSTDEC1, F, ACCESS
1478  52E5     MOVF POSTDEC1, F, ACCESS
147A  0012     RETURN 0
712:           		M_Ind_bin2dec(M_Mngm_Get_parameters_buffer()->menu_parameters.software_version, 0);
1316  6AE6     CLRF POSTINC1, ACCESS
1318  D874     RCALL __pa_4
131A  0E34     MOVLW 0x34
131C  D8E1     RCALL __pa_22
13E4  26E9     ADDWF FSR0, F, ACCESS
13E6  0E00     MOVLW 0x0
13E8  22EA     ADDWFC FSR0H, F, ACCESS
13EA  0012     RETURN 0
13EC  6EE6     MOVWF POSTINC1, ACCESS
13EE  EF94     GOTO 0x1528
13F0  F00A     NOP
14E0  D841     RCALL __pa_36
14E2  EFF6     GOTO 0x13EC
14E4  F009     NOP
713:                   M_Ind_view_text(IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_S, 
132C  0E10     MOVLW 0x10
132E  D898     RCALL __pa_11
1460  6EE6     MOVWF POSTINC1, ACCESS
714:           			IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_F, IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_L, NO_NEED_BLINK, 1);
131E  0E01     MOVLW 0x1
1320  6EE6     MOVWF POSTINC1, ACCESS
1322  6AE6     CLRF POSTINC1, ACCESS
1324  0E0F     MOVLW 0xF
1326  6EE6     MOVWF POSTINC1, ACCESS
1328  0E15     MOVLW 0x15
132A  6EE6     MOVWF POSTINC1, ACCESS
1462  DE0F     RCALL M_Ind_view_text
1464  6E32     MOVWF __tmp_0, ACCESS
1466  0E05     MOVLW 0x5
1468  5EE1     SUBWF FSR1, F, ACCESS
146A  5032     MOVF __tmp_0, W, ACCESS
146C  0012     RETURN 0
715:           		M_Ind_State = STATE_IND_INIT;		
1330  0100     MOVLB 0x0
1332  6BBD     CLRF M_Ind_State, BANKED
716:           	}
717:           }
1334  0012     RETURN 0
718:           
719:           /* Мигание светодиодов  */
720:           static void M_Ind_LED_blinking(uint8_t action, const uint8_t index)
1336  D8E8     RCALL __pa_26
1412  CFD9     MOVFF FSR2, POSTINC1
1414  FFE6     NOP
1416  CFE1     MOVFF FSR1, FSR2
1418  FFD9     NOP
141A  0012     RETURN 0
1508  DF84     RCALL __pa_6
721:           {
722:           	if(action != NO_BLINKING)
1338  50DB     MOVF PLUSW2, W, ACCESS
133A  E04C     BZ 0x13D4
150A  0EFE     MOVLW 0xFE
150C  0012     RETURN 0
723:           	{
724:           		if(time_M_Ind.time_blink_LED++ == M_Ind_time_const[e_Time_Blink])
133C  0100     MOVLB 0x0
133E  C0BB     MOVFF 0xBB, __tmp_0
1340  F032     NOP
1342  C0BC     MOVFF 0xBC, 0x33
1344  F033     NOP
1346  2BBB     INCF 0xBB, F, BANKED
1348  0E00     MOVLW 0x0
134A  23BC     ADDWFC 0xBC, F, BANKED
134C  D882     RCALL __pa_10
134E  E10F     BNZ 0x136E
1350  5035     MOVF 0x35, W, ACCESS
1352  1833     XORWF 0x33, W, ACCESS
1354  E10C     BNZ 0x136E
725:           		{
726:           			time_M_Ind.time_blink_LED = 0;
1356  6BBB     CLRF 0xBB, BANKED
1358  6BBC     CLRF 0xBC, BANKED
727:           			Flag_Blink_led[index] = !Flag_Blink_led[index];
135A  D8D9     RCALL __pa_27
135C  E002     BZ 0x1362
135E  0E00     MOVLW 0x0
1360  D001     BRA 0x1364
1362  0E01     MOVLW 0x1
1364  6EE6     MOVWF POSTINC1, ACCESS
1366  D845     RCALL __pa_3
1368  52E5     MOVF POSTDEC1, F, ACCESS
136A  50E7     MOVF INDF1, W, ACCESS
136C  6EEF     MOVWF INDF0, ACCESS
728:           		}
729:           		switch(action)
136E  0EFE     MOVLW 0xFE
1370  50DB     MOVF PLUSW2, W, ACCESS
1372  0A05     XORLW 0x5
1374  E028     BZ 0x13C6
1376  0A01     XORLW 0x1
1378  E021     BZ 0x13BC
137A  0A07     XORLW 0x7
137C  E013     BZ 0x13A4
137E  0A01     XORLW 0x1
1380  E009     BZ 0x1394
1382  0A03     XORLW 0x3
1384  E12C     BNZ 0x13DE
730:           		{
731:           			case BLINKING_RED:	//мигание красного
732:           				LED_BICOLOR_RED_PIN = Flag_Blink_led[index];
1386  D8C3     RCALL __pa_27
1388  B0E8     BTFSC WREG, 0, ACCESS
138A  888D     BSF LATE, 4, ACCESS
138C  B0E8     BTFSC WREG, 0, ACCESS
138E  D008     BRA 0x13A0
1390  988D     BCF LATE, 4, ACCESS
733:           				LED_BICOLOR_GREEN_PIN = OFF;
734:           				break;
1392  D006     BRA 0x13A0
735:           			case BLINKING_GREEN:	//мигание зелёного
736:           				LED_BICOLOR_RED_PIN = OFF;
1394  988D     BCF LATE, 4, ACCESS
737:           				LED_BICOLOR_GREEN_PIN = Flag_Blink_led[index];
1396  D8BB     RCALL __pa_27
1398  B0E8     BTFSC WREG, 0, ACCESS
139A  8A8D     BSF LATE, 5, ACCESS
139C  B0E8     BTFSC WREG, 0, ACCESS
139E  D01F     BRA 0x13DE
13A0  9A8D     BCF LATE, 5, ACCESS
738:           				break;	
13A2  D01D     BRA 0x13DE
739:           			case BLINKING_YELLOW:	//мигание жёлтого (Ж = К+З)
740:           				LED_BICOLOR_RED_PIN = LED_BICOLOR_GREEN_PIN = Flag_Blink_led[index]; 
13A4  D8B4     RCALL __pa_27
13A6  B0E8     BTFSC WREG, 0, ACCESS
13A8  8A8D     BSF LATE, 5, ACCESS
13AA  A0E8     BTFSS WREG, 0, ACCESS
13AC  9A8D     BCF LATE, 5, ACCESS
13AE  508D     MOVF LATE, W, ACCESS
13B0  0B20     ANDLW 0x20
13B2  E002     BZ 0x13B8
13B4  888D     BSF LATE, 4, ACCESS
13B6  D013     BRA 0x13DE
13B8  988D     BCF LATE, 4, ACCESS
741:           				break;
13BA  D011     BRA 0x13DE
742:           			case BLINKING_FAN_PIN:	//мигание светодиода "Вентилятор" (при горении, в подсостояния подержания температуры)
743:           				LED_FAN_PIN =  Flag_Blink_led[index];
13BC  D8A8     RCALL __pa_27
13BE  B0E8     BTFSC WREG, 0, ACCESS
13C0  868D     BSF LATE, 3, ACCESS
13C2  A0E8     BTFSS WREG, 0, ACCESS
13C4  968D     BCF LATE, 3, ACCESS
744:                       case BLINKING_PUMP_PIN:  //to do!!!
745:                           LED_PUMP_PIN = Flag_Blink_led[index]; //Мигание светодиода "Насос"
13C6  D8A3     RCALL __pa_27
13C8  B0E8     BTFSC WREG, 0, ACCESS
13CA  848D     BSF LATE, 2, ACCESS
13CC  B0E8     BTFSC WREG, 0, ACCESS
13CE  D007     BRA 0x13DE
13D0  948D     BCF LATE, 2, ACCESS
13F2  0EFD     MOVLW 0xFD
13F4  50DB     MOVF PLUSW2, W, ACCESS
13F6  6AEA     CLRF FSR0H, ACCESS
13F8  0F3D     ADDLW 0x3D
13FA  6EE9     MOVWF FSR0, ACCESS
13FC  0E0F     MOVLW 0xF
13FE  22EA     ADDWFC FSR0H, F, ACCESS
1400  0012     RETURN 0
150E  DF71     RCALL __pa_3
1510  50EF     MOVF INDF0, W, ACCESS
1512  0012     RETURN 0
746:                           break;
747:                   }
748:           	}
749:           	else
13D2  D005     BRA 0x13DE
750:           	{
751:           		Flag_Blink_led[index] = NO_BLINKING; 
13D4  D80E     RCALL __pa_3
13D6  6AEF     CLRF INDF0, ACCESS
752:           		time_M_Ind.time_blink_LED = 0;
13D8  0100     MOVLB 0x0
13DA  6BBB     CLRF 0xBB, BANKED
13DC  6BBC     CLRF 0xBC, BANKED
753:           	}
754:           }
13DE  D015     BRA __pa_5
140A  52E5     MOVF POSTDEC1, F, ACCESS
140C  CFE7     MOVFF INDF1, FSR2
140E  FFD9     NOP
1410  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_fan/module_fan.c  -------------------------
1:             #include "stdint.h"
2:             #include "module_fan.h"
3:             #include "module_indication.h"
4:             #include "interrupts.h"
5:             #include "module_management.h"
6:             #include "main.h"
7:             #include <p18cxxx.h>
8:             
9:             
10:            #define THRESHOLD_ZERO_CROSS 			480U	//порог накопления количества переходов через нуль для определения наличия напряжения ~220В
11:            #define M_FAN_WAITING					1
12:            #define M_FAN_FAILURE					2
13:            #define M_FAN_WORK_OR_OFF				3
14:            #define M_FAN_WORK_CYCLE_TIMER          4
15:            #define TIME_CHECK_SYNCHRO_IMPULSE		25U //25мс
16:            
17:            #define HALF_SINUS_PERIOD_MS			10
18:            #define FAN_PIN							LATFbits.LATF2
19:            #define FAN_TRIS                        TRISFbits.TRISF2
20:            #define TIMEOUT_TASK_FAN				1
21:            #define TIME_TRIAK_IS_ON				1
22:            #define FIRST_HALF_SINUS_PERIOD			0
23:            #define SECOND_HALF_SINUS_PERIOD		1
24:            #define FAN_MAX_LEVEL_ROTATION_SPEED	8U
25:            #define MIN_FAN_LEVEL					2
26:            
27:            
28:            typedef struct 
29:            {
30:            	uint16_t time_detect_zero_cross;
31:            	uint16_t time_before_triac_is_on;
32:            }TIME_M_Fan;
33:            
34:            
35:            const rom uint16_t M_fan_time_accum_zero_cross = 10000;  //10 с - время накопления переходов через ноль напряжения 220В 
36:            
37:            /* Переменные модуля */
38:            BOOL M_fan_is_220V = ON;
39:            BOOL ctrl_fan = FALSE;
40:            uint8_t M_fan_state = M_FAN_WAITING;
41:            uint8_t M_fan_previous_state = M_FAN_WAITING;
42:            uint8_t level_fan = MIN_FAN_LEVEL;
43:            uint8_t step_force_fan = 0;
44:            uint16_t timer_force_fan = 0;
45:            
46:            
47:            /* Структуры модуля  */
48:            TIME_M_Fan time_M_Fan = {0};
49:            
50:            
51:            
52:            void M_Fan_ctor( void )
53:            {
54:                FAN_TRIS = OUT;
2EA6  9497     BCF TRISF, 2, ACCESS
55:                FAN_PIN = OFF;		
2EA8  948E     BCF LATF, 2, ACCESS
56:            }
2EAA  0012     RETURN 0
57:            
58:            void M_fan_set_level_fan(uint8_t value)
2EAC  D892     RCALL __pa_0
59:            {
60:            	level_fan = value;
2EAE  CFDB     MOVFF PLUSW2, level_fan
2EB0  F104     NOP
61:            }
2EB2  D095     BRA __pa_1
62:            
63:            /* Функции*/
64:            void M_fan_set_ctrl_fan (BOOL value)
2EB4  D88E     RCALL __pa_0
65:            {
66:            	ctrl_fan = value;
2EB6  CFDB     MOVFF PLUSW2, ctrl_fan
2EB8  F101     NOP
67:            }
2EBA  D091     BRA __pa_1
68:            
69:            BOOL M_fan_get_ctrl_fan(void)
70:            {
71:            	return ctrl_fan;
2EBC  0101     MOVLB 0x1
2EBE  5101     MOVF 0x1, W, BANKED
72:            }
2EC0  0012     RETURN 0
73:            
74:            BOOL M_fan_get_is_220V(void)
75:            {
76:            	return M_fan_is_220V;
2EC2  0101     MOVLB 0x1
2EC4  5100     MOVF _OS_BestTask, W, BANKED
77:            }
2EC6  0012     RETURN 0
78:            
79:            /* Функция проверки наличия 220В  */
80:            BOOL  M_fan_check_220V(void)
81:            {
82:            	#ifdef NO_220V_CONTROL
83:            		M_fan_is_220V = ON;
2EC8  0101     MOVLB 0x1
2ECA  0E01     MOVLW 0x1
2ECC  6F00     MOVWF _OS_BestTask, BANKED
84:            	#else		
85:            		if(time_M_Fan.time_detect_zero_cross++ >= M_fan_time_accum_zero_cross)
86:            		{
87:            			time_M_Fan.time_detect_zero_cross = 0;
88:            			M_fan_is_220V = (Intr_get_cnt_zero_crossing() >= THRESHOLD_ZERO_CROSS);
89:            			Intr_set_cnt_zero_crossing(0);
90:            		}	
91:            	#endif
92:            	return M_fan_is_220V;
2ECE  50E8     MOVF WREG, W, ACCESS
93:            }
2ED0  0012     RETURN 0
94:            
95:            void M_fan_clear_timeouts(void)
96:            {
97:            	time_M_Fan.time_before_triac_is_on = step_force_fan = timer_force_fan = 0;
2ED2  0E00     MOVLW 0x0
2ED4  0101     MOVLB 0x1
2ED6  6F06     MOVWF 0x6, BANKED
2ED8  6B07     CLRF 0x7, BANKED
2EDA  6F05     MOVWF _OS_Tasks, BANKED
2EDC  6F0A     MOVWF 0xA, BANKED
2EDE  6B0B     CLRF 0xB, BANKED
98:            }
2EE0  0012     RETURN 0
99:            
100:           void M_fan_run(void)
101:           {
102:           	
103:            	#define LEVEL_FORCE_FAN 	4U
104:           	#define TIMEOUT_FORCE_FAN	3500U
105:           	
106:           	if(M_Ind_Get_state() == STATE_IND_INIT)
2EE2  ECA5     CALL 0xD4A, 0
2EE4  F006     NOP
2EE6  0900     IORLW 0x0
2EE8  E101     BNZ 0x2EEC
107:           		return;
2EEA  0012     RETURN 0
108:           	
109:           	M_fan_check_220V(); //проверка наличия 220В
2EEC  DFED     RCALL M_fan_check_220V
110:           	
111:           	if(M_Mngm_Get_state() == STATE_PAUSE)	
2EEE  EC0C     CALL 0x1618, 0
2EF0  F00B     NOP
2EF2  0803     SUBLW 0x3
2EF4  E102     BNZ 0x2EFA
112:           	{
113:           		FAN_PIN = OFF;	
2EF6  948E     BCF LATF, 2, ACCESS
114:           	}
115:           	else
2EF8  0012     RETURN 0
116:           	{
117:           		switch(M_fan_state)
2EFA  0101     MOVLB 0x1
2EFC  5102     MOVF _OS_LastTask, W, BANKED
2EFE  0A03     XORLW 0x3
2F00  E017     BZ 0x2F30
2F02  0A01     XORLW 0x1
2F04  E00E     BZ 0x2F22
2F06  0A03     XORLW 0x3
2F08  E001     BZ 0x2F0C
2F0A  0012     RETURN 0
118:           		{
119:           			case M_FAN_WAITING:
120:           				M_fan_previous_state = M_fan_state;
2F0C  C102     MOVFF M_fan_state, M_fan_previous_state
2F0E  F103     NOP
121:           				/* отладка (в рабочей версии убрать)*/ //ctrl_fan = TRUE;  
122:           				if(!M_fan_is_220V) 
2F10  5100     MOVF _OS_BestTask, W, BANKED
2F12  E102     BNZ 0x2F18
123:           				{
124:           					M_fan_state = M_FAN_FAILURE; 	
2F14  0E02     MOVLW 0x2
125:           				}
126:           				else
2F16  D003     BRA 0x2F1E
127:           				{
128:           					if( ctrl_fan ) 
2F18  5101     MOVF 0x1, W, BANKED
2F1A  E020     BZ 0x2F5C
129:           						M_fan_state = M_FAN_WORK_OR_OFF;
2F1C  0E03     MOVLW 0x3
2F1E  6F02     MOVWF _OS_LastTask, BANKED
130:           				}
131:           			break;
2F20  0012     RETURN 0
132:           			case M_FAN_FAILURE:
133:           				if(M_fan_is_220V) 		//условие выхода из состояния аварии
2F22  5100     MOVF _OS_BestTask, W, BANKED
2F24  E003     BZ 0x2F2C
134:           				{		
135:           					M_fan_state = M_fan_previous_state;
2F26  C103     MOVFF M_fan_previous_state, M_fan_state
2F28  F102     NOP
136:           				}
137:           				else
2F2A  0012     RETURN 0
138:           				{
139:           					FAN_PIN = OFF;
2F2C  948E     BCF LATF, 2, ACCESS
140:           				}
141:           			break;
2F2E  0012     RETURN 0
142:           			case M_FAN_WORK_OR_OFF:
143:           				M_fan_previous_state = M_fan_state;
2F30  C102     MOVFF M_fan_state, M_fan_previous_state
2F32  F103     NOP
144:           				if(!M_fan_is_220V) 
2F34  5100     MOVF _OS_BestTask, W, BANKED
2F36  E107     BNZ 0x2F46
145:           				{
146:           					M_fan_state = M_FAN_FAILURE; 	
2F38  0E02     MOVLW 0x2
2F3A  6F02     MOVWF _OS_LastTask, BANKED
147:           					Intr_set_is_zero_cross (FALSE); 
2F3C  6AE6     CLRF POSTINC1, ACCESS
2F3E  EC3B     CALL 0x2E76, 0
2F40  F017     NOP
2F42  52E5     MOVF POSTDEC1, F, ACCESS
148:           					M_fan_clear_timeouts();
149:           				}
150:           				else
2F44  D005     BRA 0x2F50
151:           				{
152:           					if( !ctrl_fan )
2F46  5101     MOVF 0x1, W, BANKED
2F48  E105     BNZ 0x2F54
153:           					{	
154:           						M_fan_state = M_FAN_WAITING;
2F4A  0E01     MOVLW 0x1
2F4C  6F02     MOVWF _OS_LastTask, BANKED
155:           						FAN_PIN = OFF;	
2F4E  948E     BCF LATF, 2, ACCESS
156:           						M_fan_clear_timeouts();
2F50  EF69     GOTO 0x2ED2
2F52  F017     NOP
157:           					}
158:           					else
159:           					{
160:           						//0 - форсированный старт (на 5 секунд включить вентилятор на 3-ем уровне), 1 - работа по передаваемому level_fan
161:           						/*
162:           						switch (step_force_fan) 
163:           						{
164:           							case 0:
165:           								if(timer_force_fan ++ >= TIMEOUT_FORCE_FAN)
166:           								{
167:           									timer_force_fan = 0;
168:           									step_force_fan++;		
169:           								}
170:           								else
171:           								{
172:           									M_Fan_work_fan(LEVEL_FORCE_FAN);
173:           								}
174:           							break;
175:           							case 1:
176:           								M_Fan_work_fan(level_fan);
177:           							break;
178:           						}
179:           					    */
180:           					    M_Fan_work_fan(level_fan);
2F54  C104     MOVFF level_fan, POSTINC1
2F56  FFE6     NOP
2F58  D802     RCALL M_Fan_work_fan
2F5A  52E5     MOVF POSTDEC1, F, ACCESS
181:           					}
182:           				}
183:           			break;
184:           		}
185:           	}
186:           }
2F5C  0012     RETURN 0
187:           
188:           /* Функция, в которой устанавливается время работы симистора в зависимости от уровня, заданного в меню */
189:           void M_Fan_work_fan ( uint8_t level )
2F5E  D839     RCALL __pa_0
2FD2  CFD9     MOVFF FSR2, POSTINC1
2FD4  FFE6     NOP
2FD6  CFE1     MOVFF FSR1, FSR2
2FD8  FFD9     NOP
190:           {
191:           	static uint8_t counter = 0;
192:           	static BOOL cnt_half_period = FIRST_HALF_SINUS_PERIOD;
193:           	
194:           		
195:           	if( level == FAN_MAX_LEVEL_ROTATION_SPEED )  //при максимальном уровне оборотов вентилятор всегда включен
2F60  50DB     MOVF PLUSW2, W, ACCESS
2F62  0808     SUBLW 0x8
2F64  E102     BNZ 0x2F6A
2FDA  0EFE     MOVLW 0xFE
2FDC  0012     RETURN 0
196:           	{
197:           		FAN_PIN = ON;		
2F66  848E     BSF LATF, 2, ACCESS
198:           	}
199:           	else if (level == 1U)
2F68  D033     BRA 0x2FD0
2F6A  0EFE     MOVLW 0xFE
2F6C  04DB     DECF PLUSW2, W, ACCESS
2F6E  E102     BNZ 0x2F74
200:           	{	
201:           		FAN_PIN = OFF;
2F70  948E     BCF LATF, 2, ACCESS
202:           	}
203:           	else
2F72  D02E     BRA 0x2FD0
204:           	{
205:           		if (Intr_get_is_zero_cross())		//если был переход через нуль сетевого напряжения
2F74  EC3F     CALL 0x2E7E, 0
2F76  F017     NOP
2F78  0900     IORLW 0x0
2F7A  E028     BZ 0x2FCC
206:           		{
207:           		
208:           				switch (counter)  //реализация фазового регулирования оборотов вентилятора
2F7C  0101     MOVLB 0x1
2F7E  510C     MOVF 0xC, W, BANKED
2F80  0A01     XORLW 0x1
2F82  E01D     BZ 0x2FBE
2F84  0A01     XORLW 0x1
2F86  E124     BNZ 0x2FD0
209:           				{
210:           					case 0:  	//отсчёт времени паузы, затем включение симистора
211:           						if(time_M_Fan.time_before_triac_is_on++ < (HALF_SINUS_PERIOD_MS - level - TIMEOUT_TASK_FAN - 1))
2F88  C10A     MOVFF 0x10A, __tmp_0
2F8A  F032     NOP
2F8C  C10B     MOVFF 0x10B, 0x33
2F8E  F033     NOP
2F90  2B0A     INCF 0xA, F, BANKED
2F92  0E00     MOVLW 0x0
2F94  230B     ADDWFC 0xB, F, BANKED
2F96  0EFE     MOVLW 0xFE
2F98  CFDB     MOVFF PLUSW2, POSTINC1
2F9A  FFE6     NOP
2F9C  0E0A     MOVLW 0xA
2F9E  52E5     MOVF POSTDEC1, F, ACCESS
2FA0  80D8     BSF STATUS, 0, ACCESS
2FA2  54E7     SUBFWB INDF1, W, ACCESS
2FA4  0FFF     ADDLW 0xFF
2FA6  0FFF     ADDLW 0xFF
2FA8  6A35     CLRF 0x35, ACCESS
2FAA  50E8     MOVF WREG, W, ACCESS
2FAC  5C32     SUBWF __tmp_0, W, ACCESS
2FAE  5035     MOVF 0x35, W, ACCESS
2FB0  5833     SUBWFB 0x33, W, ACCESS
2FB2  E30E     BNC 0x2FD0
212:           							break;
213:           						else
214:           						{
215:           							time_M_Fan.time_before_triac_is_on = 0;
2FB4  6B0A     CLRF 0xA, BANKED
2FB6  6B0B     CLRF 0xB, BANKED
216:           							FAN_PIN = ON;		
2FB8  848E     BSF LATF, 2, ACCESS
217:           							counter++;	
2FBA  2B0C     INCF 0xC, F, BANKED
218:           						}
219:           						break;
2FBC  D009     BRA 0x2FD0
220:           					case 1:  	//выключение симистора и отсчёт времени до конца полупериода
221:           						FAN_PIN = OFF;
2FBE  948E     BCF LATF, 2, ACCESS
222:           						counter = 0;
2FC0  6B0C     CLRF 0xC, BANKED
223:           						Intr_set_is_zero_cross (FALSE); 	 //в конце полупериода синуса (10мс) сбросить флаг синхроимпульса
2FC2  6AE6     CLRF POSTINC1, ACCESS
2FC4  EC3B     CALL 0x2E76, 0
2FC6  F017     NOP
2FC8  52E5     MOVF POSTDEC1, F, ACCESS
224:           						break;
225:           				}
226:           			}
227:           		
228:           		else
2FCA  D002     BRA 0x2FD0
229:           		{
230:           			cnt_half_period = FIRST_HALF_SINUS_PERIOD;	
2FCC  0101     MOVLB 0x1
2FCE  6B0D     CLRF 0xD, BANKED
231:           		}
232:           	}
233:           }
2FD0  D006     BRA __pa_1
2FDE  52E5     MOVF POSTDEC1, F, ACCESS
2FE0  CFE7     MOVFF INDF1, FSR2
2FE2  FFD9     NOP
2FE4  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_analog_inputs/module_analog_inputs.c  -----
1:             #include <p18cxxx.h>
2:             #include <adc.h>
3:             #include "module_analog_inputs.h"
4:             
5:             
6:             /* 
7:             Таблица температуры для терморезистора 10 кОм с характеристикой В3950
8:             Диапазон от 0 до 99 градусов с шагом 1 градус
9:             Таблица в дискретах 10-битного АЦП
10:            */
11:            const rom uint16_t M_AI_Table_thermoresistor[] =
12:            {
13:            789, 780, 770, 760, 749, 739, 728, 718, 707, 696, 685, 673, 662, 651, 639, 628, 616, 604, 593, 581,
14:            570, 558, 546, 535, 523, 512, 501, 489, 478, 467, 456, 445, 435, 424, 414, 404, 394, 384, 374, 364,
15:            355, 346, 336, 328, 319, 310, 302, 294, 286, 278, 270, 263, 256, 249, 242, 235, 228, 222, 216, 210,
16:            204, 198, 193, 187, 182, 177, 172, 167, 162, 158, 153, 149, 145, 141, 137, 133, 129, 126, 122, 119,
17:            115, 112, 109, 106, 103, 100, 98, 95, 92, 90, 87, 85, 83, 81, 78, 76, 74, 72, 70, 69
18:            };
19:            
20:            
21:            /* 
22:            Таблица температуры для датчика температуры PT100
23:            Диапазон от 0 до 850 градусов с шагом 10 градусов
24:            Таблица в дискретах 10-битного АЦП
25:            Конечная температура будет в виде числа от 0 до 85
26:            */
27:            const rom uint16_t M_AI_Table_PT100[] = 
28:            {
29:            59, 71, 83, 95, 107, 119, 131, 143, 155, 167, 178, 190, 202, 213, 225, 236, 247, 259, 270, 281,
30:            292, 303, 314, 325, 336, 347, 358, 369, 380, 390, 401, 412, 422, 433, 443, 453, 464, 474, 484,
31:            495, 505, 515, 525, 535, 545, 555, 565, 574, 584, 594, 604, 613, 623, 632, 642, 651, 661, 670,
32:            679, 689, 698, 707, 716, 725, 734, 743, 752, 761, 770, 779, 788, 796, 805, 814, 822, 831, 839, 
33:            848, 856, 865, 873, 881, 890, 898, 906, 914
34:            };
35:            
36:            //#define ALL_ANALOG_CHANNELS_IN_USE
37:            
38:            // Количество значений в таблице температуры терморезистора от 0 до 100 градусов в дискретах АЦП (10 бит)
39:            #define SIZE_TABLE_TERMO_RES  	sizeof(M_AI_Table_thermoresistor) / sizeof(M_AI_Table_thermoresistor[0])  
40:            
41:            // Количество значений в таблице температуры PT100 от 0 до 850 градусов в дискретах АЦП (10 бит)
42:            #define SIZE_TABLE_PT100	  	sizeof(M_AI_Table_PT100) / sizeof(M_AI_Table_PT100[0])     
43:            
44:            #ifdef ALL_ANALOG_CHANNELS_IN_USE
45:                #define QUANTITY_ANALOG_CHANNELS    6U 	   		//Общее количество каналов АЦП
46:                #define QUANTITY_TEMPER_CHANNELS    5U          //Количество каналов АЦП измерения температуры  
47:            #else
48:                #define QUANTITY_ANALOG_CHANNELS    3U 	   		//Общее количество каналов АЦП
49:                #define QUANTITY_TEMPER_CHANNELS    2U          //Количество каналов АЦП измерения температуры
50:            #endif
51:            
52:            #define QUANTITY_DC_CURRENT_CHANNELS    1U          //Количество каналов АЦП измерения постоянного тока         
53:            #define QUANTITY_OF_SHR                 6 			//Для усреднения результата (количество сдвигов вправо)
54:            #define QUANTITY_ELEMENTS_OF_SUMMARY  	1U << QUANTITY_OF_SHR  //Величина буфера суммы			 
55:            #define QUANTITY_TABLES_TEMPERATURE		2
56:            #define ADC_CH0_TRIS                    TRISAbits.TRISA0
57:            #define ADC_CH1_TRIS                    TRISAbits.TRISA1
58:            #define ADC_CH2_TRIS                    TRISAbits.TRISA2
59:            #define ADC_CH3_TRIS                    TRISAbits.TRISA3
60:            #define ADC_CH4_TRIS                    TRISAbits.TRISA5
61:            #define ADC_CH012_TRIS                  TRISHbits.TRISH4
62:            #define ADC_MASK_CHANNELS               0b1110111111100000  //Маска аналоговыз каналов (1 - цифровой вход/выход, 0 - аналоговый вход)
63:            
64:            
65:            
66:            const rom uint8_t M_AI_Type_Table_Sorted[QUANTITY_TABLES_TEMPERATURE] = {TABLE_SORTED_UP, TABLE_SORTED_DOWN};
67:            
68:            const rom uint8_t M_AI_Offset_in_table[QUANTITY_TABLES_TEMPERATURE][QUANTITY_TABLES_TEMPERATURE] = 
69:            {
70:            {0, SIZE_TABLE_PT100 - 1},
71:            {SIZE_TABLE_TERMO_RES - 1, 0}
72:            };
73:            
74:            const rom uint16_t* M_AI_ptrTable [QUANTITY_TABLES_TEMPERATURE] = {M_AI_Table_PT100, M_AI_Table_thermoresistor};
75:            #ifdef ALL_ANALOG_CHANNELS_IN_USE
76:                const rom uint8_t M_AI_Mask_ADC_channels [QUANTITY_ANALOG_CHANNELS] = 
77:                                { ADC_CH3, ADC_CH1, ADC_CH12, ADC_CH0, ADC_CH4, ADC_CH2 }; 
78:            #else
79:                const rom uint8_t M_AI_Mask_ADC_channels [QUANTITY_ANALOG_CHANNELS] = 
80:                                { ADC_CH3, ADC_CH1, ADC_CH12 }; 
81:            #endif
82:            const rom uint8_t M_AI_Size_Table_temperature [QUANTITY_TABLES_TEMPERATURE] = {SIZE_TABLE_PT100, SIZE_TABLE_TERMO_RES};
83:            
84:            //Объявление структур температур и постоянного тока
85:            ADC_Data  M_AI_ADC_Data[QUANTITY_ANALOG_CHANNELS] = {0};
86:            
87:            
88:            /*Функция возвращает адрес массива структур канала АЦП */
89:            ADC_Data* M_AI_Get_ADC_Data(uint8_t index)
2318  D969     RCALL __pa_7
90:            {
91:            	return (ADC_Data*)&M_AI_ADC_Data[index];
231A  0EFE     MOVLW 0xFE
231C  50DB     MOVF PLUSW2, W, ACCESS
231E  0D06     MULLW 0x6
2320  CFF3     MOVFF PROD, __tmp_0
2322  F032     NOP
2324  CFF4     MOVFF PRODH, 0x33
2326  F033     NOP
2328  0EC7     MOVLW 0xC7
232A  2632     ADDWF __tmp_0, F, ACCESS
232C  0E00     MOVLW 0x0
232E  2233     ADDWFC 0x33, F, ACCESS
2330  C032     MOVFF __tmp_0, PROD
2332  FFF3     NOP
2334  C033     MOVFF 0x33, PRODH
2336  FFF4     NOP
92:            }  
2338  D15E     BRA __pa_8
93:            
94:            //Инициализация модуля АЦП
95:            void M_AI_ctor( void )
96:            {
97:                OpenADC(ADC_FOSC_64 & ADC_RIGHT_JUST & ADC_12_TAD,  
2346  0EEB     MOVLW 0xEB
2348  6EE6     MOVWF POSTINC1, ACCESS
98:                        ADC_CH0 & ADC_CH1 & ADC_CH2 & ADC_CH3 &  
99:                        ADC_CH4 & ADC_CH12 & ADC_INT_OFF & ADC_REF_VDD_VSS, ADC_MASK_CHANNELS);
233A  0EE0     MOVLW 0xE0
233C  6EE6     MOVWF POSTINC1, ACCESS
233E  0EEF     MOVLW 0xEF
2340  6EE6     MOVWF POSTINC1, ACCESS
2342  0E04     MOVLW 0x4
2344  6EE6     MOVWF POSTINC1, ACCESS
234A  ECD9     CALL 0x33B2, 0
234C  F019     NOP
234E  52E5     MOVF POSTDEC1, F, ACCESS
2350  52E5     MOVF POSTDEC1, F, ACCESS
2352  52E5     MOVF POSTDEC1, F, ACCESS
2354  52E5     MOVF POSTDEC1, F, ACCESS
100:               ADC_CH0_TRIS   = IN;   
2356  8092     BSF TRISA, 0, ACCESS
101:               ADC_CH1_TRIS   = IN;  
2358  8292     BSF TRISA, 1, ACCESS
102:               ADC_CH2_TRIS   = IN;  
235A  8492     BSF TRISA, 2, ACCESS
103:               ADC_CH3_TRIS   = IN;  
235C  8692     BSF TRISA, 3, ACCESS
104:               ADC_CH4_TRIS   = IN;  
235E  8A92     BSF TRISA, 5, ACCESS
105:               ADC_CH012_TRIS = IN;      
2360  8899     BSF TRISH, 4, ACCESS
106:           }
2362  0012     RETURN 0
107:           
108:           
109:           
110:           //Поиск в таблице значения температуры по данным работы АЦП (методом двоичного поиска)
111:           //в зависимости от типа таблицы (отсортирована по возрастанию или по убыванию в зависимости от  аргумента uint8_t sort_direction)
112:           uint8_t M_AI_Search(uint16_t value, const rom uint16_t* table, const uint8_t length, uint8_t sort_direction)
2364  D943     RCALL __pa_7
2366  0E03     MOVLW 0x3
2368  26E1     ADDWF FSR1, F, ACCESS
113:           {
114:           	uint8_t U, L, M;
115:           	
116:           	U = length;
236A  0EFA     MOVLW 0xFA
236C  50DB     MOVF PLUSW2, W, ACCESS
236E  6EDF     MOVWF INDF2, ACCESS
117:           	L = 0;
2370  0E01     MOVLW 0x1
2372  6ADB     CLRF PLUSW2, ACCESS
118:           
119:           	while(1)
120:           	{
121:           		 M = (L + U) / 2;
2374  0E01     MOVLW 0x1
2376  50DB     MOVF PLUSW2, W, ACCESS
2378  24DF     ADDWF INDF2, W, ACCESS
237A  0BFE     ANDLW 0xFE
237C  42E8     RRNCF WREG, F, ACCESS
237E  6EE7     MOVWF INDF1, ACCESS
2380  0E02     MOVLW 0x2
2382  CFE7     MOVFF INDF1, PLUSW2
2384  FFDB     NOP
122:           		 if(sort_direction) //условие истинно для таблицы, отсортированной по убыванию (терморезистор NTC)
2386  0EF9     MOVLW 0xF9
2388  50DB     MOVF PLUSW2, W, ACCESS
238A  E006     BZ 0x2398
123:           		 {
124:           		 	if (value > table[M]) 
238C  D8F9     RCALL __pa_1
238E  D937     RCALL __pa_9
2390  E305     BNC 0x239C
125:           		 	U = M; /*- 1*/
126:           		 else
127:           		 	if (value < table[M]) 
2392  D94E     RCALL __pa_14
2394  E211     BC 0x23B8
2630  DFA7     RCALL __pa_1
2632  5034     MOVF 0x34, W, ACCESS
2634  5C32     SUBWF __tmp_0, W, ACCESS
2636  5035     MOVF 0x35, W, ACCESS
2638  5833     SUBWFB 0x33, W, ACCESS
263A  0012     RETURN 0
128:           		 		L = M; /*+ 1*/
129:           		 	else 
2396  D009     BRA 0x23AA
130:           		 		return M;
131:           		 } 
132:           		else  //эта ветвь выполняется для таблицы, отсортированной по возрастанию (датчик PT100)
133:           		{
134:           			if (value < table[M]) 
2398  D94B     RCALL __pa_14
239A  E204     BC 0x23A4
135:           		 	U = M; /*- 1*/
239C  0E02     MOVLW 0x2
239E  50DB     MOVF PLUSW2, W, ACCESS
23A0  6EDF     MOVWF INDF2, ACCESS
136:           		 else
23A2  D00C     BRA 0x23BC
137:           		 	if (value > table[M]) 
23A4  D8ED     RCALL __pa_1
23A6  D92B     RCALL __pa_9
23A8  E207     BC 0x23B8
2580  0EFD     MOVLW 0xFD
2582  CFDB     MOVFF PLUSW2, __tmp_0
2584  F032     NOP
2586  0EFE     MOVLW 0xFE
2588  CFDB     MOVFF PLUSW2, 0x33
258A  F033     NOP
258C  0E02     MOVLW 0x2
258E  6A37     CLRF 0x37, ACCESS
2590  34DB     RLCF PLUSW2, W, ACCESS
2592  0BFE     ANDLW 0xFE
2594  3637     RLCF 0x37, F, ACCESS
2596  6E36     MOVWF 0x36, ACCESS
2598  0EFB     MOVLW 0xFB
259A  50DB     MOVF PLUSW2, W, ACCESS
259C  2436     ADDWF 0x36, W, ACCESS
259E  6EF6     MOVWF TBLPTR, ACCESS
25A0  0EFC     MOVLW 0xFC
25A2  50DB     MOVF PLUSW2, W, ACCESS
25A4  2037     ADDWFC 0x37, W, ACCESS
25A6  EF10     GOTO 0x2620
25A8  F013     NOP
138:           		 		L = M; /*+ 1*/
23AA  0E02     MOVLW 0x2
23AC  50DB     MOVF PLUSW2, W, ACCESS
23AE  6EE7     MOVWF INDF1, ACCESS
23B0  0E01     MOVLW 0x1
23B2  CFE7     MOVFF INDF1, PLUSW2
23B4  FFDB     NOP
139:           		 	else 
23B6  D002     BRA 0x23BC
140:           		 		return M;
23B8  0E02     MOVLW 0x2
23BA  D006     BRA 0x23C8
141:           		 }
142:           		if ((U - L) == 1U) 
23BC  0E01     MOVLW 0x1
23BE  50DB     MOVF PLUSW2, W, ACCESS
23C0  5CDF     SUBWF INDF2, W, ACCESS
23C2  0801     SUBLW 0x1
23C4  E1D7     BNZ 0x2374
143:           		 	return L;
23C6  0E01     MOVLW 0x1
23C8  50DB     MOVF PLUSW2, W, ACCESS
144:           	}
145:           } 
23CA  6E32     MOVWF __tmp_0, ACCESS
23CC  0E03     MOVLW 0x3
23CE  5CE1     SUBWF FSR1, W, ACCESS
23D0  E202     BC 0x23D6
23D2  6AE1     CLRF FSR1, ACCESS
23D4  52E5     MOVF POSTDEC1, F, ACCESS
23D6  6EE1     MOVWF FSR1, ACCESS
23D8  5032     MOVF __tmp_0, W, ACCESS
23DA  D10D     BRA __pa_8
146:           
147:           
148:           /*
149:           Метод Run модуля обработки АЦП
150:           */
151:           void M_AI_Run (void)
152:           {
153:           	static uint8_t index_channel = 0;
154:           	
155:           	M_AI_Processing_ADC (index_channel); //Преобразование АЦП, усреднение результатов
23DC  C0D9     MOVFF 0xD9, POSTINC1
23DE  FFE6     NOP
23E0  D812     RCALL M_AI_Processing_ADC
23E2  52E5     MOVF POSTDEC1, F, ACCESS
156:           	if( ++index_channel == QUANTITY_ANALOG_CHANNELS ) 
23E4  0100     MOVLB 0x0
23E6  2BD9     INCF 0xD9, F, BANKED
23E8  0E03     MOVLW 0x3
23EA  5DD9     SUBWF 0xD9, W, BANKED
23EC  E101     BNZ 0x23F0
157:           		index_channel = 0; //Когда все каналы пройдены, начинать снова с самого первого
23EE  6BD9     CLRF 0xD9, BANKED
158:           	
159:           	SetChanADC(M_AI_Mask_ADC_channels[index_channel]); //Выбор следующего канала измерения
23F0  51D9     MOVF 0xD9, W, BANKED
23F2  6AF7     CLRF TBLPTRH, ACCESS
23F4  0F3A     ADDLW 0x3A
23F6  6EF6     MOVWF TBLPTR, ACCESS
23F8  0E2D     MOVLW 0x2D
23FA  D8F4     RCALL __pa_6
23FC  6EE6     MOVWF POSTINC1, ACCESS
23FE  EC34     CALL 0x3668, 0
2400  F01B     NOP
2402  52E5     MOVF POSTDEC1, F, ACCESS
160:           }
2404  0012     RETURN 0
161:           
162:           /* 
163:           Измерение АЦП и обработка результатов измерений
164:           */
165:           void M_AI_Processing_ADC (uint8_t index)
2406  D8F2     RCALL __pa_7
25EC  CFD9     MOVFF FSR2, POSTINC1
25EE  FFE6     NOP
25F0  CFE1     MOVFF FSR1, FSR2
25F2  FFD9     NOP
25F4  0012     RETURN 0
166:           {
167:           	if(M_AI_ADC_Data[index].quantity++ < QUANTITY_ELEMENTS_OF_SUMMARY) //Измерение и суммирование в буфер
2408  D919     RCALL __pa_15
240A  50EF     MOVF INDF0, W, ACCESS
240C  2AEF     INCF INDF0, F, ACCESS
240E  6E32     MOVWF __tmp_0, ACCESS
2410  0E40     MOVLW 0x40
2412  5C32     SUBWF __tmp_0, W, ACCESS
2414  E212     BC 0x243A
263C  DF95     RCALL __pa_0
263E  0E02     MOVLW 0x2
2640  D015     BRA __pa_20
266C  26E9     ADDWF FSR0, F, ACCESS
266E  0E00     MOVLW 0x0
2670  22EA     ADDWFC FSR0H, F, ACCESS
2672  0012     RETURN 0
168:           	{
169:           		ConvertADC( );
2416  EC06     CALL 0x380C, 0
2418  F01C     NOP
170:           		while( BusyADC( ) );
241A  EC00     CALL 0x3800, 0
241C  F01C     NOP
241E  0900     IORLW 0x0
2420  E1FC     BNZ 0x241A
171:                   M_AI_ADC_Data[index].sum_discr += ReadADC();	//накопление суммы отсчётов выбранного канала АЦП	
2422  ECF7     CALL 0x37EE, 0
2424  F01B     NOP
2426  CFF3     MOVFF PROD, __tmp_0
2428  F032     NOP
242A  CFF4     MOVFF PRODH, 0x33
242C  F033     NOP
242E  D89C     RCALL __pa_0
2430  5032     MOVF __tmp_0, W, ACCESS
2432  26EE     ADDWF POSTINC0, F, ACCESS
2434  5033     MOVF 0x33, W, ACCESS
2436  22ED     ADDWFC POSTDEC0, F, ACCESS
172:           		
173:           	}
174:           	else
2438  D096     BRA 0x2566
175:           	{
176:           		M_AI_ADC_Data[index].data_value = M_AI_ADC_Data[index].sum_discr >> QUANTITY_OF_SHR; //усреднение результата
243A  D896     RCALL __pa_0
243C  D902     RCALL __pa_16
243E  0E06     MOVLW 0x6
2440  90D8     BCF STATUS, 0, ACCESS
2442  3233     RRCF 0x33, F, ACCESS
2444  3232     RRCF __tmp_0, F, ACCESS
2446  04E8     DECF WREG, W, ACCESS
2448  E1FB     BNZ 0x2440
244A  D90A     RCALL __pa_19
2660  DFD5     RCALL __pa_11
2662  C032     MOVFF __tmp_0, POSTINC0
2664  FFEE     NOP
2666  C033     MOVFF 0x33, POSTDEC0
2668  FFED     NOP
266A  0012     RETURN 0
177:           		M_AI_ADC_Data[index].sum_discr = 0;
244C  D88D     RCALL __pa_0
244E  6AEE     CLRF POSTINC0, ACCESS
2450  6AED     CLRF POSTDEC0, ACCESS
178:           		M_AI_ADC_Data[index].quantity = 0;
2452  D8F4     RCALL __pa_15
2454  6AEF     CLRF INDF0, ACCESS
2568  0EFE     MOVLW 0xFE
256A  50DB     MOVF PLUSW2, W, ACCESS
256C  0D06     MULLW 0x6
256E  CFF3     MOVFF PROD, FSR0
2570  FFE9     NOP
2572  CFF4     MOVFF PRODH, FSR0H
2574  FFEA     NOP
2576  0EC7     MOVLW 0xC7
2578  26E9     ADDWF FSR0, F, ACCESS
257A  0E00     MOVLW 0x0
257C  22EA     ADDWFC FSR0H, F, ACCESS
257E  0012     RETURN 0
179:           		
180:                   switch(index)
2456  0EFE     MOVLW 0xFE
2458  50DB     MOVF PLUSW2, W, ACCESS
245A  0A02     XORLW 0x2
245C  E101     BNZ 0x2460
245E  D083     BRA 0x2566
2460  0A02     XORLW 0x2
2462  E003     BZ 0x246A
2464  0A01     XORLW 0x1
2466  E001     BZ 0x246A
2468  D07E     BRA 0x2566
181:                   {    
182:                       case CHN_T_GAS: //Обработка температуры
183:                       case CHN_T_WATER:
184:                           if (M_AI_ADC_Data[index].data_value < SHORT_CIRCUIT_SENSOR_THRESHOLD) // проверка на КЗ датчика температуры
246A  D8D0     RCALL __pa_11
246C  D8B5     RCALL __pa_5
246E  E203     BC 0x2476
25D8  D834     RCALL __pa_16
25DA  0E0A     MOVLW 0xA
25DC  5C32     SUBWF __tmp_0, W, ACCESS
25DE  0E00     MOVLW 0x0
25E0  5833     SUBWFB 0x33, W, ACCESS
25E2  0012     RETURN 0
2642  CFEE     MOVFF POSTINC0, __tmp_0
2644  F032     NOP
2646  CFEF     MOVFF INDF0, 0x33
2648  F033     NOP
264A  0012     RETURN 0
185:                           {
186:                               M_AI_ADC_Data[index].param = SHORT_CIRCUIT_SENSOR_VALUE; 
2470  D8ED     RCALL __pa_17
2472  0EFB     MOVLW 0xFB
187:                               return;
2474  D077     BRA 0x2564
188:                           }
189:                           else if (M_AI_ADC_Data[index].data_value > BREAK_SENSOR_THRESHOLD) // проверка на обрыв датчика температуры
2476  D8ED     RCALL __pa_18
2478  E203     BC 0x2480
2652  DFDC     RCALL __pa_11
2654  0ED4     MOVLW 0xD4
2656  80D8     BSF STATUS, 0, ACCESS
2658  54EE     SUBFWB POSTINC0, W, ACCESS
265A  0E03     MOVLW 0x3
265C  54ED     SUBFWB POSTDEC0, W, ACCESS
265E  0012     RETURN 0
190:                           {
191:                                M_AI_ADC_Data[index].param = BREAK_SENSOR_VALUE;
247A  D8E8     RCALL __pa_17
247C  0EFA     MOVLW 0xFA
192:                               #ifndef NO_SENSOR_GAS
193:                                   return;
247E  D072     BRA 0x2564
194:                               #else
195:                                   if(index == CHN_T_GAS)	
196:                                   {
197:                                       M_AI_ADC_Data[index].param = 2;  //типа фиктивные 20 градусов
198:                                       return;
199:                                   }	
200:                               #endif
201:                           }
202:                           else if (M_AI_ADC_Data[index].data_value >= SHORT_CIRCUIT_SENSOR_THRESHOLD && 
2480  D8C5     RCALL __pa_11
2482  D8AA     RCALL __pa_5
203:                                    M_AI_ADC_Data[index].data_value < *(M_AI_ptrTable[index] + M_AI_Offset_in_table[index][0])) 
2484  E320     BNC 0x24C6
2486  D8C2     RCALL __pa_11
2488  CFEE     MOVFF POSTINC0, 0x34
248A  F034     NOP
248C  CFEF     MOVFF INDF0, 0x35
248E  F035     NOP
2490  D88C     RCALL __pa_2
2492  CFEE     MOVFF POSTINC0, 0x38
2494  F038     NOP
2496  CFEF     MOVFF INDF0, 0x39
2498  F039     NOP
249A  D892     RCALL __pa_3
249C  D8A3     RCALL __pa_6
249E  0D02     MULLW 0x2
24A0  5038     MOVF 0x38, W, ACCESS
24A2  24F3     ADDWF PROD, W, ACCESS
24A4  6EF6     MOVWF TBLPTR, ACCESS
24A6  5039     MOVF 0x39, W, ACCESS
24A8  20F4     ADDWFC PRODH, W, ACCESS
24AA  6EF7     MOVWF TBLPTRH, ACCESS
24AC  0009     TBLRD*+
24AE  CFF5     MOVFF TABLAT, 0x36
24B0  F036     NOP
24B2  0008     TBLRD*
24B4  CFF5     MOVFF TABLAT, 0x37
24B6  F037     NOP
24B8  5036     MOVF 0x36, W, ACCESS
24BA  5C34     SUBWF 0x34, W, ACCESS
24BC  5037     MOVF 0x37, W, ACCESS
24BE  5835     SUBWFB 0x35, W, ACCESS
24C0  E202     BC 0x24C6
204:                                       M_AI_ADC_Data[index].data_value = *(M_AI_ptrTable[index] + M_AI_Offset_in_table[index][0]);
24C2  D8A7     RCALL __pa_12
2612  DFCB     RCALL __pa_2
2614  CFEE     MOVFF POSTINC0, 0x34
2616  F034     NOP
2618  CFEF     MOVFF INDF0, 0x35
261A  F035     NOP
261C  EFE0     GOTO 0x25C0
261E  F012     NOP
205:                           else if (M_AI_ADC_Data[index].data_value <= BREAK_SENSOR_THRESHOLD && 
24C4  D01D     BRA 0x2500
24C6  D8C5     RCALL __pa_18
206:                                    M_AI_ADC_Data[index].data_value > *(M_AI_ptrTable[index] + M_AI_Offset_in_table[index][1])) 
24C8  E32A     BNC 0x251E
24CA  D8A0     RCALL __pa_11
24CC  D8BA     RCALL __pa_16
24CE  D86D     RCALL __pa_2
24D0  CFEE     MOVFF POSTINC0, 0x36
24D2  F036     NOP
24D4  CFEF     MOVFF INDF0, 0x37
24D6  F037     NOP
24D8  D873     RCALL __pa_3
24DA  22F7     ADDWFC TBLPTRH, F, ACCESS
24DC  0E01     MOVLW 0x1
24DE  26F6     ADDWF TBLPTR, F, ACCESS
24E0  0E00     MOVLW 0x0
24E2  D880     RCALL __pa_6
24E4  0D02     MULLW 0x2
24E6  5036     MOVF 0x36, W, ACCESS
24E8  24F3     ADDWF PROD, W, ACCESS
24EA  6EF6     MOVWF TBLPTR, ACCESS
24EC  5037     MOVF 0x37, W, ACCESS
24EE  20F4     ADDWFC PRODH, W, ACCESS
24F0  D897     RCALL __pa_13
24F2  D885     RCALL __pa_9
24F4  E214     BC 0x251E
25FE  5032     MOVF __tmp_0, W, ACCESS
2600  5C34     SUBWF 0x34, W, ACCESS
2602  5033     MOVF 0x33, W, ACCESS
2604  5835     SUBWFB 0x35, W, ACCESS
2606  0012     RETURN 0
2620  6EF7     MOVWF TBLPTRH, ACCESS
2622  0009     TBLRD*+
2624  CFF5     MOVFF TABLAT, 0x34
2626  F034     NOP
2628  0008     TBLRD*
262A  CFF5     MOVFF TABLAT, 0x35
262C  F035     NOP
262E  0012     RETURN 0
207:                                       M_AI_ADC_Data[index].data_value = *(M_AI_ptrTable[index] + M_AI_Offset_in_table[index][1]);
24F6  D88D     RCALL __pa_12
24F8  22F7     ADDWFC TBLPTRH, F, ACCESS
24FA  0E01     MOVLW 0x1
24FC  26F6     ADDWF TBLPTR, F, ACCESS
24FE  0E00     MOVLW 0x0
2500  D871     RCALL __pa_6
2502  0D02     MULLW 0x2
2504  5034     MOVF 0x34, W, ACCESS
2506  24F3     ADDWF PROD, W, ACCESS
2508  6EF6     MOVWF TBLPTR, ACCESS
250A  5035     MOVF 0x35, W, ACCESS
250C  20F4     ADDWFC PRODH, W, ACCESS
250E  6EF7     MOVWF TBLPTRH, ACCESS
2510  0009     TBLRD*+
2512  CFF5     MOVFF TABLAT, __tmp_0
2514  F032     NOP
2516  0008     TBLRD*
2518  CFF5     MOVFF TABLAT, 0x33
251A  F033     NOP
251C  D8A1     RCALL __pa_19
25C0  0EFE     MOVLW 0xFE
25C2  6AF7     CLRF TBLPTRH, ACCESS
25C4  34DB     RLCF PLUSW2, W, ACCESS
25C6  0BFE     ANDLW 0xFE
25C8  36F7     RLCF TBLPTRH, F, ACCESS
25CA  6EF6     MOVWF TBLPTR, ACCESS
25CC  0E36     MOVLW 0x36
25CE  26F6     ADDWF TBLPTR, F, ACCESS
25D0  0E2D     MOVLW 0x2D
25D2  0012     RETURN 0
25D4  0E03     MOVLW 0x3
25D6  D04A     BRA __pa_20
260C  DFAD     RCALL __pa_0
260E  EFEA     GOTO 0x25D4
2610  F012     NOP
208:           
209:                                   //Вычисление температуры поиском по таблице
210:                                   M_AI_ADC_Data[index].param = M_AI_Search(M_AI_ADC_Data[index].data_value, M_AI_ptrTable[index],
253E  D835     RCALL __pa_2
2540  CFEE     MOVFF POSTINC0, POSTINC1
2542  FFE6     NOP
2544  CFEF     MOVFF INDF0, POSTINC1
2546  FFE6     NOP
2548  D861     RCALL __pa_11
254A  CFEE     MOVFF POSTINC0, POSTINC1
254C  FFE6     NOP
254E  CFEF     MOVFF INDF0, POSTINC1
2550  FFE6     NOP
255E  D876     RCALL __pa_17
25AA  0EFE     MOVLW 0xFE
25AC  6AEA     CLRF FSR0H, ACCESS
25AE  34DB     RLCF PLUSW2, W, ACCESS
25B0  0BFE     ANDLW 0xFE
25B2  36EA     RLCF FSR0H, F, ACCESS
25B4  6EE9     MOVWF FSR0, ACCESS
25B6  0EC3     MOVLW 0xC3
25B8  26E9     ADDWF FSR0, F, ACCESS
25BA  0E00     MOVLW 0x0
25BC  22EA     ADDWFC FSR0H, F, ACCESS
25BE  0012     RETURN 0
2608  0E05     MOVLW 0x5
260A  D030     BRA __pa_20
264C  DF8D     RCALL __pa_0
264E  EF04     GOTO 0x2608
2650  F013     NOP
211:                                                                            M_AI_Size_Table_temperature[index], M_AI_Type_Table_Sorted[index]); 
251E  0EFE     MOVLW 0xFE
2520  50DB     MOVF PLUSW2, W, ACCESS
2522  6AF7     CLRF TBLPTRH, ACCESS
2524  0F34     ADDLW 0x34
2526  6EF6     MOVWF TBLPTR, ACCESS
2528  0E2D     MOVLW 0x2D
252A  D85C     RCALL __pa_6
252C  6EE6     MOVWF POSTINC1, ACCESS
252E  0EFE     MOVLW 0xFE
2530  50DB     MOVF PLUSW2, W, ACCESS
2532  6AF7     CLRF TBLPTRH, ACCESS
2534  0F3D     ADDLW 0x3D
2536  6EF6     MOVWF TBLPTR, ACCESS
2538  0E2D     MOVLW 0x2D
253A  D854     RCALL __pa_6
253C  6EE6     MOVWF POSTINC1, ACCESS
2552  DF08     RCALL M_AI_Search
2554  6E32     MOVWF __tmp_0, ACCESS
2556  0E06     MOVLW 0x6
2558  5EE1     SUBWF FSR1, F, ACCESS
255A  5032     MOVF __tmp_0, W, ACCESS
255C  6EE6     MOVWF POSTINC1, ACCESS
2560  52E5     MOVF POSTDEC1, F, ACCESS
2562  50E7     MOVF INDF1, W, ACCESS
2564  6EEF     MOVWF INDF0, ACCESS
25E4  22F7     ADDWFC TBLPTRH, F, ACCESS
25E6  0008     TBLRD*
25E8  50F5     MOVF TABLAT, W, ACCESS
25EA  0012     RETURN 0
212:                           break;
213:                   
214:                       case CHN_I_SUPPLY_12V:
215:                           break;
216:                   }
217:               }
218:           }
2566  D047     BRA __pa_8
25F6  52E5     MOVF POSTDEC1, F, ACCESS
25F8  CFE7     MOVFF INDF1, FSR2
25FA  FFD9     NOP
25FC  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Menu/menu.c  -------------------------------------
1:             #include "menu.h"
2:             #include "stdint.h"
3:             #include "module_indication.h"
4:             #include "module_management.h"
5:             #include "module_motor.h"
6:             #include "module_logic_inputs.h"
7:             #include "module_analog_inputs.h"
8:             #include "module_fan.h"
9:             #include <string.h>
10:            #include "eeprom.h"
11:            #include "module_sound.h"
12:            
13:            
14:            /* Константа минимальных и максимальных значений порогов величин, 
15:            значения которых устанавливаются в меню.
16:            Размещены последовательно по 2 элемента. 1-ый элемент - минимальное значение,
17:            2-ой элемент - максимальное значение
18:            */
19:            const rom uint8_t Menu_items_thresholds[] = 
20:            {
21:            /* №стр Значение параметра   */
22:            /*P0*/  10, 99,		//время разгона двигателя(дозатора) в 1/100 с. Диапазон значений 10...99 (100мс...990мс)
23:            /*P1*/  1, 60,		//максимальное время вращения двигателя(дозатора) в секундах. Диапазон значений 1...60 (1с...60с)
24:            /*P2*/  28, 100,	//минимальный процент скважности ШИМа при разгоне двигателя(дозатора). Диапазон значений 28...100
25:            /*P3*/  0, 3,		//количество повторных попыток вращения двигателя(дозатора) при несрабатывании концевика, после которого появляется признак аварии
26:            /*P4*/  10, 99,		//время разгона двигателя(ворошителя) в 1/100 с. Диапазон значений 10...99 (100мс...990мс)
27:            /*P5*/  1, 60,		//максимальное время вращения двигателя(ворошителя) в секундах. Диапазон значений 1...60 (1с...60с)
28:            /*P6*/  28, 100,	//минимальный процент скважности ШИМа при разгоне двигателя(ворошителя). Диапазон значений 28...100
29:            /*P7*/  0, 0,		//количество повторных попыток вращения двигателя(ворошителя) при несрабатывании концевика, после которого появляется признак аварии
30:            /*P8*/  10, 99,		//время разгона двигателя(заслонки) в 1/100 с. Диапазон значений 10...99 (100мс...990мс)
31:            /*P9*/  1, 60,		//максимальное время вращения двигателя(заслонки) в секундах. Диапазон значений 1...60 (1с...60с)
32:            /*P10*/ 28, 100,	//минимальный процент скважности ШИМа при разгоне двигателя(заслонки). Диапазон значений 28...100
33:            /*P11*/ 0, 7, 		//количество повторных попыток вращения двигателя(заслонки) при несрабатывании концевика, после которого появляется признак аварии
34:            /*P12*/ 10, 99,		//время разгона двигателя(чистка золы) в 1/100 с. Диапазон значений 10...99 (100мс...990мс)
35:            /*P13*/ 1, 60,		//максимальное время вращения двигателя(чистка золы) в секундах. Диапазон значений 1...60 (1с...60с)
36:            /*P14*/ 28, 100,	//минимальный процент скважности ШИМа при разгоне двигателя(чистка золы). Диапазон значений 28...100
37:            /*P15*/ 0, 0,		//количество повторных попыток вращения двигателя(чистка золы) при несрабатывании концевика, после которого появляется признак аварии
38:            /*P16*/ 2, 2,		//минимальный уровень оборотов вентилятора в режиме поддержания температуры при горении топлива. Диапазон значений 2...2 
39:            /*P17*/ 4, 8,		//максимальный процент скорости оборотов вентилятора. Диапазон значений 4...8
40:            /*P18*/ 5, 120,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для угля)
41:            /*P19*/ 5, 120,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для щепы)
42:            /*P20*/ 5, 120,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для пеллет)
43:            /*P21*/ 1, 36,		//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для угля)
44:            /*P22*/ 1, 36,  	//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для щепы)
45:            /*P23*/ 1, 36,  	//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для пеллет)
46:            /*P24*/ 1, 10,		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для угля)
47:            /*P25*/ 1, 10,		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для щепы)
48:            /*P26*/ 1, 10, 		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для пеллет)
49:            /*P27*/ 6, 42,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для угля)
50:            /*P28*/ 6, 42,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для щепы)
51:            /*P29*/ 6, 42,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для пеллет)
52:            /*P30*/ 1, 15,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для угля
53:            /*P31*/ 1, 8,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для щепы
54:            /*P32*/ 1, 8,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для пеллет
55:            /*P33*/ 1, 8,		// уровень оборотов вентилятора в эконом-режиме от 2 до 8 для угля
56:            /*P34*/ 1, 8,		// уровень оборотов вентилятора в эконом-режиме от 2 до 8 для щепы
57:            /*P35*/ 1, 8,		// уровень оборотов вентилятора в эконом-режиме от 2 до 8 для пеллет
58:            /*P36*/ 1, 8,		// уровень оборотов вентилятора в режиме продувки от 2 до 8 для угля
59:            /*P37*/ 1, 8,		// уровень оборотов вентилятора в режиме продувки от 2 до 8 для щепы
60:            /*P38*/ 1, 8,		// уровень оборотов вентилятора в режиме продувки от 2 до 8 для пеллет
61:            /*P39*/ 30, 90, 	//установленная температура
62:            /*P40*/ 0, 2, 		//тип топлива
63:            /*P41*/ 0, 1, 		//флаг разрешения звука. 1 - разрешён, 0 - запрещён
64:            /*P42*/ 8, 60,		//время в секундах, по истечении которого, если нет действий пользователя, выходим из меню
65:            /*P43*/ 1, 63,		//период загрузок топлива "Уголь"  (в сотнях секунд, от 1 до 54, т.е. от 100 секунд до 1 часа 45 минут) 
66:            /*P44*/ 1, 63, 		//период загрузок топлива "Брикеты" (в сотнях секунд, от 1 до 54, т.е. от 100 секунд до 1.5 часа) 
67:            /*P45*/ 1, 63,		//период загрузок топлива "Пеллеты" (в сотнях секунд, от 1 до 54, т.е. от 100 секунд до 1.5 часа)
68:            /*P46*/ 2, 10,		//пороговое значение разницы между текущей и установленной температурой, по которому делается выход из циклического режима работы вентилятора
69:            /*P47*/ 1, 8,		//уровень оборотов вентилятора для режима горения (фактически, это время, в течение которого симистор открыт в каждом полупериоде синусоиды)  
70:            /*P48*/ 5, 20,       //время работы двигателя чистки золы (в секундах)
71:            /*P49*/ 18, 216     //период между включениями двигателя чистки золы (от 30 минут до 6 часов)
72:            };
73:            
74:            #define QUANTITY_OF_MENU_PARAMETERS	 ( sizeof(Menu_items_thresholds) / Menu_items_thresholds[0] - 1 ) 
75:            #define INCREMENT	1
76:            #define DECREMENT	0
77:            
78:            
79:            uint8_t Menu_Num_Page_Menu = 0; 
80:            uint8_t M_Menu_src_param_menu = 0;
81:            BOOL temper_water_or_gas = 0;
82:            BOOL Menu_manual_supply = OFF;
83:            
84:            BOOL Menu_get_manual_supply(void)
85:            {
86:            	return Menu_manual_supply;
1CC8  0101     MOVLB 0x1
1CCA  5120     MOVF 0x20, W, BANKED
87:            }
1CCC  0012     RETURN 0
88:            
89:            BOOL Menu_get_temper_water_or_gas(void)
90:            {
91:            	return temper_water_or_gas;
1CCE  0101     MOVLB 0x1
1CD0  511F     MOVF 0x1F, W, BANKED
92:            }
1CD2  0012     RETURN 0
93:            
94:            
95:            uint8_t Menu_Get_Num_Page_Menu(void)
96:            {
97:            	return Menu_Num_Page_Menu;
1CD4  0101     MOVLB 0x1
1CD6  511D     MOVF 0x1D, W, BANKED
98:            }
1CD8  0012     RETURN 0
99:            
100:           //Функция увеличения параметра меню до установленного предела
101:           void Menu_inc_param(uint8_t* parameter, const uint8_t threshold_up)
1CDA  DAF3     RCALL __pa_21
22C2  DF9D     RCALL __pa_5
102:           {
103:           	if(*parameter < threshold_up) (*parameter)++;
1CDC  5C32     SUBWF __tmp_0, W, ACCESS
1CDE  E202     BC 0x1CE4
1CE0  DA63     RCALL __pa_0
1CE2  2AEF     INCF INDF0, F, ACCESS
22C4  DF71     RCALL __pa_0
22C6  CFEF     MOVFF INDF0, __tmp_0
22C8  F032     NOP
22CA  0EFC     MOVLW 0xFC
22CC  50DB     MOVF PLUSW2, W, ACCESS
22CE  0012     RETURN 0
104:           }
1CE4  D291     BRA __pa_6
105:           
106:           //Функция уменьшения параметра меню до установленного предела
107:           void Menu_dec_param(uint8_t* parameter, const uint8_t threshold_down)
1CE6  DAED     RCALL __pa_21
108:           {
109:           	if(*parameter > threshold_down) (*parameter)--;
1CE8  80D8     BSF STATUS, 0, ACCESS
1CEA  5432     SUBFWB __tmp_0, W, ACCESS
1CEC  E202     BC 0x1CF2
1CEE  DA5C     RCALL __pa_0
1CF0  06EF     DECF INDF0, F, ACCESS
21A8  0EFD     MOVLW 0xFD
21AA  CFDB     MOVFF PLUSW2, FSR0
21AC  FFE9     NOP
21AE  0EFE     MOVLW 0xFE
21B0  CFDB     MOVFF PLUSW2, FSR0H
21B2  FFEA     NOP
21B4  0012     RETURN 0
110:           }
1CF2  D28A     BRA __pa_6
111:           
112:           /*Функция изменения параметра меню в зависимости от направления изменения (инкремент/декремент)
113:           direction = 1 - инкремент
114:           direction = 0 -декремент
115:           */
116:           void Menu_item_change(uint8_t* menu_param, uint8_t index, BOOL direction)
1CF4  DA84     RCALL __pa_5
117:           {
118:           	if(direction) //увеличение параметра
1CF6  0EFB     MOVLW 0xFB
1CF8  50DB     MOVF PLUSW2, W, ACCESS
1CFA  E007     BZ 0x1D0A
119:           	{
120:           		Menu_inc_param(&menu_param[index], Menu_items_thresholds[index*2 + 1]);  			
1CFC  0EFC     MOVLW 0xFC
1CFE  50DB     MOVF PLUSW2, W, ACCESS
1D00  24E8     ADDWF WREG, W, ACCESS
1D02  0F01     ADDLW 0x1
1D04  DA69     RCALL __pa_4
1D06  DFE9     RCALL Menu_inc_param
21D8  D860     RCALL __pa_18
21DA  0EFC     MOVLW 0xFC
21DC  50DB     MOVF PLUSW2, W, ACCESS
21DE  6EE7     MOVWF INDF1, ACCESS
21E0  0EFD     MOVLW 0xFD
21E2  CFDB     MOVFF PLUSW2, __tmp_0
21E4  F032     NOP
21E6  0EFE     MOVLW 0xFE
21E8  CFDB     MOVFF PLUSW2, 0x33
21EA  F033     NOP
21EC  50E7     MOVF INDF1, W, ACCESS
21EE  2632     ADDWF __tmp_0, F, ACCESS
21F0  0E00     MOVLW 0x0
21F2  2233     ADDWFC 0x33, F, ACCESS
21F4  C032     MOVFF __tmp_0, POSTINC1
21F6  FFE6     NOP
21F8  C033     MOVFF 0x33, POSTINC1
21FA  FFE6     NOP
21FC  0012     RETURN 0
121:           	}
122:           	else
1D08  D005     BRA 0x1D14
123:           	{
124:           		Menu_dec_param(&menu_param[index], Menu_items_thresholds[index*2]);
1D0A  0EFC     MOVLW 0xFC
1D0C  50DB     MOVF PLUSW2, W, ACCESS
1D0E  24E8     ADDWF WREG, W, ACCESS
1D10  DA63     RCALL __pa_4
1D12  DFE9     RCALL Menu_dec_param
1D14  52E5     MOVF POSTDEC1, F, ACCESS
1D16  52E5     MOVF POSTDEC1, F, ACCESS
1D18  52E5     MOVF POSTDEC1, F, ACCESS
125:           	}
126:           }
1D1A  D276     BRA __pa_6
127:           
128:           /* Установка указателя на текущий параметр меню, который подлежит изменению */
129:           void M_Menu_Set_src_param_menu(uint8_t* menu_param, uint8_t num_page)
1D1C  DAD9     RCALL __pa_22
22D0  DF96     RCALL __pa_5
130:           {
131:           	M_Menu_src_param_menu = menu_param[num_page];		
1D1E  DAEB     RCALL __pa_25
1D20  CFEF     MOVFF INDF0, M_Menu_src_param_menu
1D22  F11E     NOP
22D2  0EFC     MOVLW 0xFC
22D4  50DB     MOVF PLUSW2, W, ACCESS
22D6  6EE7     MOVWF INDF1, ACCESS
22D8  DF67     RCALL __pa_0
22DA  50E7     MOVF INDF1, W, ACCESS
22DC  0012     RETURN 0
132:           }
1D24  D271     BRA __pa_6
133:           
134:           
135:           BOOL M_Menu_write_changed_param(uint8_t addr_param, uint8_t src_param, uint8_t changed_param)
1D26  DA6B     RCALL __pa_5
136:           {
137:           	if(src_param != changed_param) //параметр изменился
1D28  0EFC     MOVLW 0xFC
1D2A  50DB     MOVF PLUSW2, W, ACCESS
1D2C  6EF3     MOVWF PROD, ACCESS
1D2E  0EFD     MOVLW 0xFD
1D30  50DB     MOVF PLUSW2, W, ACCESS
1D32  5CF3     SUBWF PROD, W, ACCESS
1D34  E009     BZ 0x1D48
138:           	{
139:           		DataEEWrite (changed_param, addr_param );
1D36  0EFE     MOVLW 0xFE
1D38  CFDB     MOVFF PLUSW2, POSTINC1
1D3A  FFE6     NOP
1D3C  0EFC     MOVLW 0xFC
1D3E  CFDB     MOVFF PLUSW2, POSTINC1
1D40  FFE6     NOP
1D42  DA7E     RCALL __pa_10
140:           		return TRUE;
1D44  0E01     MOVLW 0x1
1D46  D001     BRA 0x1D4A
141:           	}		
142:           	else
143:           	{
144:           		return FALSE;
1D48  0E00     MOVLW 0x0
145:           	}	
146:           }
1D4A  D25E     BRA __pa_6
147:           
148:           /* 
149:           Проверка того, изменился ли параметр меню
150:           Возвращает:
151:           1 - изменился
152:           0 - не изменился 
153:           */
154:           BOOL M_Menu_parameter_is_changed(uint8_t* menu_param, uint8_t num_page)
1D4C  DAC1     RCALL __pa_22
155:           {
156:           	return (M_Menu_src_param_menu != menu_param[num_page]);	
1D4E  DA38     RCALL __pa_2
1D50  0101     MOVLB 0x1
1D52  5D1E     SUBWF 0x1E, W, BANKED
1D54  E102     BNZ 0x1D5A
1D56  0E00     MOVLW 0x0
1D58  D001     BRA 0x1D5C
1D5A  0E01     MOVLW 0x1
157:           }
1D5C  D255     BRA __pa_6
158:           
159:           /* Функция сохранения параметра меню, если он изменился */
160:           void M_Menu_write_parameter(uint8_t* menu_param, uint8_t num_page)
1D5E  DA4F     RCALL __pa_5
161:           {
162:           	if(M_Menu_parameter_is_changed(menu_param, num_page))
1D60  0EFC     MOVLW 0xFC
1D62  CFDB     MOVFF PLUSW2, POSTINC1
1D64  FFE6     NOP
1D66  DA85     RCALL __pa_14
1D68  DFF1     RCALL M_Menu_parameter_is_changed
1D6A  52E5     MOVF POSTDEC1, F, ACCESS
1D6C  52E5     MOVF POSTDEC1, F, ACCESS
1D6E  52E5     MOVF POSTDEC1, F, ACCESS
1D70  0900     IORLW 0x0
1D72  E00A     BZ 0x1D88
2272  0EFD     MOVLW 0xFD
2274  CFDB     MOVFF PLUSW2, POSTINC1
2276  FFE6     NOP
2278  0EFE     MOVLW 0xFE
227A  CFDB     MOVFF PLUSW2, POSTINC1
227C  FFE6     NOP
227E  0012     RETURN 0
163:           		DataEEWrite (menu_param[num_page], num_page );
1D74  0EFC     MOVLW 0xFC
1D76  CFDB     MOVFF PLUSW2, POSTINC1
1D78  FFE6     NOP
1D7A  50DB     MOVF PLUSW2, W, ACCESS
1D7C  6EE7     MOVWF INDF1, ACCESS
1D7E  DA14     RCALL __pa_0
1D80  50E7     MOVF INDF1, W, ACCESS
1D82  DA1E     RCALL __pa_2
1D84  6EE6     MOVWF POSTINC1, ACCESS
1D86  DA5C     RCALL __pa_10
164:           }
1D88  D23F     BRA __pa_6
165:           
166:           
167:           void M_Menu_entry_rotation_clean_chimney(void)
168:           {	M_Ind_Set_Previous_State(M_Ind_Get_state());
1D8A  DA61     RCALL __pa_11
169:           	M_Ind_Set_state(STATE_VIEW_CLEAN_CHIMNEY);
1D8C  0E06     MOVLW 0x6
1D8E  DA40     RCALL __pa_7
170:           	M_Mngm_Set_state(STATE_CLEAN_CHIMNEY);
1D90  0E04     MOVLW 0x4
1D92  DA64     RCALL __pa_12
225C  D847     RCALL __pa_24
22EC  6EE6     MOVWF POSTINC1, ACCESS
22EE  EC05     CALL 0x160A, 0
22F0  F00B     NOP
22F2  52E5     MOVF POSTDEC1, F, ACCESS
22F4  0012     RETURN 0
171:           	M_Ind_Set_blink_mode(NO_NEED_BLINK);
225E  6AE6     CLRF POSTINC1, ACCESS
2260  EC96     CALL 0xD2C, 0
2262  F006     NOP
2264  52E5     MOVF POSTDEC1, F, ACCESS
2266  0012     RETURN 0
172:           	M_Motor_set_state(STATE_MODULE_MOTOR_WAITING_FOR_MOVE_CLEAN_CHIMNEY);
1D94  0E05     MOVLW 0x5
1D96  6EE6     MOVWF POSTINC1, ACCESS
1D98  ECC0     CALL 0x180, 0
1D9A  F000     NOP
1D9C  52E5     MOVF POSTDEC1, F, ACCESS
173:           	M_Motor_set_ctrl_shatter(WAITING_MOVEMENT);
1D9E  0E03     MOVLW 0x3
1DA0  6EE6     MOVWF POSTINC1, ACCESS
1DA2  ECD5     CALL 0x1AA, 0
1DA4  F000     NOP
1DA6  52E5     MOVF POSTDEC1, F, ACCESS
174:           }
1DA8  0012     RETURN 0
175:           
176:           
177:           
178:           /* Обработчик нажатых кнопок 
179:           В зависимости от кода нажатой кнопки устанавливает переменную автомата состояний следущих модулей:
180:           - модуль управления 
181:           - модуль индикации 
182:           */
183:           void Menu_Key_handler(KeyState* key_str)
1DAA  DA29     RCALL __pa_5
21FE  CFD9     MOVFF FSR2, POSTINC1
2200  FFE6     NOP
2202  CFE1     MOVFF FSR1, FSR2
2204  FFD9     NOP
2206  0012     RETURN 0
184:           {
185:           		
186:           	// Все длительные нажатия кнопок обрабатываются только в режиме ожидания
187:           	if ((((key_str->M_LI_Code_Key) & 0x01) == 1U) && 
1DAC  DA7F     RCALL __pa_19
1DAE  0B01     ANDLW 0x1
1DB0  0801     SUBLW 0x1
188:           	((M_Mngm_Get_state() == STATE_WAITING) || ((M_Mngm_Get_state() == STATE_BURNING) && ((key_str->M_LI_Code_Key & NO_KEY_PRESSED) 
1DB4  EC0C     CALL 0x1618, 0
1DB6  F00B     NOP
1DB8  0900     IORLW 0x0
1DBC  EC0C     CALL 0x1618, 0
1DBE  F00B     NOP
1DC0  0802     SUBLW 0x2
1DC4  DA73     RCALL __pa_19
1DC6  0B1E     ANDLW 0x1E
189:           
190:                       == CODE_KEY_DEC_LONG__PRESSED)))) //произошло длительное нажатие какой-либо кнопки
1DB2  E140     BNZ 0x1E34
1DBA  E008     BZ 0x1DCC
1DC2  E138     BNZ 0x1E34
1DC8  080E     SUBLW 0xE
1DCA  E134     BNZ 0x1E34
191:           	{
192:           		//M_Sound_set_button_submergence (ON);  //установить флаг подзвучки кнопки
193:           		switch ((key_str->M_LI_Code_Key) & NO_KEY_PRESSED)
1DCC  DA6F     RCALL __pa_19
1DCE  0B1E     ANDLW 0x1E
1DD0  0A0E     XORLW 0xE
1DD2  E013     BZ 0x1DFA
1DD4  0A18     XORLW 0x18
1DD6  E008     BZ 0x1DE8
1DD8  0A0C     XORLW 0xC
1DDA  E127     BNZ 0x1E2A
194:           		{
195:           			case CODE_KEY_MENU_LONG__PRESSED:
196:           				
197:           					M_Ind_Set_Previous_State(M_Ind_Get_state());
1DDC  DA38     RCALL __pa_11
198:           					M_Ind_Set_state(STATE_VIEW_NUM_PAGE_MENU);
1DDE  0E01     MOVLW 0x1
1DE0  DA17     RCALL __pa_7
199:           					Menu_Num_Page_Menu = 0;
1DE2  0101     MOVLB 0x1
1DE4  6B1D     CLRF 0x1D, BANKED
200:           			break;
1DE6  D021     BRA 0x1E2A
201:           			case CODE_KEY_INC_LONG__PRESSED:
202:           				M_Ind_Set_Previous_State(M_Ind_Get_state());
1DE8  DA32     RCALL __pa_11
224E  ECA5     CALL 0xD4A, 0
2250  F006     NOP
2252  6EE6     MOVWF POSTINC1, ACCESS
2254  EC9D     CALL 0xD3A, 0
2256  F006     NOP
2258  52E5     MOVF POSTDEC1, F, ACCESS
225A  0012     RETURN 0
203:           				M_Ind_Set_state(STATE_VIEW_SUPPLY_FUEL);
1DEA  0E07     MOVLW 0x7
1DEC  DA11     RCALL __pa_7
204:           				M_Mngm_Set_state(STATE_FUEL_SUPPLY);
1DEE  0E01     MOVLW 0x1
1DF0  DA35     RCALL __pa_12
205:           				M_Ind_Set_blink_mode(NO_NEED_BLINK);
206:           				Menu_manual_supply = ON;
1DF2  0101     MOVLB 0x1
1DF4  0E01     MOVLW 0x1
1DF6  6F20     MOVWF 0x20, BANKED
207:           				break;	
1DF8  D018     BRA 0x1E2A
208:           			case CODE_KEY_DEC_LONG__PRESSED: //уловие перехода в режим чистки дымохода
209:           				if(M_Mngm_Get_state() == STATE_BURNING)
1DFA  EC0C     CALL 0x1618, 0
1DFC  F00B     NOP
1DFE  0802     SUBLW 0x2
1E00  E108     BNZ 0x1E12
210:           				{
211:           					temper_water_or_gas = !temper_water_or_gas;
1E02  0101     MOVLB 0x1
1E04  511F     MOVF 0x1F, W, BANKED
1E06  E002     BZ 0x1E0C
1E08  0E00     MOVLW 0x0
1E0A  D001     BRA 0x1E0E
1E0C  0E01     MOVLW 0x1
1E0E  6F1F     MOVWF 0x1F, BANKED
212:           				}
213:           				else
1E10  D00C     BRA 0x1E2A
214:           				{
215:           					if(M_AI_Get_ADC_Data(CHN_T_GAS)->param <=  MAX_TEMPER_GAS_SENSOR_FOR_CLEAN_CHIMNEY && 
1E12  6AE6     CLRF POSTINC1, ACCESS
1E14  DA64     RCALL __pa_23
1E16  0803     SUBLW 0x3
22DE  EC8C     CALL 0x2318, 0
22E0  F011     NOP
22E2  52E5     MOVF POSTDEC1, F, ACCESS
22E4  DF68     RCALL __pa_1
22E6  0E05     MOVLW 0x5
22E8  EFE0     GOTO 0x21C0
22EA  F010     NOP
216:           					M_LI_Get_Limit_Switches()->ls_dispenser_start_state && M_LI_Get_Limit_Switches()->ls_shatter_start_state && 
1E18  E308     BNC 0x1E2A
1E1A  DA7A     RCALL __pa_28
1E1C  50EF     MOVF INDF0, W, ACCESS
1E1E  E005     BZ 0x1E2A
1E20  DA2F     RCALL __pa_15
1E22  E003     BZ 0x1E2A
217:           					!M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state)
1E24  DA31     RCALL __pa_16
1E26  E101     BNZ 0x1E2A
218:           					{
219:           						M_Menu_entry_rotation_clean_chimney();
1E28  DFB0     RCALL M_Menu_entry_rotation_clean_chimney
220:           					}
221:           				}
222:           				break;	
223:           		}
224:           		key_str->M_LI_Code_Key = 0;
1E2A  D9BE     RCALL __pa_0
1E2C  0E02     MOVLW 0x2
1E2E  DA63     RCALL __pa_25
1E30  6AEF     CLRF INDF0, ACCESS
225:           	}
226:           	else if ((key_str->M_LI_Code_Key & 0x80) == 0x80) //произошло короткое нажатие какой-либо кнопки и её отпускание
1E32  D1B9     BRA 0x21A6
1E34  DA3B     RCALL __pa_19
1E36  0B80     ANDLW 0x80
1E38  0880     SUBLW 0x80
1E3A  E001     BZ 0x1E3E
1E3C  D1B4     BRA 0x21A6
227:           	{
228:           		switch ((key_str->M_LI_Code_Key) & NO_KEY_PRESSED)
1E3E  DA36     RCALL __pa_19
1E40  0B1E     ANDLW 0x1E
1E42  0A0E     XORLW 0xE
1E44  E101     BNZ 0x1E48
1E46  D167     BRA 0x2116
1E48  0A18     XORLW 0x18
1E4A  E101     BNZ 0x1E4E
1E4C  D0FE     BRA 0x204A
1E4E  0A0C     XORLW 0xC
1E50  E001     BZ 0x1E54
1E52  D19E     BRA 0x2190
22AC  DF7D     RCALL __pa_0
22AE  0E02     MOVLW 0x2
22B0  EFE0     GOTO 0x21C0
22B2  F010     NOP
229:           		{
230:           			case CODE_KEY_MENU_PRESSED_AND_FREE:
231:           				switch(M_Ind_Get_state())
1E54  ECA5     CALL 0xD4A, 0
1E56  F006     NOP
1E58  0A06     XORLW 0x6
1E5A  E014     BZ 0x1E84
1E5C  0A07     XORLW 0x7
1E5E  E007     BZ 0x1E6E
1E60  0A03     XORLW 0x3
1E62  E11D     BNZ 0x1E9E
232:           				{
233:           					case STATE_VIEW_PARAMETER_MENU:
234:           						M_Ind_Set_state(STATE_VIEW_NUM_PAGE_MENU);	
1E64  0E01     MOVLW 0x1
1E66  D9D4     RCALL __pa_7
235:           						//Сохранение в ЕЕПРОМ параметра, если он изменился
236:           						M_Menu_write_parameter(M_Mngm_Get_parameters_buffer()->buffer, Menu_Num_Page_Menu);
1E68  DA13     RCALL __pa_17
1E6A  DF79     RCALL M_Menu_write_parameter
237:           						M_Ind_setTimeAutoExit(0);
238:           						break;
1E6C  D004     BRA 0x1E76
239:           					case STATE_VIEW_NUM_PAGE_MENU:
240:           						M_Ind_Set_state(STATE_VIEW_PARAMETER_MENU);
1E6E  0E02     MOVLW 0x2
1E70  D9CF     RCALL __pa_7
241:           						M_Menu_Set_src_param_menu(M_Mngm_Get_parameters_buffer()->buffer, Menu_Num_Page_Menu);
1E72  DA0E     RCALL __pa_17
1E74  DF53     RCALL M_Menu_Set_src_param_menu
1E76  52E5     MOVF POSTDEC1, F, ACCESS
1E78  52E5     MOVF POSTDEC1, F, ACCESS
1E7A  52E5     MOVF POSTDEC1, F, ACCESS
242:           						M_Ind_setTimeAutoExit(0);
1E7C  6AE6     CLRF POSTINC1, ACCESS
1E7E  ECDB     CALL 0x11B6, 0
1E80  F008     NOP
243:           						break;
1E82  D00C     BRA 0x1E9C
244:           					case STATE_VIEW_CLEAN_CHIMNEY:
245:           						if((M_Motor_get_ctrl_shatter() == WAITING_MOVEMENT/*NO_MOVEMENT*/) && M_LI_Get_Limit_Switches()->ls_shatter_start_state && !M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state)
1E84  ECDB     CALL 0x1B6, 0
1E86  F000     NOP
1E88  0803     SUBLW 0x3
1E8A  E109     BNZ 0x1E9E
1E8C  D9F9     RCALL __pa_15
1E8E  E007     BZ 0x1E9E
1E90  D9FB     RCALL __pa_16
1E92  E105     BNZ 0x1E9E
246:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
1E94  0E03     MOVLW 0x3
1E96  6EE6     MOVWF POSTINC1, ACCESS
1E98  ECA1     CALL 0xD42, 0
1E9A  F006     NOP
1E9C  52E5     MOVF POSTDEC1, F, ACCESS
247:           						break;
248:           				}
249:           				switch(M_Mngm_Get_state())
1E9E  EC0C     CALL 0x1618, 0
1EA0  F00B     NOP
1EA2  0A05     XORLW 0x5
1EA4  E101     BNZ 0x1EA8
1EA6  D0A9     BRA 0x1FFA
1EA8  0A01     XORLW 0x1
1EAA  E101     BNZ 0x1EAE
1EAC  D08D     BRA 0x1FC8
1EAE  0A06     XORLW 0x6
1EB0  E04A     BZ 0x1F46
1EB2  0A03     XORLW 0x3
1EB4  E03A     BZ 0x1F2A
1EB6  0A01     XORLW 0x1
1EB8  E001     BZ 0x1EBC
1EBA  D16A     BRA 0x2190
250:           				{
251:           					case STATE_WAITING:
252:           						if((M_Ind_Get_state() !=  STATE_VIEW_TEMPERATURE_SETUP) && 
1EBC  ECA5     CALL 0xD4A, 0
1EBE  F006     NOP
1EC0  0804     SUBLW 0x4
253:           						(M_Ind_Get_state() !=  STATE_VIEW_SPEED_FAN_SETUP)
1EC4  ECA5     CALL 0xD4A, 0
1EC6  F006     NOP
1EC8  0809     SUBLW 0x9
254:           						&&(M_Ind_Get_state() !=  STATE_VIEW_PARAMETER_MENU) && 
1EC2  E019     BZ 0x1EF6
1ECA  E015     BZ 0x1EF6
1ECC  ECA5     CALL 0xD4A, 0
1ECE  F006     NOP
1ED0  0802     SUBLW 0x2
1ED2  E011     BZ 0x1EF6
255:           						(M_Ind_Get_state() !=  STATE_VIEW_NUM_PAGE_MENU) && !M_Motor_get_work() /* && (M_Ind_Get_state() != STATE_VIEW_CLEAN_CHIMNEY) */)
1ED4  ECA5     CALL 0xD4A, 0
1ED6  F006     NOP
1ED8  0801     SUBLW 0x1
1EDA  E00D     BZ 0x1EF6
1EDC  ECCF     CALL 0x19E, 0
1EDE  F000     NOP
1EE0  0900     IORLW 0x0
1EE2  E109     BNZ 0x1EF6
256:           						{
257:           								M_Mngm_Set_state(STATE_BURNING);
1EE4  0E02     MOVLW 0x2
1EE6  DA02     RCALL __pa_24
258:           								M_Mngm_set_saved_temperature_water(M_AI_Get_ADC_Data(CHN_T_WATER)->param);
1EE8  0E01     MOVLW 0x1
1EEA  6EE6     MOVWF POSTINC1, ACCESS
1EEC  D9F8     RCALL __pa_23
1EEE  6EE6     MOVWF POSTINC1, ACCESS
1EF0  ECE7     CALL 0x15CE, 0
1EF2  F00A     NOP
1EF4  52E5     MOVF POSTDEC1, F, ACCESS
21B6  CFF3     MOVFF PROD, FSR0
21B8  FFE9     NOP
21BA  CFF4     MOVFF PRODH, FSR0H
21BC  FFEA     NOP
21BE  0012     RETURN 0
259:           						}
260:           						if((M_Ind_Get_state() ==  STATE_VIEW_PARAMETER_MENU) ||
1EF6  ECA5     CALL 0xD4A, 0
1EF8  F006     NOP
1EFA  0802     SUBLW 0x2
261:           							(M_Ind_Get_state() ==  STATE_VIEW_NUM_PAGE_MENU))
1EFC  E101     BNZ 0x1F00
1EFE  D148     BRA 0x2190
1F00  ECA5     CALL 0xD4A, 0
1F02  F006     NOP
1F04  0801     SUBLW 0x1
1F06  E101     BNZ 0x1F0A
1F08  D143     BRA 0x2190
262:           							break;	
263:           						else
264:           						{
265:           							if(M_Ind_Get_state() ==  STATE_VIEW_TEMPERATURE_SETUP)
1F0A  ECA5     CALL 0xD4A, 0
1F0C  F006     NOP
1F0E  0804     SUBLW 0x4
1F10  E03C     BZ 0x1F8A
266:           								M_Menu_write_changed_param(INDEX_OF_TEMPER_SETUP, 
267:           								  	DataEERead (INDEX_OF_TEMPER_SETUP), M_Mngm_Get_parameters_buffer()->menu_parameters.temper_setup);
268:           							else if (M_Ind_Get_state() ==  STATE_VIEW_SPEED_FAN_SETUP)
1F12  ECA5     CALL 0xD4A, 0
1F14  F006     NOP
1F16  0809     SUBLW 0x9
1F18  E16E     BNZ 0x1FF6
269:           								M_Menu_write_changed_param( INDEX_OF_LEVEL_FAN_ROTATION_SPEED_INCREASE, 
1F26  0E2F     MOVLW 0x2F
270:           						  		DataEERead ( INDEX_OF_LEVEL_FAN_ROTATION_SPEED_INCREASE), M_Mngm_Get_parameters_buffer()->menu_parameters.rotational_speed_fan);		
1F1A  D9F1     RCALL __pa_26
1F1C  0E2F     MOVLW 0x2F
1F1E  D950     RCALL __pa_2
1F20  6EE6     MOVWF POSTINC1, ACCESS
1F22  0E2F     MOVLW 0x2F
1F24  D985     RCALL __pa_9
271:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
272:           						}
273:           						break;
1F28  D04A     BRA 0x1FBE
274:           					case STATE_FUEL_SUPPLY:
275:           						if(M_Motor_get_state() == STATE_MODULE_MOTOR_WAITING)  //из рабочего кода
1F2A  ECD2     CALL 0x1A4, 0
1F2C  F000     NOP
1F2E  0801     SUBLW 0x1
1F30  E001     BZ 0x1F34
1F32  D12E     BRA 0x2190
276:           						{
277:           							M_Mngm_Set_state(STATE_BURNING);
1F34  0E02     MOVLW 0x2
1F36  D9DA     RCALL __pa_24
278:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL); //добавил
1F38  0E03     MOVLW 0x3
1F3A  D96A     RCALL __pa_7
279:           							M_Motor_clear_parameters();
1F3C  EC5D     CALL 0xBA, 0
1F3E  F000     NOP
280:           							Menu_manual_supply = OFF;
1F40  0101     MOVLB 0x1
1F42  6B20     CLRF 0x20, BANKED
281:           						}
282:           						break;
1F44  D125     BRA 0x2190
283:           					case STATE_BURNING:
284:           						if(M_Ind_Get_state() !=  STATE_VIEW_TEMPERATURE_SETUP && 
1F46  ECA5     CALL 0xD4A, 0
1F48  F006     NOP
1F4A  0804     SUBLW 0x4
285:           							M_Ind_Get_state() !=  STATE_VIEW_SPEED_FAN_SETUP && M_Motor_get_state() == STATE_MODULE_MOTOR_WAITING )
1F4C  E01A     BZ 0x1F82
1F4E  ECA5     CALL 0xD4A, 0
1F50  F006     NOP
1F52  0809     SUBLW 0x9
1F54  E016     BZ 0x1F82
1F56  ECD2     CALL 0x1A4, 0
1F58  F000     NOP
1F5A  0801     SUBLW 0x1
1F5C  E112     BNZ 0x1F82
286:           						{	
287:           							M_fan_set_ctrl_fan(OFF);
1F5E  6AE6     CLRF POSTINC1, ACCESS
1F60  EC5A     CALL 0x2EB4, 0
1F62  F017     NOP
1F64  52E5     MOVF POSTDEC1, F, ACCESS
288:           							M_Mngm_Set_state(STATE_WAITING);
1F66  6AE6     CLRF POSTINC1, ACCESS
1F68  EC05     CALL 0x160A, 0
1F6A  F00B     NOP
1F6C  52E5     MOVF POSTDEC1, F, ACCESS
289:           							M_Mngm_clear_timeouts();
1F6E  ECEB     CALL 0x15D6, 0
1F70  F00A     NOP
290:           							M_Mngm_clear_accel_fan();
1F72  ECDA     CALL 0x19B4, 0
1F74  F00C     NOP
291:           							M_Mngm_clear_cyclic_mode();
1F76  ECE0     CALL 0x19C0, 0
1F78  F00C     NOP
292:           							M_Mngm_set_burning_state(CALC_PARAMS_PERIOD);
1F7A  6AE6     CLRF POSTINC1, ACCESS
1F7C  ECFA     CALL 0x15F4, 0
1F7E  F00A     NOP
293:           						}
294:           						else
1F80  D0C8     BRA 0x2112
295:           						{
296:           							if(M_Ind_Get_state() ==  STATE_VIEW_TEMPERATURE_SETUP)
1F82  ECA5     CALL 0xD4A, 0
1F84  F006     NOP
1F86  0804     SUBLW 0x4
1F88  E108     BNZ 0x1F9A
297:           								M_Menu_write_changed_param(INDEX_OF_TEMPER_SETUP, 
1F96  0E27     MOVLW 0x27
298:           								DataEERead (INDEX_OF_TEMPER_SETUP), M_Mngm_Get_parameters_buffer()->menu_parameters.temper_setup);
1F8A  D9B9     RCALL __pa_26
1F8C  0E27     MOVLW 0x27
1F8E  D918     RCALL __pa_2
1F90  6EE6     MOVWF POSTINC1, ACCESS
1F92  0E27     MOVLW 0x27
1F94  D94D     RCALL __pa_9
299:           							else if (M_Ind_Get_state() ==  STATE_VIEW_SPEED_FAN_SETUP)
1F98  D012     BRA 0x1FBE
1F9A  ECA5     CALL 0xD4A, 0
1F9C  F006     NOP
1F9E  0809     SUBLW 0x9
1FA0  E12A     BNZ 0x1FF6
300:           							{
301:           								M_Menu_write_changed_param(M_Mngm_get_fanParamOffset() >> 1, 
1FB6  ECB5     CALL 0x156A, 0
1FB8  F00A     NOP
1FBA  40E8     RRNCF WREG, W, ACCESS
1FBC  0B7F     ANDLW 0x7F
1FBE  6EE6     MOVWF POSTINC1, ACCESS
302:           						  		DataEERead (M_Mngm_get_fanParamOffset() >> 1), *M_Mngm_get_pFanLevel());
1FA2  ECB8     CALL 0x1570, 0
1FA4  F00A     NOP
1FA6  D907     RCALL __pa_1
1FA8  50EF     MOVF INDF0, W, ACCESS
1FAA  6EE6     MOVWF POSTINC1, ACCESS
1FAC  ECB5     CALL 0x156A, 0
1FAE  F00A     NOP
1FB0  40E8     RRNCF WREG, W, ACCESS
1FB2  0B7F     ANDLW 0x7F
1FB4  D93D     RCALL __pa_9
1FC0  DEB2     RCALL M_Menu_write_changed_param
1FC2  52E5     MOVF POSTDEC1, F, ACCESS
1FC4  52E5     MOVF POSTDEC1, F, ACCESS
2230  6EE6     MOVWF POSTINC1, ACCESS
2232  6AE6     CLRF POSTINC1, ACCESS
2234  EC2C     CALL 0x2A58, 0
2236  F015     NOP
2238  52E5     MOVF POSTDEC1, F, ACCESS
223A  52E5     MOVF POSTDEC1, F, ACCESS
223C  6EE6     MOVWF POSTINC1, ACCESS
223E  0012     RETURN 0
303:           							}
304:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
305:           						}
306:           						break;
1FC6  D016     BRA 0x1FF4
307:           					case STATE_CLEAN_CHIMNEY:
308:           						if(M_LI_Get_Limit_Switches()->ls_shatter_start_state && !M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state)  //если заслонка закрыта
1FC8  D95B     RCALL __pa_15
1FCA  E101     BNZ 0x1FCE
1FCC  D0E1     BRA 0x2190
1FCE  D95C     RCALL __pa_16
1FD0  E001     BZ 0x1FD4
1FD2  D0DE     BRA 0x2190
309:           						{
310:           							M_Mngm_Set_state(STATE_WAITING);
1FD4  6AE6     CLRF POSTINC1, ACCESS
1FD6  EC05     CALL 0x160A, 0
1FD8  F00B     NOP
1FDA  52E5     MOVF POSTDEC1, F, ACCESS
311:           							M_Motor_set_ctrl_shatter(NO_MOVEMENT);
1FDC  6AE6     CLRF POSTINC1, ACCESS
1FDE  ECD5     CALL 0x1AA, 0
1FE0  F000     NOP
1FE2  52E5     MOVF POSTDEC1, F, ACCESS
312:           							M_Ind_Set_blink_mode(NO_NEED_BLINK);
1FE4  6AE6     CLRF POSTINC1, ACCESS
1FE6  EC96     CALL 0xD2C, 0
1FE8  F006     NOP
1FEA  52E5     MOVF POSTDEC1, F, ACCESS
313:           							M_Motor_set_state(STATE_MODULE_MOTOR_WAITING);
1FEC  0E01     MOVLW 0x1
1FEE  6EE6     MOVWF POSTINC1, ACCESS
1FF0  ECC0     CALL 0x180, 0
1FF2  F000     NOP
1FF4  52E5     MOVF POSTDEC1, F, ACCESS
314:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
1FF6  0E03     MOVLW 0x3
315:           						}
316:           						break;
1FF8  D03A     BRA 0x206E
317:           					case STATE_FAILURE: 	//при аварии сбросить код аварии
318:           						M_Mngm_Set_Code_Failure(CODE_FAILURE_IS_NO_FAILURE);
1FFA  6AE6     CLRF POSTINC1, ACCESS
1FFC  EC12     CALL 0x1624, 0
1FFE  F00B     NOP
2000  52E5     MOVF POSTDEC1, F, ACCESS
319:           						M_Mngm_Get_parameters_buffer()->menu_parameters.code_failure = CODE_FAILURE_IS_NO_FAILURE;
2002  D97D     RCALL __pa_26
2004  0E32     MOVLW 0x32
2006  D977     RCALL __pa_25
2008  6AEF     CLRF INDF0, ACCESS
320:           						DataEEWrite (CODE_FAILURE_IS_NO_FAILURE, INDEX_OF_CODE_FAILURE );
200A  0E32     MOVLW 0x32
200C  6EE6     MOVWF POSTINC1, ACCESS
200E  0E00     MOVLW 0x0
2010  6EE6     MOVWF POSTINC1, ACCESS
2012  D916     RCALL __pa_10
2240  6AE6     CLRF POSTINC1, ACCESS
2242  EC41     CALL 0x2A82, 0
2244  F015     NOP
2246  52E5     MOVF POSTDEC1, F, ACCESS
2248  52E5     MOVF POSTDEC1, F, ACCESS
224A  52E5     MOVF POSTDEC1, F, ACCESS
224C  0012     RETURN 0
321:           						M_Ind_Set_state( M_Ind_Get_Previous_State());
2014  EC9A     CALL 0xD34, 0
2016  F006     NOP
2018  D8FB     RCALL __pa_7
2210  6EE6     MOVWF POSTINC1, ACCESS
2212  ECA1     CALL 0xD42, 0
2214  F006     NOP
2216  52E5     MOVF POSTDEC1, F, ACCESS
2218  0012     RETURN 0
322:           						M_Motor_clear_struct_failure_motor();
201A  ECEB     CALL 0x1D6, 0
201C  F000     NOP
323:           						M_Motor_clear_false_state_LS(QUANTITY_FALSE_LS);
201E  0E07     MOVLW 0x7
2020  6EE6     MOVWF POSTINC1, ACCESS
2022  ECA1     CALL 0x142, 0
2024  F000     NOP
2026  52E5     MOVF POSTDEC1, F, ACCESS
324:           						M_Mngm_Set_state_draught(IS_DRAUGHT);
2028  0E01     MOVLW 0x1
202A  6EE6     MOVWF POSTINC1, ACCESS
202C  EC16     CALL 0x162C, 0
202E  F00B     NOP
2030  52E5     MOVF POSTDEC1, F, ACCESS
325:           						if(M_Motor_get_prev_state() == STATE_MODULE_MOTOR_CLEAN_CHIMNEY)
2032  EC11     CALL 0x222, 0
2034  F001     NOP
2036  0804     SUBLW 0x4
2038  E102     BNZ 0x203E
326:           						{
327:           							M_Motor_set_state(STATE_MODULE_MOTOR_CLEAN_CHIMNEY);
203A  0E04     MOVLW 0x4
328:           						}
329:           						else
203C  D002     BRA 0x2042
330:           						{
331:           							M_Motor_set_state(M_Motor_get_prev_state());
203E  EC11     CALL 0x222, 0
2040  F001     NOP
2042  6EE6     MOVWF POSTINC1, ACCESS
2044  ECC0     CALL 0x180, 0
2046  F000     NOP
332:           						}
333:           						//M_Ind_Set_blink_mode(NO_NEED_BLINK);
334:           						break;
335:           				}
336:           			break;
2048  D064     BRA 0x2112
337:           			case CODE_KEY_INC_PRESSED_AND_FREE:   
338:           				switch(M_Ind_Get_state())
204A  ECA5     CALL 0xD4A, 0
204C  F006     NOP
204E  0A06     XORLW 0x6
2050  E054     BZ 0x20FA
2052  0A0F     XORLW 0xF
2054  E046     BZ 0x20E2
2056  0A0E     XORLW 0xE
2058  E03A     BZ 0x20CE
205A  0A03     XORLW 0x3
205C  E033     BZ 0x20C4
205E  0A06     XORLW 0x6
2060  E02A     BZ 0x20B6
2062  0A03     XORLW 0x3
2064  E008     BZ 0x2076
2066  0A02     XORLW 0x2
2068  E001     BZ 0x206C
206A  D092     BRA 0x2190
339:           				{
340:           					case STATE_VIEW_TEMPERATURE_REAL:  	//просмотр текущей температуры
341:           						M_Ind_Set_state(STATE_VIEW_TEMPERATURE_SETUP);
206C  0E04     MOVLW 0x4
206E  6EE6     MOVWF POSTINC1, ACCESS
2070  ECA1     CALL 0xD42, 0
2072  F006     NOP
342:           						break;
2074  D04E     BRA 0x2112
343:           					case STATE_VIEW_NUM_PAGE_MENU:  		//увеличение номера страницы сервисного меню
344:           						M_Ind_setTimeAutoExit(0);
2076  D8F8     RCALL __pa_13
345:           						Menu_inc_param(&Menu_Num_Page_Menu, QUANTITY_OF_MENU_PARAMETERS);
2078  0EC4     MOVLW 0xC4
207A  6EF6     MOVWF TBLPTR, ACCESS
207C  0E34     MOVLW 0x34
207E  6EF7     MOVWF TBLPTRH, ACCESS
2080  0008     TBLRD*
2082  50F5     MOVF TABLAT, W, ACCESS
2084  6E34     MOVWF 0x34, ACCESS
2086  6A35     CLRF 0x35, ACCESS
2088  0E64     MOVLW 0x64
208A  6E26     MOVWF 0x26, ACCESS
208C  6A27     CLRF 0x27, ACCESS
208E  C034     MOVFF 0x34, 0x2B
2090  F02B     NOP
2092  C035     MOVFF 0x35, 0x2C
2094  F02C     NOP
2096  EC63     CALL 0x36C6, 0
2098  F01B     NOP
209A  C026     MOVFF 0x26, __tmp_0
209C  F032     NOP
209E  C027     MOVFF 0x27, 0x33
20A0  F033     NOP
20A2  0632     DECF __tmp_0, F, ACCESS
20A4  0E00     MOVLW 0x0
20A6  5A33     SUBWFB 0x33, F, ACCESS
20A8  5032     MOVF __tmp_0, W, ACCESS
20AA  6EE6     MOVWF POSTINC1, ACCESS
20AC  0E1D     MOVLW 0x1D
20AE  6EE6     MOVWF POSTINC1, ACCESS
20B0  0E01     MOVLW 0x1
20B2  6EE6     MOVWF POSTINC1, ACCESS
346:           					break;
20B4  D01E     BRA 0x20F2
347:           					case STATE_VIEW_PARAMETER_MENU: 	 //увеличение параметра сервисного меню
348:           						M_Ind_setTimeAutoExit(0);
20B6  D8D8     RCALL __pa_13
349:           						Menu_item_change(M_Mngm_Get_parameters_buffer()->buffer, Menu_Num_Page_Menu, INCREMENT); 
20B8  0E01     MOVLW 0x1
20BA  6EE6     MOVWF POSTINC1, ACCESS
20BC  D8E9     RCALL __pa_17
20BE  DE1A     RCALL Menu_item_change
20C0  52E5     MOVF POSTDEC1, F, ACCESS
350:           					break;
20C2  D018     BRA 0x20F4
351:           					case STATE_VIEW_TEMPERATURE_SETUP: 	//установка температуры
352:           						Menu_inc_param(&(M_Mngm_Get_parameters_buffer()->menu_parameters.temper_setup), 
221A  0E27     MOVLW 0x27
221C  D86C     RCALL __pa_25
221E  CFE9     MOVFF FSR0, __tmp_0
2220  F032     NOP
2222  CFEA     MOVFF FSR0H, 0x33
2224  F033     NOP
2226  CFE9     MOVFF FSR0, POSTINC1
2228  FFE6     NOP
222A  CFEA     MOVFF FSR0H, POSTINC1
222C  FFE6     NOP
222E  0012     RETURN 0
22BC  D820     RCALL __pa_26
22BE  EF0D     GOTO 0x221A
22C0  F011     NOP
22F6  26E9     ADDWF FSR0, F, ACCESS
22F8  0E00     MOVLW 0x0
22FA  22EA     ADDWFC FSR0H, F, ACCESS
22FC  0012     RETURN 0
22FE  ECFE     CALL 0x15FC, 0
2300  F00A     NOP
2302  EFDB     GOTO 0x21B6
2304  F010     NOP
353:           							Menu_items_thresholds[INDEX_TEMPER_SETUP_MAX]);
20C4  0E13     MOVLW 0x13
20C6  6EF6     MOVWF TBLPTR, ACCESS
20C8  0E35     MOVLW 0x35
20CA  D8F4     RCALL __pa_20
22B4  6EF7     MOVWF TBLPTRH, ACCESS
22B6  0008     TBLRD*
22B8  50F5     MOVF TABLAT, W, ACCESS
22BA  6EE6     MOVWF POSTINC1, ACCESS
354:           					break;
20CC  D012     BRA 0x20F2
355:           					case STATE_VIEW_SUPPLY_FUEL :
356:           						M_Motor_set_work(ON); 		//включить алгоритм работы дозатора-заслонки-ворошителя
20CE  0E01     MOVLW 0x1
20D0  6EE6     MOVWF POSTINC1, ACCESS
20D2  ECC9     CALL 0x192, 0
20D4  F000     NOP
20D6  52E5     MOVF POSTDEC1, F, ACCESS
357:           						M_Ind_Set_blink_mode(NEED_BLINK);
20D8  0E01     MOVLW 0x1
20DA  6EE6     MOVWF POSTINC1, ACCESS
20DC  EC96     CALL 0xD2C, 0
20DE  F006     NOP
358:           					break;
20E0  D018     BRA 0x2112
359:           					case STATE_VIEW_SPEED_FAN_SETUP: 	//увеличение уровня оборотов вентилятора
360:           						if(M_Mngm_Get_state() == STATE_BURNING)
20E2  EC0C     CALL 0x1618, 0
20E4  F00B     NOP
20E6  0802     SUBLW 0x2
20E8  E153     BNZ 0x2190
361:           						{
362:           							Menu_inc_param(M_Mngm_get_pFanLevel(), Menu_items_thresholds[M_Mngm_get_fanParamOffset() + 1]);
20EA  ECB5     CALL 0x156A, 0
20EC  F00A     NOP
20EE  0F01     ADDLW 0x1
20F0  D90A     RCALL __pa_27
20F2  DDF3     RCALL Menu_inc_param
20F4  52E5     MOVF POSTDEC1, F, ACCESS
20F6  52E5     MOVF POSTDEC1, F, ACCESS
2306  DFC9     RCALL __pa_18
2308  ECB8     CALL 0x1570, 0
230A  F00A     NOP
230C  EFE3     GOTO 0x21C6
230E  F010     NOP
363:           						}
364:           						break; 	
20F8  D00C     BRA 0x2112
365:           					case STATE_VIEW_CLEAN_CHIMNEY:
366:           						if(M_Motor_get_ctrl_shatter() == WAITING_MOVEMENT/*NO_MOVEMENT */ && M_LI_Get_Limit_Switches()->ls_shatter_start_state 
20FA  ECDB     CALL 0x1B6, 0
20FC  F000     NOP
20FE  0803     SUBLW 0x3
2102  D8BE     RCALL __pa_15
367:           							&& !M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state)
2100  E147     BNZ 0x2190
2104  E045     BZ 0x2190
2106  D8C0     RCALL __pa_16
2108  E143     BNZ 0x2190
368:           							M_Motor_set_ctrl_shatter(MOVEMENT_FORWARD);
210A  0E01     MOVLW 0x1
210C  6EE6     MOVWF POSTINC1, ACCESS
210E  ECD5     CALL 0x1AA, 0
2110  F000     NOP
2112  52E5     MOVF POSTDEC1, F, ACCESS
369:           						break;
370:           				}
371:           			break;
2114  D03D     BRA 0x2190
372:           			case CODE_KEY_DEC_PRESSED_AND_FREE: 
373:           				switch(M_Ind_Get_state())
2116  ECA5     CALL 0xD4A, 0
2118  F006     NOP
211A  0A06     XORLW 0x6
211C  E02C     BZ 0x2176
211E  0A0F     XORLW 0xF
2120  E01F     BZ 0x2160
2122  0A0A     XORLW 0xA
2124  E018     BZ 0x2156
2126  0A07     XORLW 0x7
2128  E011     BZ 0x214C
212A  0A06     XORLW 0x6
212C  E009     BZ 0x2140
212E  0A03     XORLW 0x3
2130  E12F     BNZ 0x2190
374:           				{
375:           					case STATE_VIEW_NUM_PAGE_MENU :
376:           						M_Ind_setTimeAutoExit(0);
2132  D89A     RCALL __pa_13
377:           						Menu_dec_param(&Menu_Num_Page_Menu, 0);
2134  6AE6     CLRF POSTINC1, ACCESS
2136  0E1D     MOVLW 0x1D
2138  6EE6     MOVWF POSTINC1, ACCESS
213A  0E01     MOVLW 0x1
213C  6EE6     MOVWF POSTINC1, ACCESS
378:           					break;
213E  D017     BRA 0x216E
379:           					case STATE_VIEW_PARAMETER_MENU:
380:           						M_Ind_setTimeAutoExit(0);
2140  D893     RCALL __pa_13
2268  6AE6     CLRF POSTINC1, ACCESS
226A  ECDB     CALL 0x11B6, 0
226C  F008     NOP
226E  52E5     MOVF POSTDEC1, F, ACCESS
2270  0012     RETURN 0
381:           						Menu_item_change(M_Mngm_Get_parameters_buffer()->buffer, Menu_Num_Page_Menu, DECREMENT);
2142  6AE6     CLRF POSTINC1, ACCESS
2144  D8A5     RCALL __pa_17
2146  DDD6     RCALL Menu_item_change
2148  52E5     MOVF POSTDEC1, F, ACCESS
2290  C11D     MOVFF Menu_Num_Page_Menu, POSTINC1
2292  FFE6     NOP
2294  D834     RCALL __pa_26
2296  EFE3     GOTO 0x21C6
2298  F010     NOP
382:           					break;
214A  D012     BRA 0x2170
383:           					case STATE_VIEW_TEMPERATURE_SETUP:
384:           						Menu_dec_param(&(M_Mngm_Get_parameters_buffer()->menu_parameters.temper_setup), 
385:           							Menu_items_thresholds[INDEX_TEMPER_SETUP_MIN]);	
214C  0E12     MOVLW 0x12
214E  6EF6     MOVWF TBLPTR, ACCESS
2150  0E35     MOVLW 0x35
2152  D8B0     RCALL __pa_20
386:           					break;
2154  D00C     BRA 0x216E
387:           					case STATE_VIEW_TEMPERATURE_REAL:  					//просмотр текущей температуры
388:           						M_Ind_Set_state(STATE_VIEW_SPEED_FAN_SETUP);
2156  0E09     MOVLW 0x9
2158  6EE6     MOVWF POSTINC1, ACCESS
215A  ECA1     CALL 0xD42, 0
215C  F006     NOP
389:           					break;
215E  D017     BRA 0x218E
390:           					case STATE_VIEW_SPEED_FAN_SETUP:		 	//увеличение уровня оборотов вентилятора
391:           
392:           						if(M_Mngm_Get_state() == STATE_BURNING)
2160  EC0C     CALL 0x1618, 0
2162  F00B     NOP
2164  0802     SUBLW 0x2
2166  E114     BNZ 0x2190
393:           						{
394:           							Menu_dec_param(M_Mngm_get_pFanLevel(), Menu_items_thresholds[M_Mngm_get_fanParamOffset()]);
2168  ECB5     CALL 0x156A, 0
216A  F00A     NOP
216C  D8CC     RCALL __pa_27
216E  DDBB     RCALL Menu_dec_param
2170  52E5     MOVF POSTDEC1, F, ACCESS
2172  52E5     MOVF POSTDEC1, F, ACCESS
21C6  CFF3     MOVFF PROD, __tmp_0
21C8  F032     NOP
21CA  CFF4     MOVFF PRODH, 0x33
21CC  F033     NOP
21CE  CFF3     MOVFF PROD, POSTINC1
21D0  FFE6     NOP
21D2  CFF4     MOVFF PRODH, POSTINC1
21D4  FFE6     NOP
21D6  0012     RETURN 0
229A  6AF7     CLRF TBLPTRH, ACCESS
229C  0FC4     ADDLW 0xC4
229E  6EF6     MOVWF TBLPTR, ACCESS
22A0  0E34     MOVLW 0x34
22A2  22F7     ADDWFC TBLPTRH, F, ACCESS
22A4  0008     TBLRD*
22A6  50F5     MOVF TABLAT, W, ACCESS
22A8  6EE6     MOVWF POSTINC1, ACCESS
22AA  0012     RETURN 0
395:           						}
396:           					break; 
2174  D00C     BRA 0x218E
397:           					case STATE_VIEW_CLEAN_CHIMNEY:
398:           						if(M_Motor_get_ctrl_shatter() == WAITING_MOVEMENT && !M_LI_Get_Limit_Switches()->ls_shatter_start_state 
2176  ECDB     CALL 0x1B6, 0
2178  F000     NOP
217A  0803     SUBLW 0x3
217E  D880     RCALL __pa_15
2280  D847     RCALL __pa_28
2282  0E02     MOVLW 0x2
2284  EFE0     GOTO 0x21C0
2286  F010     NOP
399:           							&& M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state)
217C  E109     BNZ 0x2190
2180  E107     BNZ 0x2190
2182  D882     RCALL __pa_16
2184  E005     BZ 0x2190
21C0  D89A     RCALL __pa_25
21C2  50EF     MOVF INDF0, W, ACCESS
21C4  0012     RETURN 0
2288  D843     RCALL __pa_28
228A  0E04     MOVLW 0x4
228C  EFE0     GOTO 0x21C0
228E  F010     NOP
2310  EC54     CALL 0x26A8, 0
2312  F013     NOP
2314  EFDB     GOTO 0x21B6
2316  F010     NOP
400:           							M_Motor_set_ctrl_shatter(MOVEMENT_BACKWARD);
2186  0E02     MOVLW 0x2
2188  6EE6     MOVWF POSTINC1, ACCESS
218A  ECD5     CALL 0x1AA, 0
218C  F000     NOP
218E  52E5     MOVF POSTDEC1, F, ACCESS
401:           					break;
402:           				}
403:           			break;
404:           			//default:
405:           		}
406:           		memset(key_str, 0, sizeof *(key_str));
2190  0E03     MOVLW 0x3
2192  6EE6     MOVWF POSTINC1, ACCESS
2194  6AE6     CLRF POSTINC1, ACCESS
2196  6AE6     CLRF POSTINC1, ACCESS
2198  D86C     RCALL __pa_14
219A  EC1A     CALL 0x3634, 0
219C  F01B     NOP
219E  6E32     MOVWF __tmp_0, ACCESS
21A0  0E05     MOVLW 0x5
21A2  5EE1     SUBWF FSR1, F, ACCESS
21A4  5032     MOVF __tmp_0, W, ACCESS
407:           	}	
408:           }
21A6  D030     BRA __pa_6
2208  52E5     MOVF POSTDEC1, F, ACCESS
220A  CFE7     MOVFF INDF1, FSR2
220C  FFD9     NOP
220E  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Main/main.c  -------------------------------------
1:             /* Программа для блока управления твердотопливным котлом с автоподачей топлива
2:             Тип МК - PIC18F87J50
3:             Частота выполнения команд - 12 Мгц (83 нс)
4:             Тип ОС - кооперативная, PICOSA (версия 11.03.06)
5:             Системный тик ОС - 1 мс 
6:             Начальная версия ПО - 2.00
7:             Автор - Кругликов Владислав	
8:             Заказчик - Шумейко Роман
9:             */
10:            
11:            #include <p18cxxx.h>
12:            #include <delays.h>
13:            #include "osa.h"
14:            #include "main.h"
15:            #include "task_logic_inputs.h"
16:            #include "task_analog_inputs.h"
17:            #include "task_outs.h"
18:            #include "task_motors.h"
19:            #include "module_analog_inputs.h"
20:            #include "module_management.h"
21:            #include "task_management.h"
22:            #include "module_fan.h"
23:            #include "module_indication.h"
24:            #include "module_motor.h"
25:            #include "module_sound.h"
26:            #include "logicAnalyzer.h"
27:            #include "eeprom.h"
28:            #include "interrupts.h"
29:            #include "module_logic_inputs.h"
30:            
31:            //Конфигурационные биты МК
32:            // CONFIG1L
33:            #pragma config WDTEN = ON       // Watchdog Timer Enable bit (WDT enabled)
34:            #pragma config PLLDIV = 2       // PLL Prescaler Selection bits (Prescale 2 (8 MHz oscillator input drives PLL directly))
35:            #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable bit (Reset on stack overflow/underflow enabled)
36:            #pragma config XINST = OFF      // Extended Instruction Set Enable bit (Instruction set extension and Indexed Addressing mode disabled (Legacy mode))
37:            
38:            // CONFIG1H
39:            #pragma config CPUDIV = OSC1    // /* CPU System Clock Postscaler (No CPU system clock divide) */ CPU System Clock Divide by 2
40:            #pragma config CP0 = OFF        // Code Protection bit (Program memory is not code-protected)
41:            
42:            // CONFIG2L
43:            #pragma config FOSC = HSPLL     // Oscillator Selection bits (HS oscillator, PLL enabled, HSPLL used by USB)
44:            #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor disabled)
45:            #pragma config IESO = OFF       // Two-Speed Start-up (Internal/External Oscillator Switchover) Control bit (Two-Speed Start-up disabled)
46:            
47:            // CONFIG2H
48:            #pragma config WDTPS = 256      // Watchdog Timer Postscaler Select bits (1:256)
49:            
50:            // CONFIG3L
51:            #pragma config EASHFT = OFF     // External Address Bus Shift Enable bit (Address shifting disabled, address on external bus reflects the PC value)
52:            #pragma config MODE = MM        // External Memory Bus Configuration bits (Microcontroller mode - External bus disabled)
53:            #pragma config BW = 16          // Data Bus Width Select bit (16-bit external bus mode)
54:            #pragma config WAIT = OFF       // External Bus Wait Enable bit (Wait states on the external bus are disabled)
55:            
56:            // CONFIG3H
57:            #pragma config CCP2MX = DEFAULT // ECCP2 MUX bit (ECCP2/P2A is multiplexed with RC1)
58:            #pragma config ECCPMX = DEFAULT // ECCPx MUX bit (ECCP1 outputs (P1B/P1C) are multiplexed with RE6 and RE5; ECCP3 outputs (P3B/P3C) are multiplexed with RE4 and RE3)
59:            #pragma config PMPMX = DEFAULT  // PMP Pin Multiplex bit (PMP pins placed on EMB)
60:            #pragma config MSSPMSK = MSK7   // MSSP Address Masking Mode Select bit (7-Bit Address Masking mode enable)
61:            
62:            
63:            
64:            static void Init_PIC(void); //инициализация модулей программы
65:            
66:            
67:            static void Init_PIC(void)
68:            {
69:            	OSCTUNEbits.PLLEN = 1;   //разрешить умножитель частоты 
2FE6  8C9B     BSF OSCTUNE, 6, ACCESS
70:                M_AI_ctor();
2FE8  EC9D     CALL 0x233A, 0
2FEA  F011     NOP
71:            	M_Fan_ctor();
2FEC  EC53     CALL 0x2EA6, 0
2FEE  F017     NOP
72:                M_Ind_ctor();
2FF0  EC75     CALL 0xCEA, 0
2FF2  F006     NOP
73:                M_Motor_ctor();
2FF4  EC44     CALL 0x88, 0
2FF6  F000     NOP
74:                M_Sound_ctor();
2FF8  EC90     CALL 0x3120, 0
2FFA  F018     NOP
75:                DebugTools_ctor();
2FFC  EC94     CALL 0x3328, 0
2FFE  F019     NOP
76:                M_LI_ctor();
3000  EC3A     CALL 0x2674, 0
3002  F013     NOP
77:                Delay10KTCYx(255); //задержка около 212 мс
3004  68E6     SETF POSTINC1, ACCESS
3006  EC4C     CALL 0x3698, 0
3008  F01B     NOP
300A  52E5     MOVF POSTDEC1, F, ACCESS
78:            #ifndef DEBUG_IN_SIMULATOR
79:                EEPROM_ctor();
300C  EC1C     CALL 0x2A38, 0
300E  F015     NOP
80:            #endif
81:                Intr_ctor();
3010  EF1C     GOTO 0x2E38
3012  F017     NOP
82:            }
83:            
84:            void main (void)
85:            {
86:            	Init_PIC();									//инициализация контроллера
3014  DFE8     RCALL Init_PIC
87:            	OS_Init(); 									//инициализация ОСи
3016  ECB4     CALL 0x2968, 0
3018  F014     NOP
88:            	OS_CreateTask(0, Task_Logic_Inputs);	 	//создание задачи опроса логических входов (кнопки, концевики, отработка кнопок в меню)
301A  0EA4     MOVLW 0xA4
301C  6EE6     MOVWF POSTINC1, ACCESS
301E  0E37     MOVLW 0x37
3020  D87B     RCALL __pa_1
89:            	OS_CreateTask(1, Task_Outs);          		//создание задачи управления логическими выходами (индикация, звук, вентилятор с алгоритмом фазового регулирования)		
3022  0EF2     MOVLW 0xF2
3024  6EE6     MOVWF POSTINC1, ACCESS
3026  0E36     MOVLW 0x36
3028  6EE6     MOVWF POSTINC1, ACCESS
302A  0E01     MOVLW 0x1
302C  6EE6     MOVWF POSTINC1, ACCESS
302E  D86E     RCALL __pa_0
90:            	OS_CreateTask(1, Task_Management);          //создание задачи управления с высшим приоритетом 
3030  0E8A     MOVLW 0x8A
3032  6EE6     MOVWF POSTINC1, ACCESS
3034  0E37     MOVLW 0x37
3036  6EE6     MOVWF POSTINC1, ACCESS
3038  0E01     MOVLW 0x1
303A  6EE6     MOVWF POSTINC1, ACCESS
303C  D867     RCALL __pa_0
91:                OS_CreateTask(0, Task_Analog_Inputs);       //создание задачи управления аналоговыми входами
303E  0EBE     MOVLW 0xBE
3040  6EE6     MOVWF POSTINC1, ACCESS
3042  0E37     MOVLW 0x37
3044  D869     RCALL __pa_1
92:            	OS_CreateTask(0, Task_Motors);   			//создание задачи управления двигателями
3046  0E70     MOVLW 0x70
3048  6EE6     MOVWF POSTINC1, ACCESS
304A  0E37     MOVLW 0x37
304C  D865     RCALL __pa_1
310C  ECD5     CALL 0x29AA, 0
310E  F014     NOP
3110  52E5     MOVF POSTDEC1, F, ACCESS
3112  52E5     MOVF POSTDEC1, F, ACCESS
3114  52E5     MOVF POSTDEC1, F, ACCESS
3116  0012     RETURN 0
3118  6EE6     MOVWF POSTINC1, ACCESS
311A  6AE6     CLRF POSTINC1, ACCESS
311C  EF86     GOTO 0x310C
311E  F018     NOP
93:            	OS_Run();
304E  983A     BCF _OS_Flags, 4, ACCESS
3050  863A     BSF _OS_Flags, 3, ACCESS
3052  0E08     MOVLW 0x8
3054  6E04     MOVWF _OS_Best_Priority, ACCESS
3056  C002     MOVFF _OS_LastTask, _OS_CurTask
3058  F03D     NOP
305A  C003     MOVFF 0x3, 0x3E
305C  F03E     NOP
305E  0E19     MOVLW 0x19
3060  5C3D     SUBWF _OS_CurTask, W, ACCESS
3062  0E00     MOVLW 0x0
3064  583E     SUBWFB 0x3E, W, ACCESS
3066  E305     BNC 0x3072
3068  0E05     MOVLW 0x5
306A  6E3D     MOVWF _OS_CurTask, ACCESS
306C  0E00     MOVLW 0x0
306E  6E3E     MOVWF 0x3E, ACCESS
3070  D004     BRA 0x307A
3072  0E05     MOVLW 0x5
3074  263D     ADDWF _OS_CurTask, F, ACCESS
3076  0E00     MOVLW 0x0
3078  223E     ADDWFC 0x3E, F, ACCESS
307A  EC63     CALL 0x28C6, 0
307C  F014     NOP
307E  50EF     MOVF INDF0, W, ACCESS
3080  0B40     ANDLW 0x40
3082  E02A     BZ 0x30D8
3084  50EF     MOVF INDF0, W, ACCESS
3086  0B80     ANDLW 0x80
3088  E127     BNZ 0x30D8
308A  50EF     MOVF INDF0, W, ACCESS
308C  0B07     ANDLW 0x7
308E  6E3B     MOVWF _OS_Temp, ACCESS
3090  80D8     BSF STATUS, 0, ACCESS
3092  5404     SUBFWB _OS_Best_Priority, W, ACCESS
3094  E221     BC 0x30D8
3096  B6EF     BTFSC INDF0, 3, ACCESS
3098  D00D     BRA 0x30B4
309A  EC2C     CALL 0x2858, 0
309C  F014     NOP
309E  503C     MOVF _OS_TempH, W, ACCESS
30A0  5CE1     SUBWF FSR1, W, ACCESS
30A2  E004     BZ 0x30AC
30A4  503C     MOVF _OS_TempH, W, ACCESS
30A6  6EE1     MOVWF FSR1, ACCESS
30A8  50E7     MOVF INDF1, W, ACCESS
30AA  6ED9     MOVWF FSR2, ACCESS
30AC  A63A     BTFSS _OS_Flags, 3, ACCESS
30AE  D7CF     BRA 0x304E
30B0  EC63     CALL 0x28C6, 0
30B2  F014     NOP
30B4  50EF     MOVF INDF0, W, ACCESS
30B6  0B10     ANDLW 0x10
30B8  E003     BZ 0x30C0
30BA  50EF     MOVF INDF0, W, ACCESS
30BC  0B20     ANDLW 0x20
30BE  E00C     BZ 0x30D8
30C0  A6EF     BTFSS INDF0, 3, ACCESS
30C2  D00A     BRA 0x30D8
30C4  883A     BSF _OS_Flags, 4, ACCESS
30C6  C03D     MOVFF _OS_CurTask, _OS_BestTask
30C8  F000     NOP
30CA  C03E     MOVFF 0x3E, 0x1
30CC  F001     NOP
30CE  50EF     MOVF INDF0, W, ACCESS
30D0  0B07     ANDLW 0x7
30D2  6E04     MOVWF _OS_Best_Priority, ACCESS
30D4  50E8     MOVF WREG, W, ACCESS
30D6  E006     BZ 0x30E4
30D8  5002     MOVF _OS_LastTask, W, ACCESS
30DA  183D     XORWF _OS_CurTask, W, ACCESS
30DC  E1C0     BNZ 0x305E
30DE  5003     MOVF 0x3, W, ACCESS
30E0  183E     XORWF 0x3E, W, ACCESS
30E2  E1BD     BNZ 0x305E
30E4  A83A     BTFSS _OS_Flags, 4, ACCESS
30E6  D7B3     BRA 0x304E
30E8  963A     BCF _OS_Flags, 3, ACCESS
30EA  C000     MOVFF _OS_BestTask, _OS_CurTask
30EC  F03D     NOP
30EE  C001     MOVFF 0x1, 0x3E
30F0  F03E     NOP
30F2  C000     MOVFF _OS_BestTask, _OS_LastTask
30F4  F002     NOP
30F6  C001     MOVFF 0x1, 0x3
30F8  F003     NOP
30FA  EC63     CALL 0x28C6, 0
30FC  F014     NOP
30FE  50EF     MOVF INDF0, W, ACCESS
3100  0B40     ANDLW 0x40
3102  E0A5     BZ 0x304E
3104  50EF     MOVF INDF0, W, ACCESS
3106  0B80     ANDLW 0x80
3108  E1A2     BNZ 0x304E
310A  D7C7     BRA 0x309A
94:            }
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Interrupts/interrupts.c  -------------------------
1:             
2:             #include "interrupts.h"
3:             #include <p18cxxx.h>
4:             #include "osa.h"
5:             #include "module_motor.h"
6:             #include "logicAnalyzer.h"
7:             #include "main.h"
8:             
9:             #ifdef ENABLE_INT2
10:                #define TRIS_INTR_NULL_SIN  TRISBbits.TRISB2
11:            #endif
12:            
13:            #pragma code InterruptVectorHigh = 0x08
14:            
15:            static uint16_t cnt_zero_crossing = 0;
16:            static BOOL is_zero_cross = FALSE;  				 //признак перехода через нуль сетевого напряжения
17:            static BOOL  is_impulse_agitator_sensor = FALSE; 	 //признак наличия импульса датчика ворошителя
18:            
19:            void InterruptHandlerHigh (void);
20:            void InterruptVectorHigh (void);
21:            
22:            void InterruptVectorHigh (void)
23:            {
24:                _asm
25:                    goto InterruptHandlerHigh //jump to interrupt routine
0008  EFA0     GOTO 0x2D40
000A  F016     NOP
26:                _endasm
27:            }
000C  0012     RETURN 0
28:            
29:            
30:            #pragma code
31:            #pragma interrupt InterruptHandlerHigh
32:            
33:            /*
34:            Прерывание т/с0 для формирования системного "тика" 1мс
35:            Прерывание т/с3 50мс для формирования временной сетки с шагом 1с 
36:            Прерывание по заднему фронту INT2 (переход через ноль сетевого напряжения 220В)
37:            Прерывание т/с2 215 мкс для формирования программного ШИМа разгона двигателя 
38:            */
39:            void InterruptHandlerHigh (void)
2D40  CFDA     MOVFF FSR2H, PREINC1
2D42  FFE4     NOP
2D44  CFE2     MOVFF FSR1H, FSR2H
2D46  FFDA     NOP
2D48  CFE9     MOVFF FSR0, PREINC1
2D4A  FFE4     NOP
2D4C  CFEA     MOVFF FSR0H, PREINC1
2D4E  FFE4     NOP
2D50  CFF6     MOVFF TBLPTR, PREINC1
2D52  FFE4     NOP
2D54  CFF7     MOVFF TBLPTRH, PREINC1
2D56  FFE4     NOP
2D58  CFF5     MOVFF TABLAT, PREINC1
2D5A  FFE4     NOP
2D5C  CFF3     MOVFF PROD, PREINC1
2D5E  FFE4     NOP
2D60  CFF4     MOVFF PRODH, PREINC1
2D62  FFE4     NOP
2D64  CFFA     MOVFF PCLATH, PREINC1
2D66  FFE4     NOP
2D68  EE00     LFSR 0, 0x1E
2D6A  F01E     NOP
2D6C  0E14     MOVLW 0x14
2D6E  04E8     DECF WREG, W, ACCESS
2D70  E303     BNC 0x2D78
2D72  CFEE     MOVFF POSTINC0, PREINC1
2D74  FFE4     NOP
2D76  D7FB     BRA 0x2D6E
2D78  EE00     LFSR 0, 0x32
2D7A  F032     NOP
2D7C  0E08     MOVLW 0x8
2D7E  04E8     DECF WREG, W, ACCESS
2D80  E303     BNC 0x2D88
2D82  CFEE     MOVFF POSTINC0, PREINC1
2D84  FFE4     NOP
2D86  D7FB     BRA 0x2D7E
2D88  52E6     MOVF POSTINC1, F, ACCESS
40:            {
41:             	OS_EnterInt();
42:             	if (INTCONbits.TMR0IF)      //отсчёт системного тика 1 мс
2D8A  A4F2     BTFSS INTCON, 2, ACCESS
2D8C  D005     BRA 0x2D98
43:                {                           //check for TMR0 overflow
44:                	//DEBUG_PIN_1_TOGGLE;
45:                    TMR0L=0x48;
2D8E  0E48     MOVLW 0x48
2D90  6ED6     MOVWF TMR0, ACCESS
46:                	INTCONbits.TMR0IF = 0;  //clear interrupt flag
2D92  94F2     BCF INTCON, 2, ACCESS
47:                   	OS_Timer();
2D94  ECBF     CALL 0x297E, 0
2D96  F014     NOP
48:            	}
49:                if(INTCON3bits.INT2IF && INTCON3bits.INT2IE) //прерывание по переходу через ноль сетевого напряжения каждые 20 мс
2D98  50F0     MOVF INTCON3, W, ACCESS
2D9A  0B02     ANDLW 0x2
2D9C  E00A     BZ 0x2DB2
2D9E  50F0     MOVF INTCON3, W, ACCESS
2DA0  0B10     ANDLW 0x10
2DA2  E007     BZ 0x2DB2
50:            	{
51:            		INTCON3bits.INT2IF = 0;
2DA4  92F0     BCF INTCON3, 1, ACCESS
52:            		is_zero_cross = TRUE;
2DA6  0101     MOVLB 0x1
2DA8  0E01     MOVLW 0x1
2DAA  6F23     MOVWF 0x23, BANKED
53:            		cnt_zero_crossing++;
2DAC  2B21     INCF 0x21, F, BANKED
2DAE  0E00     MOVLW 0x0
2DB0  2322     ADDWFC 0x22, F, BANKED
54:            	}
55:            	if(INTCON3bits.INT1IF && INTCON3bits.INT1IE) //прерывание по заднему фронту на RB1 для опроса датчика ворошителя
2DB2  50F0     MOVF INTCON3, W, ACCESS
2DB4  0B01     ANDLW 0x1
2DB6  E007     BZ 0x2DC6
2DB8  50F0     MOVF INTCON3, W, ACCESS
2DBA  0B08     ANDLW 0x8
2DBC  E004     BZ 0x2DC6
56:            	{
57:            		is_impulse_agitator_sensor = TRUE;
2DBE  0101     MOVLB 0x1
2DC0  0E01     MOVLW 0x1
2DC2  6F24     MOVWF 0x24, BANKED
58:            		INTCON3bits.INT1IF = 0;
2DC4  90F0     BCF INTCON3, 0, ACCESS
59:            	}
60:            	if(PIR1bits.TMR2IF && PIE1bits.TMR2IE) //период прерывания 205 мкс (для формирования ШИМа разгона двигателя)
2DC6  509E     MOVF PIR1, W, ACCESS
2DC8  0B02     ANDLW 0x2
2DCA  E012     BZ 0x2DF0
2DCC  509D     MOVF PIE1, W, ACCESS
2DCE  0B02     ANDLW 0x2
2DD0  E00F     BZ 0x2DF0
61:            	{
62:            		PIR1bits.TMR2IF = 0;
2DD2  929E     BCF PIR1, 1, ACCESS
63:            		M_Motor_software_PWM_interrrupt(M_Motor_get_ptr_to_motor_pins());
2DD4  EC09     CALL 0x412, 0
2DD6  F002     NOP
2DD8  CFF3     MOVFF PROD, __tmp_1
2DDA  F03F     NOP
2DDC  CFF4     MOVFF PRODH, 0x40
2DDE  F040     NOP
2DE0  CFF3     MOVFF PROD, POSTINC1
2DE2  FFE6     NOP
2DE4  CFF4     MOVFF PRODH, POSTINC1
2DE6  FFE6     NOP
2DE8  EC0B     CALL 0xA16, 0
2DEA  F005     NOP
2DEC  52E5     MOVF POSTDEC1, F, ACCESS
2DEE  52E5     MOVF POSTDEC1, F, ACCESS
64:            	}	
65:            	OS_LeaveInt();
66:            }
2DF0  52E5     MOVF POSTDEC1, F, ACCESS
2DF2  EE00     LFSR 0, 0x39
2DF4  F039     NOP
2DF6  0E08     MOVLW 0x8
2DF8  04E8     DECF WREG, W, ACCESS
2DFA  E303     BNC 0x2E02
2DFC  CFE5     MOVFF POSTDEC1, POSTDEC0
2DFE  FFED     NOP
2E00  D7FB     BRA 0x2DF8
2E02  EE00     LFSR 0, 0x31
2E04  F031     NOP
2E06  0E14     MOVLW 0x14
2E08  04E8     DECF WREG, W, ACCESS
2E0A  E303     BNC 0x2E12
2E0C  CFE5     MOVFF POSTDEC1, POSTDEC0
2E0E  FFED     NOP
2E10  D7FB     BRA 0x2E08
2E12  CFE5     MOVFF POSTDEC1, PCLATH
2E14  FFFA     NOP
2E16  CFE5     MOVFF POSTDEC1, PRODH
2E18  FFF4     NOP
2E1A  CFE5     MOVFF POSTDEC1, PROD
2E1C  FFF3     NOP
2E1E  CFE5     MOVFF POSTDEC1, TABLAT
2E20  FFF5     NOP
2E22  CFE5     MOVFF POSTDEC1, TBLPTRH
2E24  FFF7     NOP
2E26  CFE5     MOVFF POSTDEC1, TBLPTR
2E28  FFF6     NOP
2E2A  CFE5     MOVFF POSTDEC1, FSR0H
2E2C  FFEA     NOP
2E2E  CFE5     MOVFF POSTDEC1, FSR0
2E30  FFE9     NOP
2E32  CFE5     MOVFF POSTDEC1, FSR2H
2E34  FFDA     NOP
2E36  0011     RETFIE 1
67:            
68:            void Intr_ctor( void )
69:            {
70:                INTCON = 0x20;                 //disable global and enable TMR0 interrupt
2E38  0E20     MOVLW 0x20
2E3A  6EF2     MOVWF INTCON, ACCESS
71:            	INTCON2 = 0x84;                //TMR0 high priority
2E3C  0E84     MOVLW 0x84
2E3E  6EF1     MOVWF INTCON2, ACCESS
72:            #ifdef ENABLE_INT2
73:                INTCON3 = 0xD8;		//разрешить внешние прерывания INT2 (для детектирования переходов через нуль 
2E40  0ED8     MOVLW 0xD8
2E42  6EF0     MOVWF INTCON3, ACCESS
74:            #else                   //сетевого напряжения)и INT1 (для опроса датчика ворошителя)
75:            	INTCON3 = 0xC8;
76:            #endif
77:                RCONbits.IPEN = 1;  //enable priority levels
2E44  8ED0     BSF RCON, 7, ACCESS
78:            	TMR0H = 0;          //clear timer
2E46  6AD7     CLRF TMR0H, ACCESS
79:            	TMR0L = 0;          //clear timer
2E48  6AD6     CLRF TMR0, ACCESS
80:            	T0CON = 0xC5;
2E4A  0EC5     MOVLW 0xC5
2E4C  6ED5     MOVWF T0CON, ACCESS
81:            	INTCONbits.GIEH = 1; //enable interrupts
2E4E  8EF2     BSF INTCON, 7, ACCESS
82:                IPR2 = 0x02;        //установить высокий приоритет прерыванию от т/с3
2E50  0E02     MOVLW 0x2
2E52  6EA2     MOVWF IPR2, ACCESS
83:            	T2CON = 0;
2E54  6ACA     CLRF T2CON, ACCESS
84:            	PIE1 = 0;
2E56  6A9D     CLRF PIE1, ACCESS
85:            	PIE2 = 0;
2E58  6AA0     CLRF PIE2, ACCESS
86:                IPR1 = 0x02;                //установить высокий приоритет прерыванию от т/с2
2E5A  6E9F     MOVWF IPR1, ACCESS
87:            #ifdef ENABLE_INT2    
88:                TRIS_INTR_NULL_SIN = IN;    //установить на вход пин внешнего прерівания INT2 (имрульс перехода через нуль 220В)
2E5C  8493     BSF TRISB, 2, ACCESS
89:            #endif
90:            }
2E5E  0012     RETURN 0
91:            
92:            void Intr_set_cnt_zero_crossing(uint8_t value)
2E60  D818     RCALL __pa_0
93:            {
94:            	cnt_zero_crossing = value;
2E62  50DB     MOVF PLUSW2, W, ACCESS
2E64  0101     MOVLB 0x1
2E66  6F21     MOVWF 0x21, BANKED
2E68  6B22     CLRF 0x22, BANKED
95:            }
2E6A  D019     BRA __pa_1
96:            
97:            uint16_t Intr_get_cnt_zero_crossing(void)
98:            {
99:            	return cnt_zero_crossing;
2E6C  C121     MOVFF cnt_zero_crossing, PROD
2E6E  FFF3     NOP
2E70  C122     MOVFF 0x122, PRODH
2E72  FFF4     NOP
100:           }
2E74  0012     RETURN 0
101:           
102:           void Intr_set_is_zero_cross (BOOL value)
2E76  D80D     RCALL __pa_0
103:           {
104:           	is_zero_cross = value;
2E78  CFDB     MOVFF PLUSW2, is_zero_cross
2E7A  F123     NOP
105:           }
2E7C  D010     BRA __pa_1
106:           
107:           BOOL Intr_get_is_zero_cross(void)
108:           {
109:           	return is_zero_cross;
2E7E  0101     MOVLB 0x1
2E80  5123     MOVF 0x23, W, BANKED
110:           }
2E82  0012     RETURN 0
111:           
112:           BOOL Intr_get_is_impulse_agitator_sensor(void)
113:           {
114:           	return is_impulse_agitator_sensor;
2E84  0101     MOVLB 0x1
2E86  5124     MOVF 0x24, W, BANKED
115:           }
2E88  0012     RETURN 0
116:           
117:           void Intr_set_is_impulse_agitator_sensor (BOOL value)
2E8A  D803     RCALL __pa_0
2E92  CFD9     MOVFF FSR2, POSTINC1
2E94  FFE6     NOP
2E96  CFE1     MOVFF FSR1, FSR2
2E98  FFD9     NOP
118:           {
119:           	is_impulse_agitator_sensor = value;
2E8C  CFDB     MOVFF PLUSW2, is_impulse_agitator_sensor
2E8E  F124     NOP
2E9A  0EFE     MOVLW 0xFE
2E9C  0012     RETURN 0
120:           }
2E90  D006     BRA __pa_1
2E9E  52E5     MOVF POSTDEC1, F, ACCESS
2EA0  CFE7     MOVFF INDF1, FSR2
2EA2  FFD9     NOP
2EA4  0012     RETURN 0
121:           
122:           
123:           
124:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/EEPROMmemory/eeprom.c  ---------------------------
1:             //Модуль работы с внешней пакмятью EEPROM
2:             
3:             
4:             #include <p18cxxx.h>
5:             #include <delays.h>
6:             #include "stdint.h"
7:             #include "module_management.h"
8:             #include "i2c.h"
9:             
10:            
11:            //Константа записи параметров меню в энергонезависимой памяти EEPROM
12:            const rom uint8_t start_config[] = 
13:            {
14:            /*P0*/	20, 	//время разгона двигателя (дозатора) в 1/100 с
15:            /*P1*/	3, 		//максимальное время вращения двигателя  (дозатора) в секундах
16:            /*P2*/	72, 	//минимальный процент скважности ШИМа при разгоне двигателя (дозатора)
17:            /*P3*/	3,		//количество повторных попыток вращения двигателя (дозатора) при несрабатывании концевика, после которого появляется признак аварии 
18:            /*P4*/	30,		//время разгона двигателя (ворошителя) в 1/100 с		 
19:            /*P5*/  10,		//максимальное время вращения двигателя  (ворошителя) в секундах 
20:            /*P6*/  100,	//минимальный процент скважности ШИМа при разгоне двигателя (ворошителя)
21:            /*P7*/	0, 		//количество повторных попыток вращения двигателя (ворошителя) при несрабатывании концевика, после которого появляется признак аварии
22:            /*P8*/	20,		//время разгона двигателя (заслонки) в 1/100 с	 
23:            /*P9*/	3,		//максимальное время вращения двигателя  (заслонки) в секундах  
24:            /*P10*/	72, 	//минимальный процент скважности ШИМа при разгоне двигателя (заслонки)
25:            /*P11*/	7, 		//количество повторных попыток вращения двигателя (заслонки) при несрабатывании концевика, после которого появляется признак аварии			
26:            /*P12*/	30,		//время разгона двигателя (чистка золы) в 1/100 с		 
27:            /*P13*/ 30,		//максимальное время вращения двигателя  (чистка золы) в секундах 
28:            /*P14*/ 100,	//минимальный процент скважности ШИМа при разгоне двигателя (чистка золы)
29:            /*P15*/	0,      //количество повторных попыток вращения двигателя (чистка золы)
30:            /*P16*/	2,		//минимальный уровень оборотов вентилятора в режиме поддержания температуры. Диапазон значений 1...3
31:            /*P17*/	3, 		//максимальный процент скорости оборотов вентилятора. Диапазон значений 2...8
32:            /*P18*/	20,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для угля)
33:            /*P19*/	40,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для щепы)	
34:            /*P20*/	40,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для пеллет)
35:            /*P21*/	12, 	//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для угля)
36:            /*P22*/	6,		//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для щепы)
37:            /*P23*/	6,		//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для пеллет)
38:            /*P24*/ 5, 		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для угля)
39:            /*P25*/	2,		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для щепы)
40:            /*P26*/	2,		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для пеллет)
41:            /*P27*/	15, 	//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для угля)
42:            /*P28*/	5,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для щепы)
43:            /*P29*/	5,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для пеллет)
44:            /*P30*/	12,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для угля
45:            /*P31*/	4,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для щепы
46:            /*P32*/	6,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для пеллет
47:            /*P33*/	2,		// уровень оборотов вентилятора в эконом-режиме от 2 до 4 для угля
48:            /*P34*/	3,		// уровень оборотов вентилятора в эконом-режиме от 2 до 4 для щепы
49:            /*P35*/	3,		// уровень оборотов вентилятора в эконом-режиме от 2 до 4 для пеллет
50:            /*P36*/	2,		// уровень оборотов вентилятора в режиме продувки от 2 до 4 для угля
51:            /*P37*/	3,		// уровень оборотов вентилятора в режиме продувки от 2 до 4 для щепы
52:            /*P38*/	3,		// уровень оборотов вентилятора в режиме продувки от 2 до 4 для пеллет
53:            /*P39*/	50, 	//установленная температура
54:            /*P40*/	1, 		//тип топлива
55:            /*P41*/	1,		//флаг разрешения звука. 1 - разрешён, 0 - запрещён	 		
56:            /*P42*/	15,		//время в секундах, по истечении которого, если нет действий пользователя, выходим из меню 
57:            /*P43*/	6,		//период загрузок топлива "Уголь"  (в сотнях секунд)
58:            /*P44*/	3, 		//период загрузок топлива "Брикеты" (в сотнях секунд)
59:            /*P45*/	3, 		//период загрузок топлива "Пеллеты" (в сотнях секунд)
60:            /*P46*/	2, 		//пороговое значение разницы между текущей и установленной температурой, по которой управляется вентилятор
61:            /*P47*/	3,		//уровень оборотов вентилятора для режима горения 2...8 (время в мс, в течение которого симистор открыт в каждом полупериоде синусоиды)
62:            /*P48*/ 10,     //время работы двигателя чистки золы (в секундах)
63:            /*P49*/ 18,     //период между включениями двигателя чистки золы (в сотнях секунд)
64:            /*P50*/ 0, 		//код аварии
65:            /*P51*/ 0, 		//код автомата состояний
66:            /*P52*/ 200		//версия программного обеспечения (2.00)
67:            
68:            
69:            };			
70:            
71:            static void FactorySettingsReadAndWrite( ParametersBuffer* parameters_buffer );
72:            
73:            
74:            void EEPROM_ctor( void )
75:            {
76:                i2c_init();
2A38  EC47     CALL 0x328E, 0
2A3A  F019     NOP
77:                FactorySettingsReadAndWrite( M_Mngm_Get_parameters_buffer( ) );
2A3C  ECFE     CALL 0x15FC, 0
2A3E  F00A     NOP
2A40  CFF3     MOVFF PROD, __tmp_0
2A42  F032     NOP
2A44  CFF4     MOVFF PRODH, 0x33
2A46  F033     NOP
2A48  CFF3     MOVFF PROD, POSTINC1
2A4A  FFE6     NOP
2A4C  CFF4     MOVFF PRODH, POSTINC1
2A4E  FFE6     NOP
2A50  D841     RCALL FactorySettingsReadAndWrite
2A52  52E5     MOVF POSTDEC1, F, ACCESS
2A54  52E5     MOVF POSTDEC1, F, ACCESS
78:            }
2A56  0012     RETURN 0
79:            
80:            //Чтение байта из ячейки внешней EEPROM
81:            uint8_t DataEERead( uint16_t mem_addr )
2A58  D8A2     RCALL __pa_4
82:            {
83:                uint8_t data;
84:            
85:                // Start the I2C Transmission
86:                i2c_start( I2C_START_CMD );
2A5A  D86F     RCALL __pa_0
2B3A  6AE6     CLRF POSTINC1, ACCESS
2B3C  EC59     CALL 0x32B2, 0
2B3E  F019     NOP
2B40  52E5     MOVF POSTDEC1, F, ACCESS
87:                // Write 24LC08B Control Byte - Write
88:                i2c_write( MEMORY_24LC08B_ADDR | I2C_WRITE_CMD );  
2B42  0EA0     MOVLW 0xA0
2B44  D838     RCALL __pa_6
89:                // Sending the 24LC02B 8-Bit Memory Address Pointer
90:                i2c_write( mem_addr & 0x00FF );     
2B46  0EFF     MOVLW 0xFF
2B48  6EE7     MOVWF INDF1, ACCESS
2B4A  0EFD     MOVLW 0xFD
2B4C  CFDB     MOVFF PLUSW2, __tmp_0
2B4E  F032     NOP
2B50  50E7     MOVF INDF1, W, ACCESS
2B52  1632     ANDWF __tmp_0, F, ACCESS
2B54  6A33     CLRF 0x33, ACCESS
2B56  5032     MOVF __tmp_0, W, ACCESS
2B58  EFDB     GOTO 0x2BB6
2B5A  F015     NOP
2BB6  6EE6     MOVWF POSTINC1, ACCESS
2BB8  EC72     CALL 0x32E4, 0
2BBA  F019     NOP
2BBC  52E5     MOVF POSTDEC1, F, ACCESS
2BBE  0012     RETURN 0
91:                // ReStart the I2C Transmission
92:                i2c_start( I2C_REP_START_CMD );
2A5C  0E01     MOVLW 0x1
2A5E  6EE6     MOVWF POSTINC1, ACCESS
2A60  EC59     CALL 0x32B2, 0
2A62  F019     NOP
2A64  52E5     MOVF POSTDEC1, F, ACCESS
93:                // Write 24LC08B Control Byte - Read
94:                i2c_write( MEMORY_24LC08B_ADDR | I2C_READ_CMD); 
2A66  0EA1     MOVLW 0xA1
2A68  D8A6     RCALL __pa_6
95:                // Read Data from 24LC02B EEPROM
96:                data = i2c_read(); 
2A6A  EC83     CALL 0x3306, 0
2A6C  F019     NOP
2A6E  6EDF     MOVWF INDF2, ACCESS
97:                // Master send No Acknowledge Required to the Slave
98:                i2c_master_ack( I2C_DATA_NOACK );  
2A70  0E01     MOVLW 0x1
2A72  6EE6     MOVWF POSTINC1, ACCESS
2A74  EC7A     CALL 0x32F4, 0
2A76  F019     NOP
2A78  52E5     MOVF POSTDEC1, F, ACCESS
99:                // Stop the I2C Transmission
100:               i2c_stop();  
2A7A  EC69     CALL 0x32D2, 0
2A7C  F019     NOP
101:               return data;
2A7E  50DF     MOVF INDF2, W, ACCESS
102:           }
2A80  D07F     BRA __pa_2
103:           
104:           //Запись байта данных data в память EEPROM по адресу mem_addr
105:           void DataEEWrite( uint16_t mem_addr, uint8_t data )
2A82  CFD9     MOVFF FSR2, POSTINC1
2A84  FFE6     NOP
2A86  CFE1     MOVFF FSR1, FSR2
2A88  FFD9     NOP
106:           {
107:               //Tcy = (1/Fin)*4 = 83,3ns
108:               // Tdelay = 4ms => parameter for Delay1KTCYx = 48001
109:               static const rom uint16_t T_DELAY_4MS = 48000U;
110:               
111:               // Start the I2C Write Transmission
112:               i2c_start( I2C_START_CMD );
2A8A  D857     RCALL __pa_0
113:               // Write I2C OP Code
114:               i2c_write( MEMORY_24LC08B_ADDR | I2C_WRITE_CMD );     
115:               // Sending the 24LC02B 8-bit Memory Address Pointer
116:               i2c_write( mem_addr & 0x00FF );       
117:               // Write data to 24LC08B EEPROM
118:               i2c_write( data );   
2A8C  0EFC     MOVLW 0xFC
2A8E  CFDB     MOVFF PLUSW2, POSTINC1
2A90  FFE6     NOP
2A92  EC72     CALL 0x32E4, 0
2A94  F019     NOP
2A96  52E5     MOVF POSTDEC1, F, ACCESS
119:               // Stop I2C Transmission
120:               i2c_stop();  
2A98  EC69     CALL 0x32D2, 0
2A9A  F019     NOP
121:               // Put some delay 4ms here
122:               Delay1KTCYx(T_DELAY_4MS);
2A9C  0E31     MOVLW 0x31
2A9E  6EF6     MOVWF TBLPTR, ACCESS
2AA0  0E36     MOVLW 0x36
2AA2  6EF7     MOVWF TBLPTRH, ACCESS
2AA4  0008     TBLRD*
2AA6  50F5     MOVF TABLAT, W, ACCESS
2AA8  6EE6     MOVWF POSTINC1, ACCESS
2AAA  EC8A     CALL 0x3714, 0
2AAC  F01B     NOP
2AAE  D068     BRA __pa_2
123:           }
124:           
125:           
126:           /*
127:           Функция чтения массива данных с начального адреса start_addr
128:           с количеством size_buff в массив buffer
129:           */
130:           void Read_buffer_EEPROM (const uint8_t start_addr, ParametersBuffer* parameters_buffer, const uint8_t size_buff)
2AB0  D876     RCALL __pa_4
131:           {
132:           	uint8_t count;
133:               
134:                   for ( count = 0; count < size_buff; count++) 
2AB2  6ADF     CLRF INDF2, ACCESS
2AB4  0EFB     MOVLW 0xFB
2AB6  50DB     MOVF PLUSW2, W, ACCESS
2AB8  5CDF     SUBWF INDF2, W, ACCESS
2ABA  E20B     BC 0x2AD2
2AD0  D7F1     BRA 0x2AB4
2B7C  2ADF     INCF INDF2, F, ACCESS
2B7E  0012     RETURN 0
135:                       parameters_buffer->buffer[count] = DataEERead (start_addr + count);
2ABC  0EFE     MOVLW 0xFE
2ABE  50DB     MOVF PLUSW2, W, ACCESS
2AC0  24DF     ADDWF INDF2, W, ACCESS
2AC2  D873     RCALL __pa_5
2AC4  6EE6     MOVWF POSTINC1, ACCESS
2AC6  0EFC     MOVLW 0xFC
2AC8  CFDB     MOVFF PLUSW2, FSR0
2ACA  FFE9     NOP
2ACC  0EFD     MOVLW 0xFD
2ACE  D846     RCALL __pa_1
2B5C  CFDB     MOVFF PLUSW2, FSR0H
2B5E  FFEA     NOP
2B60  CFE9     MOVFF FSR0, __tmp_0
2B62  F032     NOP
2B64  CFEA     MOVFF FSR0H, 0x33
2B66  F033     NOP
2B68  50DF     MOVF INDF2, W, ACCESS
2B6A  010F     MOVLB 0xF
2B6C  24E9     ADDWF FSR0, W, ACCESS
2B6E  6EE9     MOVWF FSR0, ACCESS
2B70  0E00     MOVLW 0x0
2B72  20EA     ADDWFC FSR0H, W, ACCESS
2B74  6EEA     MOVWF FSR0H, ACCESS
2B76  52E5     MOVF POSTDEC1, F, ACCESS
2B78  50E7     MOVF INDF1, W, ACCESS
2B7A  6EEF     MOVWF INDF0, ACCESS
2BAA  6EE6     MOVWF POSTINC1, ACCESS
2BAC  6AE6     CLRF POSTINC1, ACCESS
2BAE  DF54     RCALL DataEERead
2BB0  52E5     MOVF POSTDEC1, F, ACCESS
2BB2  52E5     MOVF POSTDEC1, F, ACCESS
2BB4  0012     RETURN 0
136:           }  
2AD2  D056     BRA __pa_2
137:           
138:           //Чтение конфигурации прибора и запись "заводских установок" в чистую EEPROM
139:           static void FactorySettingsReadAndWrite( ParametersBuffer* parameters_buffer )
2AD4  D864     RCALL __pa_4
2B9E  CFD9     MOVFF FSR2, POSTINC1
2BA0  FFE6     NOP
2BA2  CFE1     MOVFF FSR1, FSR2
2BA4  FFD9     NOP
2BA6  52E6     MOVF POSTINC1, F, ACCESS
2BA8  0012     RETURN 0
140:           {
141:               static const uint8_t SIZE_BUF_AND_ADDR_MAGIC_VAL = sizeof( start_config ) / sizeof( start_config[0] ); 
142:               static const uint8_t MAGIC_VALUE = 0xAA;
143:               static const uint8_t START_ADDR_EEPROM = 0U;
144:               
145:               uint8_t count;
146:               
147:               if( DataEERead( SIZE_BUF_AND_ADDR_MAGIC_VAL ) == MAGIC_VALUE ) //уже есть записанные данные
2AD6  0101     MOVLB 0x1
2AD8  5125     MOVF 0x25, W, BANKED
2ADA  D867     RCALL __pa_5
2ADC  0101     MOVLB 0x1
2ADE  5D26     SUBWF 0x26, W, BANKED
2AE0  E10D     BNZ 0x2AFC
148:               {
149:                   Read_buffer_EEPROM ( START_ADDR_EEPROM, parameters_buffer, SIZE_BUF_AND_ADDR_MAGIC_VAL );
2AE2  C125     MOVFF 0x125, POSTINC1
2AE4  FFE6     NOP
2AE6  0EFD     MOVLW 0xFD
2AE8  CFDB     MOVFF PLUSW2, POSTINC1
2AEA  FFE6     NOP
2AEC  0EFE     MOVLW 0xFE
2AEE  CFDB     MOVFF PLUSW2, POSTINC1
2AF0  FFE6     NOP
2AF2  C127     MOVFF 0x127, POSTINC1
2AF4  FFE6     NOP
2AF6  DFDC     RCALL Read_buffer_EEPROM
2AF8  52E5     MOVF POSTDEC1, F, ACCESS
150:               }
151:               else    //запись "заводских" установок 
2AFA  D01B     BRA 0x2B32
152:               {
153:                   for ( count = 0; count < SIZE_BUF_AND_ADDR_MAGIC_VAL; count++ ) 
2AFC  6ADF     CLRF INDF2, ACCESS
2AFE  0101     MOVLB 0x1
2B00  5125     MOVF 0x25, W, BANKED
2B02  5CDF     SUBWF INDF2, W, ACCESS
2B04  E210     BC 0x2B26
2B24  D7EC     BRA 0x2AFE
154:                   {
155:                       DataEEWrite( START_ADDR_EEPROM + count, start_config[count] );
2B06  D841     RCALL __pa_3
2B08  50DF     MOVF INDF2, W, ACCESS
2B0A  2527     ADDWF 0x27, W, BANKED
2B0C  6EE6     MOVWF POSTINC1, ACCESS
2B0E  6AE6     CLRF POSTINC1, ACCESS
2B10  DFB8     RCALL DataEEWrite
2B12  52E5     MOVF POSTDEC1, F, ACCESS
2B14  52E5     MOVF POSTDEC1, F, ACCESS
2B16  52E5     MOVF POSTDEC1, F, ACCESS
2B8A  50DF     MOVF INDF2, W, ACCESS
2B8C  6AF7     CLRF TBLPTRH, ACCESS
2B8E  0FFC     ADDLW 0xFC
2B90  6EF6     MOVWF TBLPTR, ACCESS
2B92  0E35     MOVLW 0x35
2B94  22F7     ADDWFC TBLPTRH, F, ACCESS
2B96  0008     TBLRD*
2B98  50F5     MOVF TABLAT, W, ACCESS
2B9A  6EE6     MOVWF POSTINC1, ACCESS
2B9C  0012     RETURN 0
156:                       parameters_buffer->buffer[count] = start_config[count];
2B18  D838     RCALL __pa_3
2B1A  0EFD     MOVLW 0xFD
2B1C  CFDB     MOVFF PLUSW2, FSR0
2B1E  FFE9     NOP
2B20  0EFE     MOVLW 0xFE
2B22  D81C     RCALL __pa_1
157:                   }
158:                   DataEEWrite( SIZE_BUF_AND_ADDR_MAGIC_VAL, MAGIC_VALUE ); //write magic value to next EEPROM cell (after last element of buffer)
2B26  C126     MOVFF 0x126, POSTINC1
2B28  FFE6     NOP
2B2A  5125     MOVF 0x25, W, BANKED
2B2C  6EE6     MOVWF POSTINC1, ACCESS
2B2E  6AE6     CLRF POSTINC1, ACCESS
2B30  DFA8     RCALL DataEEWrite
2B32  52E5     MOVF POSTDEC1, F, ACCESS
2B34  52E5     MOVF POSTDEC1, F, ACCESS
2B36  52E5     MOVF POSTDEC1, F, ACCESS
159:               }
160:           }
2B38  D023     BRA __pa_2
2B80  52E5     MOVF POSTDEC1, F, ACCESS
2B82  52E5     MOVF POSTDEC1, F, ACCESS
2B84  CFE7     MOVFF INDF1, FSR2
2B86  FFD9     NOP
2B88  0012     RETURN 0
161:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Drivers/spi.c  -----------------------------------
1:             //Модуль драйвера шины SPI (программного и аппаратного)
2:             
3:             #include <p18f87j50.h>
4:             #include "spi.h"
5:             #include <delays.h>
6:             
7:             #define HW_SPI_SDO_PIN   LATDbits.LATD4    
8:             #define HW_SPI_SDO_TRIS  TRISDbits.TRISD4
9:             #define HW_SPI_SCK_PIN   LATDbits.LATD6
10:            #define HW_SPI_SCK_TRIS  TRISDbits.TRISD6
11:            #define SW_SPI_SDO_PIN   LATJbits.LATJ0
12:            #define SW_SPI_SDO_TRIS  TRISJbits.TRISJ0
13:            #define SW_SPI_SCK_PIN   LATDbits.LATD7
14:            #define SW_SPI_SCK_TRIS  TRISDbits.TRISD7
15:            
16:            
17:            void SPI_init( void )
18:            {
19:                //Инициализация аппаратного модуля SPI2
20:            	SSP2STAT = 0b11000000;
343C  0EC0     MOVLW 0xC0
343E  6E6D     MOVWF SSP2STAT, ACCESS
21:            	SSP2CON1 = 0b00100000;
3440  0E20     MOVLW 0x20
3442  6E6C     MOVWF SSP2CON1, ACCESS
22:                HW_SPI_SDO_TRIS = OUT;
3444  9895     BCF TRISD, 4, ACCESS
23:                HW_SPI_SCK_TRIS = OUT;
3446  9C95     BCF TRISD, 6, ACCESS
24:                
25:                //Инициализация программного модуля SPI2
26:                SW_SPI_SDO_PIN  = 0;
3448  9091     BCF LATJ, 0, ACCESS
27:                SW_SPI_SDO_TRIS = OUT;
344A  909A     BCF TRISJ, 0, ACCESS
28:                SW_SPI_SCK_PIN  = 0;
344C  9E8C     BCF LATD, 7, ACCESS
29:                SW_SPI_SCK_TRIS = OUT;
344E  9E95     BCF TRISD, 7, ACCESS
30:            }
3450  0012     RETURN 0
31:            
32:            //Запись байта данных по аппаратному SPI
33:            void HW_SPI_writeByte( uint8_t data )
3452  CFD9     MOVFF FSR2, POSTINC1
3454  FFE6     NOP
3456  CFE1     MOVFF FSR1, FSR2
3458  FFD9     NOP
345A  52E6     MOVF POSTINC1, F, ACCESS
34:            {
35:                uint8_t temp;  
36:              	
37:              	temp = SSP2BUF;           // Clears BF
345C  506F     MOVF SSP2BUF, W, ACCESS
345E  6EDF     MOVWF INDF2, ACCESS
38:            	PIR1bits.SSPIF = 0;       // Clear interrupt flag
3460  969E     BCF PIR1, 3, ACCESS
39:            	SSP2BUF = data;           // write byte to SSPBUF register
3462  0EFE     MOVLW 0xFE
3464  50DB     MOVF PLUSW2, W, ACCESS
3466  6E6F     MOVWF SSP2BUF, ACCESS
40:            	while(!PIR1bits.SSPIF);   // wait until bus cycle complete  
3468  A69E     BTFSS PIR1, 3, ACCESS
346A  D7FE     BRA 0x3468
41:            }
346C  52E5     MOVF POSTDEC1, F, ACCESS
346E  52E5     MOVF POSTDEC1, F, ACCESS
3470  CFE7     MOVFF INDF1, FSR2
3472  FFD9     NOP
3474  0012     RETURN 0
42:            
43:            //Запись байта данных по программному SPI
44:            void SW_SPI_writeByte( uint8_t data )
3476  CFD9     MOVFF FSR2, POSTINC1
3478  FFE6     NOP
347A  CFE1     MOVFF FSR1, FSR2
347C  FFD9     NOP
347E  52E6     MOVF POSTINC1, F, ACCESS
45:            {
46:                int8_t i;
47:            	
48:                for( i = 0; i < 8; i++ ) 
3480  6ADF     CLRF INDF2, ACCESS
3482  CFDF     MOVFF INDF2, __tmp_0
3484  F032     NOP
3486  0E08     MOVLW 0x8
3488  6EE7     MOVWF INDF1, ACCESS
348A  1832     XORWF __tmp_0, W, ACCESS
348C  AEE8     BTFSS WREG, 7, ACCESS
348E  D002     BRA 0x3494
3490  34E7     RLCF INDF1, W, ACCESS
3492  D002     BRA 0x3498
3494  50E7     MOVF INDF1, W, ACCESS
3496  5C32     SUBWF __tmp_0, W, ACCESS
3498  E210     BC 0x34BA
34B6  2ADF     INCF INDF2, F, ACCESS
34B8  D7E4     BRA 0x3482
49:                {
50:            		SW_SPI_SCK_PIN = 0;
349A  9E8C     BCF LATD, 7, ACCESS
51:                    if ( data & 0x80 ) 
349C  0EFE     MOVLW 0xFE
349E  AEDB     BTFSS PLUSW2, 7, ACCESS
34A0  D002     BRA 0x34A6
52:                        SW_SPI_SDO_PIN = 1;
34A2  8091     BSF LATJ, 0, ACCESS
53:            		else 
34A4  D001     BRA 0x34A8
54:                        SW_SPI_SDO_PIN = 0;
34A6  9091     BCF LATJ, 0, ACCESS
55:            		SW_SPI_SCK_PIN = 1;
34A8  8E8C     BSF LATD, 7, ACCESS
56:                    data <<= 1;
34AA  CFDB     MOVFF PLUSW2, PROD
34AC  FFF3     NOP
34AE  9EF3     BCF PROD, 7, ACCESS
34B0  46F3     RLNCF PROD, F, ACCESS
34B2  CFF3     MOVFF PROD, PLUSW2
34B4  FFDB     NOP
57:                }
58:            }
34BA  52E5     MOVF POSTDEC1, F, ACCESS
34BC  52E5     MOVF POSTDEC1, F, ACCESS
34BE  CFE7     MOVFF INDF1, FSR2
34C0  FFD9     NOP
34C2  0012     RETURN 0
59:            
60:            
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Drivers/i2c.c  -----------------------------------
1:             //Модуль драйвера I2C
2:             
3:             #include "i2c.h"
4:             #include <p18cxxx.h>
5:             
6:             void i2c_init(void) 
7:             {
8:             	// Initial PIC18F87О50 I2C bus Ports: RС4 - SDA and RС3 - SCL, Set as Input
9:             	TRISCbits.TRISC4 = 1;
328E  8894     BSF TRISC, 4, ACCESS
10:            	TRISCbits.TRISC3 = 1;  
3290  8694     BSF TRISC, 3, ACCESS
11:            
12:            	// Initial the PIC18F14K22 MSSP Peripheral I2C Master Mode
13:            	// I2C Master Clock Speed: 16000000 / ((4 * (SSPADD + 1)) = 16000000 / (4 * (39 + 1))
14:            	SSP1STAT = 0x80;      // Slew Rate is disable for 100 kHz mode
3292  0E80     MOVLW 0x80
3294  6EC7     MOVWF SSP1STAT, ACCESS
15:            	SSP1CON1 = 0x28;      // Enable SDA and SCL, I2C Master mode, clock = FOSC/(4 * (SSPADD + 1))
3296  0E28     MOVLW 0x28
3298  6EC6     MOVWF SSP1CON1, ACCESS
16:            	SSP1CON2 = 0x00;      // Reset MSSP Control Register
329A  6AC5     CLRF SSP1CON2, ACCESS
17:            	SSP1ADD = 39;         // Standard I2C Clock speed: 100 kHz  
329C  0E27     MOVLW 0x27
329E  6EC8     MOVWF SSP1ADD, ACCESS
18:            	PIR1bits.SSP1IF=0;    // Clear MSSP Interrupt Flag
32A0  969E     BCF PIR1, 3, ACCESS
19:            }
32A2  0012     RETURN 0
20:            
21:            void i2c_idle(void)
22:            {
23:            	// Wait I2C Bus and Status Idle (i.e. ACKEN, RCEN, PEN, RSEN, SEN)
24:            	while (( SSP1CON2 & 0x1F ) || ( SSP1STATbits.R_W));
32A4  0E1F     MOVLW 0x1F
32A6  14C5     ANDWF SSP1CON2, W, ACCESS
32A8  E1FD     BNZ i2c_idle
32AA  50C7     MOVF SSP1STAT, W, ACCESS
32AC  0B04     ANDLW 0x4
32AE  E1FA     BNZ i2c_idle
25:            }
32B0  0012     RETURN 0
26:            
27:            void i2c_start(uint8_t stype)
32B2  CFD9     MOVFF FSR2, POSTINC1
32B4  FFE6     NOP
32B6  CFE1     MOVFF FSR1, FSR2
32B8  FFD9     NOP
28:            {
29:            	i2c_idle();                     // Ensure the I2C module is idle
32BA  DFF4     RCALL i2c_idle
30:            	if (stype == I2C_START_CMD) 
32BC  0EFE     MOVLW 0xFE
32BE  50DB     MOVF PLUSW2, W, ACCESS
32C0  E104     BNZ 0x32CA
31:            	{
32:            		SSP1CON2bits.SEN = 1;          // Start I2C Transmission
32C2  80C5     BSF SSP1CON2, 0, ACCESS
33:            		while(SSP1CON2bits.SEN);
32C4  A0C5     BTFSS SSP1CON2, 0, ACCESS
32C6  D004     BRA 0x32D0
32C8  D7FD     BRA 0x32C4
34:            	} 
35:            	else 
36:            	{
37:            		SSP1CON2bits.RSEN = 1;         // ReStart I2C Transmission
32CA  82C5     BSF SSP1CON2, 1, ACCESS
38:            		while(SSP1CON2bits.RSEN);
32CC  B2C5     BTFSC SSP1CON2, 1, ACCESS
32CE  D7FE     BRA 0x32CC
39:            	}
40:            }
32D0  D027     BRA __pa_1
41:            
42:            void i2c_stop(void)
43:            {
44:            	// Stop I2C Transmission
45:            	SSP1CON2bits.PEN = 1;
32D2  84C5     BSF SSP1CON2, 2, ACCESS
46:            	while(SSP1CON2bits.PEN);
32D4  B4C5     BTFSC SSP1CON2, 2, ACCESS
32D6  D7FE     BRA 0x32D4
47:            }
32D8  0012     RETURN 0
48:            
49:            uint8_t i2c_slave_ack(void)
50:            {
51:            	// Return: 1 = Acknowledge was not received from slave
52:            	//         0 = Acknowledge was received from slave
53:            	return(SSP1CON2bits.ACKSTAT);
32DA  50C5     MOVF SSP1CON2, W, ACCESS
32DC  0B40     ANDLW 0x40
32DE  E001     BZ 0x32E2
32E0  0E01     MOVLW 0x1
54:            }
32E2  0012     RETURN 0
55:            
56:            void i2c_write(uint8_t data)
32E4  D816     RCALL __pa_0
3312  CFD9     MOVFF FSR2, POSTINC1
3314  FFE6     NOP
3316  CFE1     MOVFF FSR1, FSR2
3318  FFD9     NOP
57:            {
58:              // Send the Data to I2C Bus
59:              SSP1BUF = data;
32E6  6EC9     MOVWF SSP1BUF, ACCESS
331A  0EFE     MOVLW 0xFE
331C  50DB     MOVF PLUSW2, W, ACCESS
331E  0012     RETURN 0
60:              if (SSP1CON1bits.WCOL)         // Check for write collision
32E8  BEC6     BTFSC SSP1CON1, 7, ACCESS
32EA  D003     BRA 0x32F2
61:                return;  
62:            
63:              while(SSP1STATbits.BF);        // Wait until write cycle is complete
32EC  B0C7     BTFSC SSP1STAT, 0, ACCESS
32EE  D7FE     BRA 0x32EC
64:              i2c_idle();                   // Ensure the I2C module is idle
32F0  DFD9     RCALL i2c_idle
65:            }
32F2  D016     BRA __pa_1
66:            
67:            void i2c_master_ack(uint8_t ack_type)
32F4  D80E     RCALL __pa_0
68:            {
69:              SSP1CON2bits.ACKDT = ack_type;   // 1 = Not Acknowledge, 0 = Acknowledge
32F6  B0E8     BTFSC WREG, 0, ACCESS
32F8  8AC5     BSF SSP1CON2, 5, ACCESS
32FA  A0E8     BTFSS WREG, 0, ACCESS
32FC  9AC5     BCF SSP1CON2, 5, ACCESS
70:              SSP1CON2bits.ACKEN = 1;          // Enable Acknowledge
32FE  88C5     BSF SSP1CON2, 4, ACCESS
71:              while (SSP1CON2bits.ACKEN == 1U);
3300  B8C5     BTFSC SSP1CON2, 4, ACCESS
3302  D7FE     BRA 0x3300
72:            }
3304  D00D     BRA __pa_1
3320  52E5     MOVF POSTDEC1, F, ACCESS
3322  CFE7     MOVFF INDF1, FSR2
3324  FFD9     NOP
3326  0012     RETURN 0
73:            
74:            uint8_t i2c_read(void)
75:            {
76:              // Ensure the I2C module is idle
77:              i2c_idle();                         
3306  DFCE     RCALL i2c_idle
78:            
79:              // Enable Receive Mode
80:              SSP1CON2bits.RCEN = 1;           // Enable master for 1 byte reception
3308  86C5     BSF SSP1CON2, 3, ACCESS
81:              while(!SSP1STATbits.BF);         // Wait until buffer is full
330A  A0C7     BTFSS SSP1STAT, 0, ACCESS
330C  D7FE     BRA 0x330A
82:              return SSP1BUF;
330E  50C9     MOVF SSP1BUF, W, ACCESS
83:            }
3310  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/DebugTools/logicAnalyzer.c  ----------------------
1:             #include <p18f87j50.h>
2:             #include <delays.h>
3:             #include "spi.h"
4:             #include "logicAnalyzer.h"
5:             
6:             
7:             #define STROBE_EN_PIN   LATDbits.LATD5
8:             #define STROBE_EN_TRIS  TRISDbits.TRISD5
9:             
10:            
11:            static void DebugTools_setStrobeSPI(void);
12:            
13:            //*****************************************************************************
14:            // Реализация интерфейсных функций
15:            //*****************************************************************************
16:            
17:            //*****************************************************************************
18:            // Инициализация компонента DebugTools
19:            
20:            void DebugTools_ctor(void) 
21:            {
22:                SPI_init();
3328  EC1E     CALL 0x343C, 0
332A  F01A     NOP
23:                STROBE_EN_TRIS = OUT;
332C  9A95     BCF TRISD, 5, ACCESS
24:                STROBE_EN_PIN = 1;
332E  8A8C     BSF LATD, 5, ACCESS
25:            #ifndef ENABLE_SECOND_PUMP 
26:                DEBUG_PIN_1_GPIO = OFF;
3330  9A90     BCF LATH, 5, ACCESS
27:                DEBUG_PIN_1_TRIS = OUT;
3332  9A99     BCF TRISH, 5, ACCESS
28:            #endif
29:            #ifndef ENABLE_TRISTATE_VALVE     
30:                DEBUG_PIN_2_GPIO = OFF; 
3334  968A     BCF LATB, 3, ACCESS
31:                DEBUG_PIN_2_TRIS = OUT; 
3336  9693     BCF TRISB, 3, ACCESS
32:            #endif    
33:            }
3338  0012     RETURN 0
34:            
35:            //*****************************************************************************
36:            // Реализация локальных функций
37:            //*****************************************************************************
38:            
39:            //*****************************************************************************
40:            //Формирование строба
41:            
42:            static void DebugTools_setStrobeSPI(void) 
43:            {
44:                STROBE_EN_PIN = 1;
333A  8A8C     BSF LATD, 5, ACCESS
45:                Delay1TCY();
333C  0000     NOP
46:                STROBE_EN_PIN = 0;
333E  9A8C     BCF LATD, 5, ACCESS
47:            }
3340  0012     RETURN 0
48:            
49:            //*****************************************************************************
50:            // Передача по SPI слова данных
51:            
52:            void DebugTools_trWordSPI(const uint16_t data)
3342  CFD9     MOVFF FSR2, POSTINC1
3344  FFE6     NOP
3346  CFE1     MOVFF FSR1, FSR2
3348  FFD9     NOP
53:            {
54:                DebugTools_setStrobeSPI();
334A  DFF7     RCALL DebugTools_setStrobeSPI
55:                HW_SPI_writeByte(data);
334C  0EFD     MOVLW 0xFD
334E  CFDB     MOVFF PLUSW2, POSTINC1
3350  FFE6     NOP
3352  D826     RCALL __pa_0
33A0  EC29     CALL 0x3452, 0
33A2  F01A     NOP
33A4  52E5     MOVF POSTDEC1, F, ACCESS
56:                Delay10TCYx(3);
33A6  0E03     MOVLW 0x3
33A8  6EE6     MOVWF POSTINC1, ACCESS
33AA  ECEC     CALL 0x37D8, 0
33AC  F01B     NOP
33AE  52E5     MOVF POSTDEC1, F, ACCESS
33B0  0012     RETURN 0
57:            }
3354  52E5     MOVF POSTDEC1, F, ACCESS
3356  CFE7     MOVFF INDF1, FSR2
3358  FFD9     NOP
335A  0012     RETURN 0
58:            
59:            //*****************************************************************************
60:            // Передача по SPI массива данных data с размерностью size
61:            
62:            void DebugTools_trBuffSPI(const uint16_t *data, const uint8_t size) 
335C  CFD9     MOVFF FSR2, POSTINC1
335E  FFE6     NOP
3360  CFE1     MOVFF FSR1, FSR2
3362  FFD9     NOP
3364  52E6     MOVF POSTINC1, F, ACCESS
63:            {
64:                uint8_t count;
65:            
66:                DebugTools_setStrobeSPI();
3366  DFE9     RCALL DebugTools_setStrobeSPI
67:                for (count = 0; count < size; count++) {
3368  6ADF     CLRF INDF2, ACCESS
336A  0EFC     MOVLW 0xFC
336C  50DB     MOVF PLUSW2, W, ACCESS
336E  5CDF     SUBWF INDF2, W, ACCESS
3370  E212     BC 0x3396
3392  2ADF     INCF INDF2, F, ACCESS
3394  D7EA     BRA 0x336A
68:                    HW_SPI_writeByte(data[ count ]);
3372  6A33     CLRF 0x33, ACCESS
3374  34DF     RLCF INDF2, W, ACCESS
3376  0BFE     ANDLW 0xFE
3378  3633     RLCF 0x33, F, ACCESS
337A  6E32     MOVWF __tmp_0, ACCESS
337C  0EFD     MOVLW 0xFD
337E  50DB     MOVF PLUSW2, W, ACCESS
3380  2432     ADDWF __tmp_0, W, ACCESS
3382  6EE9     MOVWF FSR0, ACCESS
3384  0EFE     MOVLW 0xFE
3386  50DB     MOVF PLUSW2, W, ACCESS
3388  2033     ADDWFC 0x33, W, ACCESS
338A  6EEA     MOVWF FSR0H, ACCESS
338C  50EF     MOVF INDF0, W, ACCESS
338E  6EE6     MOVWF POSTINC1, ACCESS
3390  D807     RCALL __pa_0
69:                    Delay10TCYx(3);
70:                }
71:            }
3396  52E5     MOVF POSTDEC1, F, ACCESS
3398  52E5     MOVF POSTDEC1, F, ACCESS
339A  CFE7     MOVFF INDF1, FSR2
339C  FFD9     NOP
339E  0012     RETURN 0
