Disassembly Listing for solid_fuel_boiler
Generated From:
D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/solid_fuel_boiler.X/dist/default/debug/solid_fuel_boiler.X.debug.cof
22 груд. 2019 13:31:58

---  E:/3.46/pic18-lt/cxx-framework/src/traditional/stdclib/memset.asm  ---------------------------------
4CB2  0EFE     MOVLW 0xFE
4CB4  CFE3     MOVFF PLUSW1, FSR0
4CB6  FFE9     NOP
4CB8  0EFF     MOVLW 0xFF
4CBA  CFE3     MOVFF PLUSW1, FSR0H
4CBC  FFEA     NOP
4CBE  CFE9     MOVFF FSR0, PROD
4CC0  FFF3     NOP
4CC2  CFEA     MOVFF FSR0H, PRODH
4CC4  FFF4     NOP
4CC6  0EFB     MOVLW 0xFB
4CC8  50E3     MOVF PLUSW1, W, ACCESS
4CCA  E103     BNZ _2jContinue
4CCC  0EFC     MOVLW 0xFC
4CCE  50E3     MOVF PLUSW1, W, ACCESS
4CD0  E009     BZ jEnd
4CD2  0EFB     MOVLW 0xFB
4CD4  06E3     DECF PLUSW1, F, ACCESS
4CD6  E202     BC _3jEnd
4CD8  0EFC     MOVLW 0xFC
4CDA  06E3     DECF PLUSW1, F, ACCESS
4CDC  0EFD     MOVLW 0xFD
4CDE  50E3     MOVF PLUSW1, W, ACCESS
4CE0  6EEE     MOVWF POSTINC0, ACCESS
4CE2  D7F1     BRA jLoop
4CE4  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/stdclib/__init.c  -----------------------------------
4EB0  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/startup/c018i.c  ------------------------------------
0000  EFF9     GOTO 0x4DF2
0002  F026     NOP
0004  0012     RETURN 0
4DF2  EE1D     LFSR 1, 0xD00
4DF4  F000     NOP
4DF6  EE2D     LFSR 2, 0xD00
4DF8  F000     NOP
4DFA  6AF8     CLRF TBLPTRU, ACCESS
4DFC  9C1F     BCF 0x1F, 6, ACCESS
4DFE  EC99     CALL 0x4932, 0
4E00  F024     NOP
4E02  EC58     CALL 0x4EB0, 0
4E04  F027     NOP
4E06  EC33     CALL 0x4666, 0
4E08  F023     NOP
4E0A  D7FB     BRA 0x4E02
4E0C  0012     RETURN 0
4932  0E0E     MOVLW 0xE
4934  6EF6     MOVWF TBLPTR, ACCESS
4936  0E00     MOVLW 0x0
4938  6EF7     MOVWF TBLPTRH, ACCESS
493A  0E00     MOVLW 0x0
493C  6EF8     MOVWF TBLPTRU, ACCESS
493E  0101     MOVLB 0x1
4940  0009     TBLRD*+
4942  50F5     MOVF TABLAT, W, ACCESS
4944  6F05     MOVWF _OS_Tasks, BANKED
4946  0009     TBLRD*+
4948  50F5     MOVF TABLAT, W, ACCESS
494A  6F06     MOVWF 0x6, BANKED
494C  E103     BNZ 0x4954
494E  6705     TSTFSZ _OS_Tasks, BANKED
4950  D001     BRA 0x4954
4952  D03D     BRA 0x49CE
4954  0009     TBLRD*+
4956  50F5     MOVF TABLAT, W, ACCESS
4958  6F00     MOVWF _OS_BestTask, BANKED
495A  0009     TBLRD*+
495C  50F5     MOVF TABLAT, W, ACCESS
495E  6F01     MOVWF 0x1, BANKED
4960  0009     TBLRD*+
4962  50F5     MOVF TABLAT, W, ACCESS
4964  6F02     MOVWF _OS_LastTask, BANKED
4966  0009     TBLRD*+
4968  0009     TBLRD*+
496A  50F5     MOVF TABLAT, W, ACCESS
496C  6EE9     MOVWF FSR0, ACCESS
496E  0009     TBLRD*+
4970  50F5     MOVF TABLAT, W, ACCESS
4972  6EEA     MOVWF FSR0H, ACCESS
4974  0009     TBLRD*+
4976  0009     TBLRD*+
4978  0009     TBLRD*+
497A  50F5     MOVF TABLAT, W, ACCESS
497C  6F03     MOVWF 0x3, BANKED
497E  0009     TBLRD*+
4980  50F5     MOVF TABLAT, W, ACCESS
4982  6F04     MOVWF _OS_Best_Priority, BANKED
4984  0009     TBLRD*+
4986  0009     TBLRD*+
4988  CFF6     MOVFF TBLPTR, 0x107
498A  F107     NOP
498C  CFF7     MOVFF TBLPTRH, 0x108
498E  F108     NOP
4990  CFF8     MOVFF TBLPTRU, 0x109
4992  F109     NOP
4994  C100     MOVFF 0x100, TBLPTR
4996  FFF6     NOP
4998  C101     MOVFF 0x101, TBLPTRH
499A  FFF7     NOP
499C  C102     MOVFF 0x102, TBLPTRU
499E  FFF8     NOP
49A0  0101     MOVLB 0x1
49A2  5303     MOVF 0x3, F, BANKED
49A4  E102     BNZ 0x49AA
49A6  5304     MOVF _OS_Best_Priority, F, BANKED
49A8  E007     BZ 0x49B8
49AA  0009     TBLRD*+
49AC  50F5     MOVF TABLAT, W, ACCESS
49AE  6EEE     MOVWF POSTINC0, ACCESS
49B0  0703     DECF 0x3, F, BANKED
49B2  E2F8     BC 0x49A4
49B4  0704     DECF _OS_Best_Priority, F, BANKED
49B6  D7F9     BRA 0x49AA
49B8  C107     MOVFF 0x107, TBLPTR
49BA  FFF6     NOP
49BC  C108     MOVFF 0x108, TBLPTRH
49BE  FFF7     NOP
49C0  C109     MOVFF 0x109, TBLPTRU
49C2  FFF8     NOP
49C4  0101     MOVLB 0x1
49C6  0705     DECF _OS_Tasks, F, BANKED
49C8  0E00     MOVLW 0x0
49CA  5B06     SUBWFB 0x6, F, BANKED
49CC  D7BF     BRA 0x494C
49CE  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/proc/p18f87j50.asm  ---------------------------------
4DD2  0E40     MOVLW 0x40
4DD4  6EF3     MOVWF PROD, ACCESS
4DD6  EE00     LFSR 0, 0x0
4DD8  F000     NOP
4DDA  0E0F     MOVLW 0xF
4DDC  D801     RCALL zero_block
4DDE  0012     RETURN 0
4DE0  60EA     CPFSLT FSR0H, ACCESS
4DE2  D002     BRA compare_l
4DE4  6AEE     CLRF POSTINC0, ACCESS
4DE6  D7FC     BRA zero_block
4DE8  50F3     MOVF PROD, W, ACCESS
4DEA  60E9     CPFSLT FSR0, ACCESS
4DEC  0012     RETURN 0
4DEE  6AEE     CLRF POSTINC0, ACCESS
4DF0  D7FC     BRA loop_l
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/math/fxm1616u.asm  ----------------------------------
4C3E  C026     MOVFF 0x26, 0x30
4C40  F030     NOP
4C42  5026     MOVF 0x26, W, ACCESS
4C44  022B     MULWF 0x2B, ACCESS
4C46  CFF4     MOVFF PRODH, 0x25
4C48  F025     NOP
4C4A  CFF3     MOVFF PROD, 0x24
4C4C  F024     NOP
4C4E  5027     MOVF 0x27, W, ACCESS
4C50  022C     MULWF 0x2C, ACCESS
4C52  CFF4     MOVFF PRODH, 0x27
4C54  F027     NOP
4C56  CFF3     MOVFF PROD, 0x26
4C58  F026     NOP
4C5A  022B     MULWF 0x2B, ACCESS
4C5C  50F3     MOVF PROD, W, ACCESS
4C5E  2625     ADDWF 0x25, F, ACCESS
4C60  50F4     MOVF PRODH, W, ACCESS
4C62  2226     ADDWFC 0x26, F, ACCESS
4C64  6AE8     CLRF WREG, ACCESS
4C66  2227     ADDWFC 0x27, F, ACCESS
4C68  5030     MOVF 0x30, W, ACCESS
4C6A  022C     MULWF 0x2C, ACCESS
4C6C  50F3     MOVF PROD, W, ACCESS
4C6E  2625     ADDWF 0x25, F, ACCESS
4C70  50F4     MOVF PRODH, W, ACCESS
4C72  2226     ADDWFC 0x26, F, ACCESS
4C74  6AE8     CLRF WREG, ACCESS
4C76  2227     ADDWFC 0x27, F, ACCESS
4C78  0C00     RETLW 0x0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/math/fxd1616u.c  ------------------------------------
4D44  6A23     CLRF 0x23, ACCESS
4D46  6A22     CLRF 0x22, ACCESS
4D48  0E10     MOVLW 0x10
4D4A  6EE7     MOVWF INDF1, ACCESS
4D4C  90D8     BCF STATUS, 0, ACCESS
4D4E  3626     RLCF 0x26, F, ACCESS
4D50  3627     RLCF 0x27, F, ACCESS
4D52  3622     RLCF 0x22, F, ACCESS
4D54  3623     RLCF 0x23, F, ACCESS
4D56  502B     MOVF 0x2B, W, ACCESS
4D58  5C22     SUBWF 0x22, W, ACCESS
4D5A  502C     MOVF 0x2C, W, ACCESS
4D5C  5823     SUBWFB 0x23, W, ACCESS
4D5E  E305     BNC 0x4D6A
4D60  502B     MOVF 0x2B, W, ACCESS
4D62  5E22     SUBWF 0x22, F, ACCESS
4D64  502C     MOVF 0x2C, W, ACCESS
4D66  5A23     SUBWFB 0x23, F, ACCESS
4D68  2A26     INCF 0x26, F, ACCESS
4D6A  2EE7     DECFSZ INDF1, F, ACCESS
4D6C  D7F0     BRA 0x4D4E
4D6E  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/delays/d1ktcyx.asm  ---------------------------------
4D92  0EFF     MOVLW 0xFF
4D94  50E3     MOVF PLUSW1, W, ACCESS
4D96  6E42     MOVWF DelayCounter1, ACCESS
4D98  0E48     MOVLW 0x48
4D9A  D001     BRA D1K_1
4D9C  0E4C     MOVLW 0x4C
4D9E  6EE7     MOVWF INDF1, ACCESS
4DA0  2EE7     DECFSZ INDF1, F, ACCESS
4DA2  D7FE     BRA 0x4DA0
4DA4  6AE7     CLRF INDF1, ACCESS
4DA6  2EE7     DECFSZ INDF1, F, ACCESS
4DA8  D7FE     BRA 0x4DA6
4DAA  2E42     DECFSZ DelayCounter1, F, ACCESS
4DAC  D7F7     BRA D1Kx
4DAE  0000     NOP
4DB0  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/delays/d10tcyx.asm  ---------------------------------
4E76  0EFF     MOVLW 0xFF
4E78  50E3     MOVF PLUSW1, W, ACCESS
4E7A  4EE8     DCFSNZ WREG, F, ACCESS
4E7C  0012     RETURN 0
4E7E  0000     NOP
4E80  D000     BRA _D10TCYXCODE_000C
4E82  D000     BRA _D10TCYXCODE_000E
4E84  D000     BRA D10_1
4E86  2EE8     DECFSZ WREG, F, ACCESS
4E88  D7FA     BRA D10x
4E8A  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/traditional/delays/d10ktcyx.asm  --------------------------------
4D16  0EFF     MOVLW 0xFF
4D18  50E3     MOVF PLUSW1, W, ACCESS
4D1A  6E42     MOVWF DelayCounter1, ACCESS
4D1C  0EEF     MOVLW 0xEF
4D1E  D001     BRA D10K_1
4D20  0EF3     MOVLW 0xF3
4D22  6EE7     MOVWF INDF1, ACCESS
4D24  2EE7     DECFSZ INDF1, F, ACCESS
4D26  EF92     GOTO 0x4D24
4D28  F026     NOP
4D2A  0E0C     MOVLW 0xC
4D2C  6E41     MOVWF DelayCounter2, ACCESS
4D2E  6AE7     CLRF INDF1, ACCESS
4D30  2EE7     DECFSZ INDF1, F, ACCESS
4D32  EF98     GOTO 0x4D30
4D34  F026     NOP
4D36  2E41     DECFSZ DelayCounter2, F, ACCESS
4D38  EF97     GOTO 0x4D2E
4D3A  F026     NOP
4D3C  2E42     DECFSZ DelayCounter1, F, ACCESS
4D3E  EF90     GOTO 0x4D20
4D40  F026     NOP
4D42  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcsetch.c  --------------------------------------
4CE6  CFD9     MOVFF FSR2, POSTINC1
4CE8  FFE6     NOP
4CEA  CFDA     MOVFF FSR2H, POSTINC1
4CEC  FFE6     NOP
4CEE  CFE1     MOVFF FSR1, FSR2
4CF0  FFD9     NOP
4CF2  CFE2     MOVFF FSR1H, FSR2H
4CF4  FFDA     NOP
4CF6  98C0     BCF WDTCON, 4, ACCESS
4CFE  0EFD     MOVLW 0xFD
4D00  40DB     RRNCF PLUSW2, W, ACCESS
4D02  0B7F     ANDLW 0x7F
4D04  0B3C     ANDLW 0x3C
4CF8  0EC3     MOVLW 0xC3
4CFA  14C2     ANDWF ADCON0, W, ACCESS
4CFC  6E32     MOVWF __tmp_0, ACCESS
4D06  1032     IORWF __tmp_0, W, ACCESS
4D08  6EC2     MOVWF ADCON0, ACCESS
4D0A  52E5     MOVF POSTDEC1, F, ACCESS
4D0C  CFE5     MOVFF POSTDEC1, FSR2H
4D0E  FFDA     NOP
4D10  CFE7     MOVFF INDF1, FSR2
4D12  FFD9     NOP
4D14  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcread.c  ---------------------------------------
4E8C  50C4     MOVF ADRESH, W, ACCESS
4E8E  6E35     MOVWF 0x35, ACCESS
4E90  6A34     CLRF 0x34, ACCESS
4E92  50C3     MOVF ADRES, W, ACCESS
4E94  1034     IORWF 0x34, W, ACCESS
4E96  6EF3     MOVWF PROD, ACCESS
4E98  C035     MOVFF 0x35, PRODH
4E9A  FFF4     NOP
4E9C  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcopen.c  ---------------------------------------
4AF0  CFD9     MOVFF FSR2, POSTINC1
4AF2  FFE6     NOP
4AF4  CFDA     MOVFF FSR2H, POSTINC1
4AF6  FFE6     NOP
4AF8  CFE1     MOVFF FSR1, FSR2
4AFA  FFD9     NOP
4AFC  CFE2     MOVFF FSR1H, FSR2H
4AFE  FFDA     NOP
4B00  98C0     BCF WDTCON, 4, ACCESS
4B02  6AC2     CLRF ADCON0, ACCESS
4B04  6AC1     CLRF ADCON1, ACCESS
4B12  0EFC     MOVLW 0xFC
4B14  40DB     RRNCF PLUSW2, W, ACCESS
4B16  0B7F     ANDLW 0x7F
4B18  0B3C     ANDLW 0x3C
4B06  0EFC     MOVLW 0xFC
4B08  50DB     MOVF PLUSW2, W, ACCESS
4B0A  0D40     MULLW 0x40
4B0C  50F3     MOVF PROD, W, ACCESS
4B0E  0BC0     ANDLW 0xC0
4B10  6E32     MOVWF __tmp_0, ACCESS
4B1A  1032     IORWF __tmp_0, W, ACCESS
4B1C  6EC2     MOVWF ADCON0, ACCESS
4B34  0EFD     MOVLW 0xFD
4B36  50DB     MOVF PLUSW2, W, ACCESS
4B38  0B80     ANDLW 0x80
4B2A  0EFD     MOVLW 0xFD
4B2C  38DB     SWAPF PLUSW2, W, ACCESS
4B2E  0B0F     ANDLW 0xF
4B30  0B07     ANDLW 0x7
4B32  6E32     MOVWF __tmp_0, ACCESS
4B3A  1032     IORWF __tmp_0, W, ACCESS
4B1E  0EFD     MOVLW 0xFD
4B20  50DB     MOVF PLUSW2, W, ACCESS
4B22  0D04     MULLW 0x4
4B24  50F3     MOVF PROD, W, ACCESS
4B26  0B38     ANDLW 0x38
4B28  6E33     MOVWF 0x33, ACCESS
4B3C  1033     IORWF 0x33, W, ACCESS
4B3E  6EC1     MOVWF ADCON1, ACCESS
4B40  88C0     BSF WDTCON, 4, ACCESS
4B42  0EFA     MOVLW 0xFA
4B44  50DB     MOVF PLUSW2, W, ACCESS
4B46  6EC1     MOVWF ADCON1, ACCESS
4B48  0EFA     MOVLW 0xFA
4B4A  CFDB     MOVFF PLUSW2, __tmp_0
4B4C  F032     NOP
4B4E  0EFB     MOVLW 0xFB
4B50  CFDB     MOVFF PLUSW2, 0x33
4B52  F033     NOP
4B54  C033     MOVFF 0x33, __tmp_0
4B56  F032     NOP
4B58  6A33     CLRF 0x33, ACCESS
4B5A  5032     MOVF __tmp_0, W, ACCESS
4B5C  6EC2     MOVWF ADCON0, ACCESS
4B5E  98C0     BCF WDTCON, 4, ACCESS
4B60  0EFC     MOVLW 0xFC
4B62  AEDB     BTFSS PLUSW2, 7, ACCESS
4B64  D003     BRA 0x4B6C
4B66  9C9E     BCF PIR1, 6, ACCESS
4B68  8C9D     BSF PIE1, 6, ACCESS
4B6A  8CF2     BSF INTCON, 6, ACCESS
4B6C  80C2     BSF ADCON0, 0, ACCESS
4B6E  52E5     MOVF POSTDEC1, F, ACCESS
4B70  CFE5     MOVFF POSTDEC1, FSR2H
4B72  FFDA     NOP
4B74  CFE7     MOVFF INDF1, FSR2
4B76  FFD9     NOP
4B78  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcconv.c  ---------------------------------------
4EAA  98C0     BCF WDTCON, 4, ACCESS
4EAC  82C2     BSF ADCON0, 1, ACCESS
4EAE  0012     RETURN 0
---  E:/3.46/pic18-lt/cxx-framework/src/pmc_common/ADC/adcbusy.c  ---------------------------------------
4E9E  98C0     BCF WDTCON, 4, ACCESS
4EA0  50C2     MOVF ADCON0, W, ACCESS
4EA2  0B02     ANDLW 0x2
4EA4  E001     BZ 0x4EA8
4EA6  0E01     MOVLW 0x1
4EA8  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Task_outs/task_outs.c  ---------------------------
1:             #include "module_indication.h"
2:             #include "module_fan.h"
3:             #include "module_sound.h"
4:             #include "OSA.h"
5:             #include "task_outs.h"
6:             #include <p18cxxx.h>
7:             
8:             /*
9:             Задача управления логическими выходами
10:            Работают алгоритмы управления индикацией, вентилятором, звуком
11:            */
12:            
13:            
14:            void Task_Outs(void)
15:            {
16:            	for (;;) 
4D8E  D7F0     BRA Task_Outs
17:            	{ 
18:            		
19:            		M_Ind_Run();
4D70  EC9B     CALL 0x2D36, 0
4D72  F016     NOP
20:            		M_fan_run();
4D74  EC04     CALL 0x4208, 0
4D76  F021     NOP
21:            		M_Sound_run();
4D78  ECDD     CALL 0x47BA, 0
4D7A  F023     NOP
22:            		ClrWdt();
4D7C  0004     CLRWDT
23:                    OS_Delay(TIMEOUT_TASK_OUTS);
4D7E  0E01     MOVLW 0x1
4D80  6EE6     MOVWF POSTINC1, ACCESS
4D82  EC12     CALL 0x4024, 0
4D84  F020     NOP
4D86  52E5     MOVF POSTDEC1, F, ACCESS
4D88  ECE4     CALL 0x3FC8, 0
4D8A  F01F     NOP
4D8C  0000     NOP
24:            	}
25:            }
4D90  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Task_motors/task_motors.c  -----------------------
1:             #include "OSA.h"
2:             #include "task_motors.h"
3:             #include "module_motor.h"
4:             #include <p18cxxx.h>
5:             
6:             void Task_Motors(void)
7:             {
8:             	for (;;) 
4E24  D7F4     BRA Task_Motors
9:             	{ 
10:            		
11:            		M_Motor_Run();
4E0E  EC97     CALL 0x72E, 0
4E10  F003     NOP
12:            		ClrWdt();
4E12  0004     CLRWDT
13:                    OS_Delay(TIMEOUT_TASK_MOTORS);
4E14  0E01     MOVLW 0x1
4E16  6EE6     MOVWF POSTINC1, ACCESS
4E18  EC12     CALL 0x4024, 0
4E1A  F020     NOP
4E1C  52E5     MOVF POSTDEC1, F, ACCESS
4E1E  ECE4     CALL 0x3FC8, 0
4E20  F01F     NOP
4E22  0000     NOP
14:            	}
15:            }
4E26  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Task_management/task_management.c  ---------------
1:             #include "module_management.h"
2:             #include "task_management.h"
3:             #include "module_motor.h"
4:             #include "OSA.h"
5:             #include <p18cxxx.h>
6:             
7:             void Task_Management(void)
8:             {
9:             	for (;;) 
4E3E  D7F4     BRA Task_Management
10:            	{ 
11:                    M_Mngm_Run ();
4E28  EC10     CALL 0x1820, 0
4E2A  F00C     NOP
12:            		ClrWdt();
4E2C  0004     CLRWDT
13:                    OS_Delay(TIMEOUT_TASK_MANAGEMENT);
4E2E  0E64     MOVLW 0x64
4E30  6EE6     MOVWF POSTINC1, ACCESS
4E32  EC12     CALL 0x4024, 0
4E34  F020     NOP
4E36  52E5     MOVF POSTDEC1, F, ACCESS
4E38  ECE4     CALL 0x3FC8, 0
4E3A  F01F     NOP
4E3C  0000     NOP
14:            	}
15:            }
4E40  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Task_logic_inputs/task_logic_inputs.c  -----------
1:             #include "task_logic_inputs.h"
2:             #include "module_logic_inputs.h"
3:             #include "OSA.h"
4:             #include <p18cxxx.h>
5:             
6:             void Task_Logic_Inputs(void)
7:             {
8:             	for (;;) 
4E58  D7F4     BRA Task_Logic_Inputs
9:             	{ 
10:            		
11:            		M_LI_Run();
4E42  ECB6     CALL 0x3D6C, 0
4E44  F01E     NOP
12:            		ClrWdt();
4E46  0004     CLRWDT
13:                    OS_Delay(TIMEOUT_TASK_LOGIC_INPUTS);
4E48  0E01     MOVLW 0x1
4E4A  6EE6     MOVWF POSTINC1, ACCESS
4E4C  EC12     CALL 0x4024, 0
4E4E  F020     NOP
4E50  52E5     MOVF POSTDEC1, F, ACCESS
4E52  ECE4     CALL 0x3FC8, 0
4E54  F01F     NOP
4E56  0000     NOP
14:            	}
15:            }
4E5A  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Task_analog_inputs/task_analog_inputs.c  ---------
1:             #include "task_analog_inputs.h"
2:             #include "module_analog_inputs.h"
3:             #include "OSA.h"
4:             #include <p18cxxx.h>
5:             
6:             void Task_Analog_Inputs(void)
7:             {
8:             	for (;;) 
4E72  D7F4     BRA Task_Analog_Inputs
9:             	{ 
10:            			
11:            		M_AI_Run();
4E5C  EC2E     CALL 0x365C, 0
4E5E  F01B     NOP
12:            		ClrWdt();
4E60  0004     CLRWDT
13:                    OS_Delay(TIMEOUT_TASK_ANALOG_INPUTS);
4E62  0E01     MOVLW 0x1
4E64  6EE6     MOVWF POSTINC1, ACCESS
4E66  EC12     CALL 0x4024, 0
4E68  F020     NOP
4E6A  52E5     MOVF POSTDEC1, F, ACCESS
4E6C  ECE4     CALL 0x3FC8, 0
4E6E  F01F     NOP
4E70  0000     NOP
14:            	}
15:            }
4E74  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/OSA/port/pic18/osa_pic18_mplabc.c  ---------------
1:             /*
2:              ************************************************************************************************
3:              *
4:              *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8
5:              *
6:              *  OSA is distributed under BSD license (see license.txt)
7:              *
8:              *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro
9:              *
10:             *----------------------------------------------------------------------------------------------
11:             *
12:             *  File:           osa_pic18_mplabc.c
13:             *
14:             *  Compilers:      Mplab C18
15:             *
16:             *  Programmer:     Timofeev Victor
17:             *                  osa@pic24.ru, testerplus@mail.ru
18:             *
19:             *  Description:    MPLABC18 specific functions definition
20:             *                  This file directly included in osa.c
21:             *
22:             *  History:        10.09.2010 -    File updated
23:             *
24:             ************************************************************************************************
25:             */
26:            
27:            
28:            
29:            
30:            #define _OS_INIT_PROC_SPEC()      // Empty macro for MCC18
31:            
32:            
33:            
34:            
35:            
36:            
37:            /************************************************************************************************
38:             *                                                                                              *
39:             *                           K E R N E L   F U N C T I O N S                                    *
40:             *                                                                                              *
41:             ************************************************************************************************/
42:            
43:            
44:            void _OS_ClrReadySetClrCanContinue (void);  /* see description below    */
45:            
46:            
47:            
48:            void _OS_JumpToTask (void)
49:            {
50:                _OS_SET_FSR_CUR_TASK_W(OS_CODE_POINTER_SIZE + _OS_TASK_POINTER_OFFSET);
3FA6  0E03     MOVLW 0x3
3FA8  D839     RCALL __OS_SET_FSR_CUR_TASK_W
51:            
52:                if (_indf)
3FAA  50EF     MOVF INDF0, W, ACCESS
3FAC  E004     BZ 0x3FB6
53:                {
54:                    _indf1 = _fsr2l;
3FAE  50D9     MOVF FSR2, W, ACCESS
3FB0  6EE7     MOVWF INDF1, ACCESS
55:                    _fsr2l = _fsr1l + 1;
3FB2  28E1     INCF FSR1, W, ACCESS
3FB4  6ED9     MOVWF FSR2, ACCESS
56:                }
57:                _OS_TempH = _fsr1l;
3FB6  50E1     MOVF FSR1, W, ACCESS
3FB8  6E3C     MOVWF _OS_TempH, ACCESS
58:                _fsr1l += _postdec;
3FBA  50ED     MOVF POSTDEC0, W, ACCESS
3FBC  26E1     ADDWF FSR1, F, ACCESS
59:                _OS_SET_PC();
3FBE  50ED     MOVF POSTDEC0, W, ACCESS
3FC0  6EFA     MOVWF PCLATH, ACCESS
3FC2  50ED     MOVF POSTDEC0, W, ACCESS
3FC4  6EF9     MOVWF PCL, ACCESS
60:                /* Now FSR points to OS_CurTask->State    */
61:            }
3FC6  0012     RETURN 0
62:            
63:            
64:            
65:            
66:            
67:            /*
68:             ********************************************************************************
69:             *
70:             *  void _OS_ReturnSave (void)
71:             *
72:             *------------------------------------------------------------------------------
73:             *
74:             *  description:    Return to sheduler with saving current task return point
75:             *
76:             *  parameters:     none
77:             *
78:             *  on return:      none
79:             *
80:             ********************************************************************************
81:             */
82:            
83:            void _OS_ReturnSave (void)
84:            {
85:                _OS_SET_FSR_CUR_TASK_W(OS_CODE_POINTER_SIZE + _OS_TASK_POINTER_OFFSET);
3FC8  0E03     MOVLW 0x3
3FCA  D828     RCALL __OS_SET_FSR_CUR_TASK_W
86:                _postdec = _fsr1l - _OS_TempH;
3FCC  503C     MOVF _OS_TempH, W, ACCESS
3FCE  5CE1     SUBWF FSR1, W, ACCESS
3FD0  6EED     MOVWF POSTDEC0, ACCESS
87:            
88:                _OS_SAVE_PC();
3FD2  50FE     MOVF TOSH, W, ACCESS
3FD4  6EED     MOVWF POSTDEC0, ACCESS
3FD6  50FD     MOVF TOS, W, ACCESS
3FD8  6EED     MOVWF POSTDEC0, ACCESS
89:            
90:                _OS_bTaskReady = 1;
3FDA  86EF     BSF INDF0, 3, ACCESS
91:            
92:                _OS_POP();
3FDC  0006     POP
93:            }
3FDE  0012     RETURN 0
94:            
95:            
96:            
97:            /*
98:             ********************************************************************************
99:             *
100:            *  void _OS_ReturnNoSave (void)
101:            *
102:            *------------------------------------------------------------------------------
103:            *
104:            *  description:    Return to scheduler without saving context
105:            *
106:            *  parameters:     none
107:            *
108:            *  on return:      none
109:            *
110:            ********************************************************************************
111:            */
112:           
113:           void _OS_ReturnNoSave (void)
114:           {
115:               _OS_POP();
3FE0  0006     POP
116:           }
3FE2  0012     RETURN 0
117:           
118:           
119:           /*
120:            ********************************************************************************
121:            *
122:            *  void __OS_EnterWaitMode (void)
123:            *
124:            *------------------------------------------------------------------------------
125:            *
126:            *  description:    Clear bReady flag and return to the sheduler with seaving
127:            *                  task return point
128:            *
129:            *  parameters:     none
130:            *
131:            *  on return:      none
132:            *
133:            *
134:            ********************************************************************************
135:            */
136:           
137:           void _OS_EnterWaitMode (void)
138:           {
139:               _OS_Temp = 0;
3FE4  6A3B     CLRF _OS_Temp, ACCESS
140:               _asm    goto    _OS_ClrReadySetClrCanContinue   _endasm
3FE6  EFFA     GOTO 0x3FF4
3FE8  F01F     NOP
141:           }
3FEA  0012     RETURN 0
142:           
143:           
144:           /*
145:            ********************************************************************************
146:            *
147:            *  void __OS_EnterWaitModeTO (void)
148:            *
149:            *------------------------------------------------------------------------------
150:            *
151:            *  description:    Clear bReady flag, set bCanContinue flag and return to the
152:            *                  sheduler with seaving task return point
153:            *
154:            *  parameters:     none
155:            *
156:            *  on return:      none
157:            *
158:            *
159:            ********************************************************************************
160:            */
161:           
162:           void _OS_EnterWaitModeTO (void)
163:           {
164:               _OS_Temp = 0xFF;
3FEC  683B     SETF _OS_Temp, ACCESS
165:               _asm    goto    _OS_ClrReadySetClrCanContinue   _endasm
3FEE  EFFA     GOTO 0x3FF4
3FF0  F01F     NOP
166:           }
3FF2  0012     RETURN 0
167:           
168:           
169:           /*
170:            ********************************************************************************
171:            *
172:            *  void _OS_ClrReadySetClrCanContinue (void)
173:            *
174:            *------------------------------------------------------------------------------
175:            *
176:            *  description:    Addition function. Called only by GOTO from:
177:            *                      _OS_EnterWaitMode()
178:            *                      _OS_EnterWaitModeTO()
179:            *                  Stack has pointer of task who called theese services.
180:            *
181:            *  parameters:     none
182:            *
183:            *  on return:      none
184:            *
185:            ********************************************************************************
186:            */
187:           
188:           void _OS_ClrReadySetClrCanContinue (void)
189:           {
190:           
191:           
192:               _OS_Flags.bEventError = 0;
3FF4  903A     BCF _OS_Flags, 0, ACCESS
193:           
194:               _OS_SET_FSR_CUR_TASK_W(OS_CODE_POINTER_SIZE + _OS_TASK_POINTER_OFFSET);
3FF6  0E03     MOVLW 0x3
3FF8  D811     RCALL __OS_SET_FSR_CUR_TASK_W
195:               _postdec = _fsr1l - _OS_TempH;
3FFA  503C     MOVF _OS_TempH, W, ACCESS
3FFC  5CE1     SUBWF FSR1, W, ACCESS
3FFE  6EED     MOVWF POSTDEC0, ACCESS
196:               _OS_SAVE_PC();
4000  50FE     MOVF TOSH, W, ACCESS
4002  6EED     MOVWF POSTDEC0, ACCESS
4004  50FD     MOVF TOS, W, ACCESS
4006  6EED     MOVWF POSTDEC0, ACCESS
197:               _OS_bTaskReady = 0;
4008  96EF     BCF INDF0, 3, ACCESS
198:           
199:               #if defined(OS_ENABLE_TTIMERS)
200:                   if (!_OS_bTaskDelay) _OS_bTaskCanContinue = 0;
400A  A8EF     BTFSS INDF0, 4, ACCESS
400C  9AEF     BCF INDF0, 5, ACCESS
201:                   if (_OS_Temp & 0x01) _OS_bTaskCanContinue = 1;
400E  B03B     BTFSC _OS_Temp, 0, ACCESS
4010  8AEF     BSF INDF0, 5, ACCESS
202:               #endif
203:           
204:           }
4012  0012     RETURN 0
205:           
206:           
207:           
208:           
209:           
210:           
211:           
212:           
213:           
214:           
215:           
216:           /************************************************************************************************
217:            *                                                                                              *
218:            *  MAKE FSR POINTER TO OS_CUR_TASK                                                             *
219:            *                                                                                              *
220:            *  (for code reducing)                                                                         *
221:            *                                                                                              *
222:            ************************************************************************************************/
223:           
224:           void _OS_SET_FSR_CUR_TASK (void)
225:           {
226:               _asm
227:                   movlw   0
4014  0E00     MOVLW 0x0
228:                   goto __OS_SET_FSR_CUR_TASK_W
4016  EF0E     GOTO 0x401C
4018  F020     NOP
229:               _endasm
230:           }
401A  0012     RETURN 0
231:           
232:           
233:           void __OS_SET_FSR_CUR_TASK_W (void)
234:           {
235:               _asm
236:                   addwf   _OS_CurTask + 0, 0, 0
401C  243D     ADDWF _OS_CurTask, W, ACCESS
237:                   movwf   _fsr + 0, 0
401E  6EE9     MOVWF FSR0, ACCESS
238:                   #if OS_BANK_TASKS == 0
239:                       clrf    _fsr + 1, 0
4020  6AEA     CLRF FSR0H, ACCESS
240:                   #else
241:                       movlw   0
242:                       addwfc  _OS_CurTask + 1, 0, 0
243:                       movwf   _fsr + 1, 0
244:                   #endif
245:               _endasm
246:           }
4022  0012     RETURN 0
247:           
248:           
249:           
250:           
251:           
252:           /*
253:            ************************************************************************************************
254:            *                                                                                              *
255:            *                                   D E L A Y S   I N   T A S K                                *
256:            *                                                                                              *
257:            ************************************************************************************************
258:            */
259:           
260:           //------------------------------------------------------------------------------
261:           #ifdef OS_ENABLE_TTIMERS
262:           //------------------------------------------------------------------------------
263:           
264:           /*
265:            ********************************************************************************
266:            *
267:            *   void _OS_InitDelay (OS_TTIMER_TYPE Delay)
268:            *
269:            *------------------------------------------------------------------------------
270:            *
271:            *  description:    (Internal function called by system kernel)
272:            *
273:            *                  Init task timer delay.Set timer variable in task descriptor,
274:            *                  sets bit bDelay and clears bit bCanContinue.
275:            *
276:            *                  _OS_CurTask must point to descriptor.
277:            *
278:            *
279:            *  parameters:     Delay   - time of delay in system ticks
280:            *
281:            *  on return:      none
282:            *
283:            *  note:           This function overloads "osa.c"
284:            *
285:            ********************************************************************************
286:            */
287:           
288:           //------------------------------------------------------------------------------
289:           #define _OS_InitDelay_DEFINED
290:           //------------------------------------------------------------------------------
291:           
292:           void _OS_InitDelay (OS_TTIMER_TYPE Delay)
4024  CFD9     MOVFF FSR2, POSTINC1
4026  FFE6     NOP
4028  CFE1     MOVFF FSR1, FSR2
402A  FFD9     NOP
402C  52E6     MOVF POSTINC1, F, ACCESS
293:           {
294:           
295:               char temp;
296:               temp = 0;               // This variable used to prevent FSR changing
402E  6ADF     CLRF INDF2, ACCESS
297:               if (Delay) temp = 1;    // when checking Delay after FSR set to task->Timer
4030  0EFE     MOVLW 0xFE
4032  50DB     MOVF PLUSW2, W, ACCESS
4034  E002     BZ 0x403A
4036  0E01     MOVLW 0x1
4038  6EDF     MOVWF INDF2, ACCESS
298:                                       // See "if (temp & 1)" below
299:           
300:               _OS_SET_FSR_CUR_TASK();
403A  DFEC     RCALL _OS_SET_FSR_CUR_TASK
301:               _OS_bTaskCanContinue = 0;
403C  9AEF     BCF INDF0, 5, ACCESS
302:               _OS_bTaskDelay = 0;     // Clear bDelay to prevent timer changing in interrupt
403E  98EF     BCF INDF0, 4, ACCESS
303:           
304:               if (temp & 1)
4040  A0DF     BTFSS INDF2, 0, ACCESS
4042  D012     BRA 0x4068
305:               {
306:           
307:                   Delay ^= -1;
4044  0EFE     MOVLW 0xFE
4046  1EDB     COMF PLUSW2, F, ACCESS
308:                   Delay ++;
4048  0EFE     MOVLW 0xFE
404A  2ADB     INCF PLUSW2, F, ACCESS
309:           
310:                   _OS_CurTask->Timer = Delay;
404C  C03D     MOVFF _OS_CurTask, FSR0
404E  FFE9     NOP
4050  C03E     MOVFF 0x3E, FSR0H
4052  FFEA     NOP
4054  0E04     MOVLW 0x4
4056  26E9     ADDWF FSR0, F, ACCESS
4058  0E00     MOVLW 0x0
405A  22EA     ADDWFC FSR0H, F, ACCESS
405C  0EFE     MOVLW 0xFE
405E  CFDB     MOVFF PLUSW2, INDF0
4060  FFEF     NOP
311:                   _OS_SET_FSR_CUR_TASK();
4062  DFD8     RCALL _OS_SET_FSR_CUR_TASK
312:                   _OS_bTaskDelay = 1;
4064  88EF     BSF INDF0, 4, ACCESS
313:                   _OS_bTaskReady = 1;
4066  86EF     BSF INDF0, 3, ACCESS
314:           
315:               }
316:           }
4068  52E5     MOVF POSTDEC1, F, ACCESS
406A  52E5     MOVF POSTDEC1, F, ACCESS
406C  CFE7     MOVFF INDF1, FSR2
406E  FFD9     NOP
4070  0012     RETURN 0
317:           
318:           //------------------------------------------------------------------------------
319:           #endif  // #ifdef OS_ENABLE_TTIMERS
320:           //------------------------------------------------------------------------------
321:           
322:           
323:           
324:           
325:           
326:           
327:           
328:           
329:           
330:           
331:           
332:           
333:           
334:           
335:           
336:           
337:           
338:           
339:           
340:           
341:           
342:           
343:           
344:           
345:           
346:           
347:           
348:           
349:           
350:           
351:           
352:           
353:           
354:           
355:           
356:           
357:           
358:           
359:           
360:           
361:           
362:           
363:           
364:           
365:           
366:           
367:           
368:           /************************************************************************************************
369:            *                                                                                              *
370:            *                            S Y S T E M   F U N C T I O N S                                   *
371:            *                                                                                              *
372:            ************************************************************************************************/
373:           
374:           
375:           
376:           
377:           
378:           
379:           /*
380:            ********************************************************************************
381:            *
382:            *  char OS_DI (void)
383:            *
384:            *------------------------------------------------------------------------------
385:            *
386:            *  description:    Disable interrupt with GIE saving
387:            *
388:            *  parameters:     none
389:            *
390:            *  on return:      char - bit 7 = previous GIEH value,
391:            *                         bit 6 = previous GIEL value
392:            *                         bits 0..5 = 0
393:            *
394:            ********************************************************************************
395:            */
396:           
397:           //-------------------------------------------------------------------------------
398:           #define OS_DI_DEFINED
399:           //-------------------------------------------------------------------------------
400:           
401:           char OS_DI (void)
402:           {
403:               _asm
404:                   movf    _intcon, 0, 0
4072  50F2     MOVF INTCON, W, ACCESS
405:                   andlw   0xC0
4074  0BC0     ANDLW 0xC0
406:                   bcf     _intcon, 7, 0
4076  9EF2     BCF INTCON, 7, ACCESS
407:                   btfsc   _rcon, 7, 0
4078  BED0     BTFSC RCON, 7, ACCESS
408:                   bcf     _intcon, 6, 0
407A  9CF2     BCF INTCON, 6, ACCESS
409:               _endasm
410:           }
407C  0012     RETURN 0
411:           
412:           //------------------------------------------------------------------------------
413:           #if defined(OS_ENABLE_INT)
414:           //------------------------------------------------------------------------------
415:           
416:               void _OS_DI_INT (void)
417:               {
418:                   _asm
419:                       movf    _intcon, 0, 0
420:                       andlw   0xC0
421:                       bcf     _intcon, 7, 0
422:                       btfsc   _rcon, 7, 0
423:                       bcf     _intcon, 6, 0
424:                       movwf   _OS_Temp_I, 0
425:                   _endasm
426:               }
427:           
428:           //------------------------------------------------------------------------------
429:           #endif
430:           //------------------------------------------------------------------------------
431:           
432:           /*
433:            ********************************************************************************
434:            *
435:            *  char OS_RI (void)
436:            *
437:            *------------------------------------------------------------------------------
438:            *
439:            *  description:    Restore saved by OS_DI() GIEx states
440:            *
441:            *  parameters:     char - bit 7 = previos GIE value, bits 0..6 = 0
442:            *
443:            *  on return:      none
444:            *
445:            ********************************************************************************
446:            */
447:           
448:           //-------------------------------------------------------------------------------
449:           #define OS_RI_DEFINED
450:           //-------------------------------------------------------------------------------
451:           
452:           void _OS_RI ()
453:           {
454:               _asm
455:                   btfsc   _wreg, 7, 0
407E  BEE8     BTFSC WREG, 7, ACCESS
456:                   bsf     _intcon, 7, 0
4080  8EF2     BSF INTCON, 7, ACCESS
457:                   btfsc   _rcon, 7, 0
4082  BED0     BTFSC RCON, 7, ACCESS
458:                   btfss   _wreg, 6, 0
4084  ACE8     BTFSS WREG, 6, ACCESS
459:                   bra     _RI_EXIT
4086  D001     BRA 0x408A
460:                   bsf     _intcon, 6, 0
4088  8CF2     BSF INTCON, 6, ACCESS
461:               _RI_EXIT:
462:               _endasm
463:           
464:           }
408A  0012     RETURN 0
465:           
466:           //------------------------------------------------------------------------------
467:           #if defined(OS_ENABLE_INT)
468:           //------------------------------------------------------------------------------
469:           
470:               void _OS_RI_INT ()
471:               {
472:                   _asm
473:                       btfsc   _OS_Temp_I, 7, 0
474:                       bsf     _intcon, 7, 0
475:                       btfsc   _rcon, 7, 0
476:                       btfss   _OS_Temp_I, 6, 0
477:                       bra     _RI_INT_EXIT
478:                       bsf     _intcon, 6, 0
479:                   _RI_INT_EXIT:
480:                   _endasm
481:           
482:               }
483:           
484:           //------------------------------------------------------------------------------
485:           #endif
486:           //------------------------------------------------------------------------------
487:           
488:           
489:           
490:           
491:           
492:           
493:           
494:           
495:           
496:           
497:           
498:           /*
499:            ********************************************************************************
500:            *
501:            *  void _OS_CheckEvent (char bEvent)
502:            *
503:            *------------------------------------------------------------------------------
504:            *
505:            *  description:    (Internal function called by system kernel througth
506:            *                  waiting services)
507:            *
508:            *                  Check condition of bEvent. Accordint to bEvent value and
509:            *                  current state of bReady, bDelay and bCanContinue flags,
510:            *                  task becames ready to execute or still remains in waiting
511:            *                  mode.
512:            *
513:            *  parameters:     bEvent (passing througth _OS_TempH)
514:            *                  - zero, or non-zero condition
515:            *
516:            *
517:            *  on return:      none
518:            *
519:            *  note:           This function overloads "osa.c"
520:            *
521:            ********************************************************************************
522:            */
523:           
524:           //------------------------------------------------------------------------------
525:           #define _OS_CheckEvent_DEFINED
526:           //------------------------------------------------------------------------------
527:           
528:           #define bEvent  _OS_Temp
529:           
530:           void _OS_CheckEvent (void)
531:           {
532:               //------------------------------------------------------------------------------
533:               #if OS_PRIORITY_LEVEL == OS_PRIORITY_DISABLED
534:               //------------------------------------------------------------------------------
535:           
536:                   _OS_Flags.bTimeout = 0;
537:                   _OS_SET_FSR_CUR_TASK();
538:           
539:                   if (bEvent)
540:                   {
541:                       #ifdef OS_ENABLE_TTIMERS
542:                           _OS_bTaskDelay = 0;
543:                       #endif
544:           
545:                       return;
546:                   }
547:           
548:                   #ifdef OS_ENABLE_TTIMERS
549:           
550:                       if (_OS_bTaskTimeout && _OS_bTaskCanContinue)
551:                       {
552:                           _OS_Flags.bTimeout = 1;
553:           
554:                           return;
555:                       }
556:           
557:                   #endif
558:           
559:                   _OS_POP();
560:           
561:               //------------------------------------------------------------------------------
562:               #else
563:               //------------------------------------------------------------------------------
564:           
565:                   _OS_Flags.bTimeout = 0;
408C  9A3A     BCF _OS_Flags, 5, ACCESS
566:                   _OS_SET_FSR_CUR_TASK();
408E  DFC2     RCALL _OS_SET_FSR_CUR_TASK
567:           
568:                   if (bEvent)
4090  503B     MOVF _OS_Temp, W, ACCESS
4092  E006     BZ 0x40A0
569:                   {
570:                       if (_OS_bTaskReady)
4094  A6EF     BTFSS INDF0, 3, ACCESS
4096  D002     BRA 0x409C
571:                       {
572:                           #ifdef OS_ENABLE_TTIMERS
573:                           _OS_bTaskDelay = 0;
4098  98EF     BCF INDF0, 4, ACCESS
574:                           #endif
575:           
576:                           #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED
577:                           _OS_Flags.bEventOK = 1;
578:                           #endif
579:           
580:                           return;
409A  D00D     BRA 0x40B6
581:                       }
582:           
583:                       _OS_bTaskReady = 1;
409C  86EF     BSF INDF0, 3, ACCESS
584:           
585:                   } else {
409E  D001     BRA 0x40A2
586:                       _OS_bTaskReady = 0;
40A0  96EF     BCF INDF0, 3, ACCESS
587:                   }
588:           
589:                   #ifdef OS_ENABLE_TTIMERS
590:           
591:                       if (_OS_bTaskTimeout && _OS_bTaskCanContinue)
40A2  50EF     MOVF INDF0, W, ACCESS
40A4  0B10     ANDLW 0x10
40A6  E106     BNZ 0x40B4
40A8  50EF     MOVF INDF0, W, ACCESS
40AA  0B20     ANDLW 0x20
40AC  E003     BZ 0x40B4
592:                       {
593:                           _OS_bTaskReady = 1;
40AE  86EF     BSF INDF0, 3, ACCESS
594:                           _OS_Flags.bTimeout = 1;
40B0  8A3A     BSF _OS_Flags, 5, ACCESS
595:           
596:                           #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED
597:                           _OS_Flags.bEventOK = 1;
598:                           #endif
599:           
600:                           return;
40B2  D001     BRA 0x40B6
601:                       }
602:           
603:                   #endif
604:           
605:                   _OS_POP();
40B4  0006     POP
606:           
607:               //------------------------------------------------------------------------------
608:               #endif
609:               //------------------------------------------------------------------------------
610:           }
40B6  0012     RETURN 0
611:           
612:           
613:           
614:           
615:           
616:           //------------------------------------------------------------------------------
617:           #if (OS_STIMERS > 0 ) && defined(OS_STIMERS_ENABLE_ALLOCATION)
618:           //------------------------------------------------------------------------------
619:           
620:           /*
621:            ********************************************************************************
622:            *
623:            *  _OS_Stimer_GetFree
624:            *
625:            *------------------------------------------------------------------------------
626:            *
627:            *  description:    (Internal function called by system kernel througth service OS
628:            *                  Searches free static timer and returns it's ID
629:            *
630:            *
631:            *  parameters:     OST_UINT bCreate - =0 - do not created timer, just check for
632:            *                                               aviability
633:            *                                          =1 - create timer and mark it asm used
634:            *
635:            *  on return:      none
636:            *
637:            *  Overloaded in:  osa_pic18_htpicc.c
638:            *
639:            ********************************************************************************
640:            */
641:           
642:           //-----------------------------------------------------------------
643:           #define _OS_Stimer_GetFree_DEFINED
644:           //-----------------------------------------------------------------
645:           
646:           OST_UINT8   _OS_Stimer_GetFree (OST_UINT bCreate)
647:           {
648:               _OS_Flags.bError = 0;
649:               _fsr = (OS_FSR_TYPE)_OS_StimersFree;
650:               _OS_Temp = (OS_STIMERS >> 3) + 1;
651:               do
652:               {
653:                   if (_indf)
654:                   {
655:                       if (!(bCreate & 1)) return 0;
656:           
657:                       _asm
658:                           movlw   _OS_StimersFree
659:                           subwf   _fsr, 0, 0
660:                           rlcf    _wreg, 1, 0
661:                           rlcf    _wreg, 1, 0
662:                           rlcf    _wreg, 0, 0
663:                           andlw   0xF8
664:           
665:                           movff   _indf, _OS_TempH  // Search for first "1" in _indf
666:                           movwf   _OS_Temp, 0
667:                           movlw   1
668:                        OS_ST_GF_REPEAT:
669:                           rrcf    _OS_TempH, 1, 0
670:                           bc      OS_ST_GF_OK
671:                           rlcf    _wreg, 1, 0
672:                           incf    _OS_Temp, 1, 0
673:                           bra     OS_ST_GF_REPEAT
674:                        OS_ST_GF_OK:
675:           
676:                           xorwf  _indf, 1, 0         // Clear bit of selected timer
677:           
678:                       _endasm
679:                       return _OS_Temp;
680:           
681:                   }
682:                   _fsr++;
683:               } while (--_OS_Temp);
684:           
685:               _OS_Flags.bError = 1;
686:               return 0xFF;
687:           }
688:           
689:           
690:           void    _OS_Stimer_Free (OST_UINT8 ID)
691:           {
692:               _OS_Temp = ID;
693:               _asm
694:               __OS_Stimer_Free:
695:                   lfsr    0, _OS_StimersFree
696:                   movf    _OS_Temp, 0, 0
697:                   rrcf    _wreg, 0, 0          //  wreg = ID / 8
698:                   rrcf    _wreg, 0, 0
699:                   rrcf    _wreg, 0, 0
700:                   andlw   0x1F
701:                   addwf   _fsr, 1, 0
702:           
703:                   movlw   0x01                  // W = 1 << (ID & 7)
704:                   btfsc   _OS_Temp, 2, 0
705:                   swapf   _wreg, 0, 0
706:                   btfsc   _OS_Temp, 1, 0
707:                   rlcf    _wreg, 0, 0
708:                   btfsc   _OS_Temp, 1, 0
709:                   rlcf    _wreg, 0, 0
710:                   btfsc   _OS_Temp, 0, 0
711:                   rlcf    _wreg, 0, 0
712:                   iorwf   _indf, 1, 0          // Free timer
713:               _endasm
714:               return   ;
715:           }
716:           //------------------------------------------------------------------------------
717:           #endif      //  OS_STIMERS_ENABLE_ALLOCATION
718:           //-----------------------------------------------------------------
719:           
720:           
721:           
722:           //******************************************************************************
723:           //  END OF FILE osa_pic18_mplabc.c
724:           //******************************************************************************
725:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/OSA/kernel/system/osa_tasks.c  -------------------
1:             /*
2:              ************************************************************************************************
3:              *
4:              *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8
5:              *
6:              *  OSA is distributed under BSD license (see license.txt)
7:              *
8:              *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro
9:              *
10:             *----------------------------------------------------------------------------------------------
11:             *
12:             *  File:           osa_tasks.c
13:             *
14:             *  Programmer:     Timofeev Victor
15:             *                  osa@pic24.ru, testerplus@mail.ru
16:             *
17:             *  Description:    Functions and variables for Tasks.
18:             *                  This file directly included in osa.c
19:             *
20:             *  History:        12.09.2010 -    File updated
21:             *
22:             ************************************************************************************************
23:             */
24:            
25:            
26:            
27:            
28:            //******************************************************************************
29:            //  Task descriptors
30:            //******************************************************************************
31:            
32:            #if (OS_BANK_TASKS == 0) && defined(__OSA_PIC18_MPLABC__)
33:            #pragma udata access os_bsems
34:            #endif
35:            
36:            OS_TASKS_BANK  OST_TCB  _OS_Tasks[OS_TASKS] OS_ALLOCATION_TASKS;
37:            
38:            #if (OS_BANK_TASKS == 0) && defined(__OSA_PIC18_MPLABC__)
39:            #pragma udata
40:            #endif
41:            
42:            
43:            
44:            /*
45:             ********************************************************************************
46:             *
47:             *   void             _OS_Task_Create(OST_WORD    priority,
48:             *                                    OST_CODE_POINTER TaskAddr)
49:             *
50:             *------------------------------------------------------------------------------
51:             *
52:             *   description:   (Internal function called by system kernel from service
53:             *                  OS_Task_Create)
54:             *                  Create task in free descriptor.
55:             *  parameters:     priority - value from 0 (highest) to 7 (lowest)
56:             *                  TaskAddr - pointer to C-function that contains task
57:             *
58:             *  on return:      check OS_IsError
59:             *                  OST_TASK_POINTER - pointer to task descriptor
60:             *                  _OS_Temp - task position in _OS_Tasks array 
61:             *
62:             *  Overloaded in:  "osa_pic12_htpicc.c"
63:             *                  "osa_pic16_mikroc.c"
64:             *                  "osa_pic24_mplabc.c"
65:             *                  "port\osa_ccc16.c"
66:             *
67:             ********************************************************************************
68:             */
69:            
70:            
71:            //------------------------------------------------------------------------------
72:            #if !defined(_OS_Task_Create_DEFINED)
73:            //------------------------------------------------------------------------------
74:            
75:                void _OS_Task_Create(OST_WORD priority, OST_CODE_POINTER TaskAddr)
40FA  CFD9     MOVFF FSR2, POSTINC1
40FC  FFE6     NOP
40FE  CFE1     MOVFF FSR1, FSR2
4100  FFD9     NOP
4102  0E02     MOVLW 0x2
4104  26E1     ADDWF FSR1, F, ACCESS
76:                {
77:                    OST_TASK_POINTER Task;
78:            
79:                    _OS_Flags.bError = 0;
4106  923A     BCF _OS_Flags, 1, ACCESS
80:            
81:            
82:                    /*--------------------------------------*
83:                     *                                      *
84:                     *  Start search from first task in     *
85:                     *  OS_TASKS descriptors.               *
86:                     *                                      *
87:                     *--------------------------------------*/
88:                    Task = (OST_TASK_POINTER)_OS_Tasks;
4108  0E05     MOVLW 0x5
410A  6EDE     MOVWF POSTINC2, ACCESS
410C  0E00     MOVLW 0x0
410E  6EDD     MOVWF POSTDEC2, ACCESS
89:                    _OS_Temp = 0;   
4110  6A3B     CLRF _OS_Temp, ACCESS
90:            
91:                    do {
92:            
93:                        if (!Task->State.bEnable)               // Is descriptor free?
4112  CFDE     MOVFF POSTINC2, FSR0
4114  FFE9     NOP
4116  CFDD     MOVFF POSTDEC2, FSR0H
4118  FFEA     NOP
411A  50EF     MOVF INDF0, W, ACCESS
411C  0B40     ANDLW 0x40
411E  E12A     BNZ 0x4174
94:                        {                                       // Yes
95:                            ((OST_TASK_STATE*)&priority)->bEnable = 1;
4120  0EFE     MOVLW 0xFE
4122  8CDB     BSF PLUSW2, 6, ACCESS
96:                            ((OST_TASK_STATE*)&priority)->bReady = 1;
4124  0EFE     MOVLW 0xFE
4126  86DB     BSF PLUSW2, 3, ACCESS
97:            
98:                            Task->pTaskPointer = TaskAddr;
4128  CFDE     MOVFF POSTINC2, FSR0
412A  FFE9     NOP
412C  CFDD     MOVFF POSTDEC2, FSR0H
412E  FFEA     NOP
4130  52EE     MOVF POSTINC0, F, ACCESS
4132  0EFC     MOVLW 0xFC
4134  CFDB     MOVFF PLUSW2, POSTINC0
4136  FFEE     NOP
4138  0EFD     MOVLW 0xFD
413A  CFDB     MOVFF PLUSW2, POSTDEC0
413C  FFED     NOP
99:            
100:                           #ifdef OS_ENABLE_TTIMERS
101:                               Task->Timer = 0;
413E  CFDE     MOVFF POSTINC2, FSR0
4140  FFE9     NOP
4142  CFDD     MOVFF POSTDEC2, FSR0H
4144  FFEA     NOP
4146  0E04     MOVLW 0x4
4148  26E9     ADDWF FSR0, F, ACCESS
414A  0E00     MOVLW 0x0
414C  22EA     ADDWFC FSR0H, F, ACCESS
414E  6AEF     CLRF INDF0, ACCESS
102:                           #endif
103:           
104:                           #ifdef _OS_TASK_CREATE_PROC_SPEC
105:                           _OS_TASK_CREATE_PROC_SPEC();
4150  CFDE     MOVFF POSTINC2, FSR0
4152  FFE9     NOP
4154  CFDD     MOVFF POSTDEC2, FSR0H
4156  FFEA     NOP
4158  0E03     MOVLW 0x3
415A  26E9     ADDWF FSR0, F, ACCESS
415C  0E00     MOVLW 0x0
415E  22EA     ADDWFC FSR0H, F, ACCESS
4160  6AEF     CLRF INDF0, ACCESS
106:                           #endif
107:           
108:                           *((OS_TASKS_BANK char*)&Task->State) = priority;
4162  CFDE     MOVFF POSTINC2, FSR0
4164  FFE9     NOP
4166  CFDD     MOVFF POSTDEC2, FSR0H
4168  FFEA     NOP
416A  0EFE     MOVLW 0xFE
416C  CFDB     MOVFF PLUSW2, INDF0
416E  FFEF     NOP
109:           
110:                           #if defined(_OS_CUR_FLAGS_IN_OS_STATE)
111:                           if (Task == _OS_CurTask) *((OS_RAM_NEAR char*)&_OS_State) = priority;
112:                           #endif
113:           
114:                           #if defined(__OSA_AVR_WINAVR__) || defined(__OSA_AVR_IAR__)
115:                           Task->nY_Temp = 0x8000;
116:                           #endif
117:           
118:                           #if defined(__OSA_AVR_WINAVR__)
119:                           Task->c_NumOfTemp = 0;  
120:                           #endif
121:           
122:                           #if defined(__OSA_STM8__)
123:                           Task->nSP_Temp = 0;
124:                           #endif
125:           
126:                           _OS_Flags.bError = 0;
4170  923A     BCF _OS_Flags, 1, ACCESS
127:           
128:                           return ;
4172  D00E     BRA 0x4190
129:           
130:                       }
131:           
132:                       Task ++;
4174  CFD9     MOVFF FSR2, FSR0
4176  FFE9     NOP
4178  CFDA     MOVFF FSR2H, FSR0H
417A  FFEA     NOP
417C  0E05     MOVLW 0x5
417E  26EE     ADDWF POSTINC0, F, ACCESS
4180  0E00     MOVLW 0x0
4182  22EF     ADDWFC INDF0, F, ACCESS
133:           
134:                   } while (++_OS_Temp < OS_TASKS);    
4184  2A3B     INCF _OS_Temp, F, ACCESS
4186  0E05     MOVLW 0x5
4188  5C3B     SUBWF _OS_Temp, W, ACCESS
418A  E3C3     BNC 0x4112
135:           
136:                   // There is no free descriptor. Task was not created.
137:                   _OS_Flags.bError = 1;
418C  823A     BSF _OS_Flags, 1, ACCESS
138:           
139:                   return ;
418E  D000     BRA 0x4190
140:               }
4190  0E02     MOVLW 0x2
4192  5CE1     SUBWF FSR1, W, ACCESS
4194  E202     BC 0x419A
4196  6AE1     CLRF FSR1, ACCESS
4198  52E5     MOVF POSTDEC1, F, ACCESS
419A  6EE1     MOVWF FSR1, ACCESS
419C  52E5     MOVF POSTDEC1, F, ACCESS
419E  CFE7     MOVFF INDF1, FSR2
41A0  FFD9     NOP
41A2  0012     RETURN 0
141:           
142:           //------------------------------------------------------------------------------
143:           #endif  // !defined(_OS_Task_Create_DEFINED)
144:           //------------------------------------------------------------------------------
145:           
146:           
147:           
148:           //******************************************************************************
149:           //  END OF FILE osa_tasks.c
150:           //******************************************************************************
151:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/OSA/kernel/system/osa_system.c  ------------------
1:             /*
2:              ************************************************************************************************
3:              *
4:              *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8
5:              *
6:              *  OSA is distributed under BSD license (see license.txt)
7:              *
8:              *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro
9:              *
10:             *----------------------------------------------------------------------------------------------
11:             *
12:             *  File:           osa_system.c
13:             *
14:             *  Programmer:     Timofeev Victor
15:             *                  osa@pic24.ru, testerplus@mail.ru
16:             *
17:             *  Description:    System functions
18:             *                  This file directly included in osa.c
19:             *
20:             *  History:        12.09.2010 -    File updated
21:             *
22:             ************************************************************************************************
23:             */
24:            
25:            
26:            
27:            
28:            
29:            
30:            /************************************************************************************************
31:             *                                                                                              *
32:             *                                                                                              *
33:             *                         F U N C T I O N   D E F I N I T I O N S                              *
34:             *                                                                                              *
35:             *                                                                                              *
36:             ************************************************************************************************/
37:            
38:            
39:            
40:            
41:            /*
42:             ********************************************************************************
43:             *
44:             *   void OS_Init (void)
45:             *
46:             *------------------------------------------------------------------------------
47:             *
48:             *  description:    (Internal function called by system kernel)
49:             *
50:             *                  Initialize all system variables:
51:             *                  - Clear all binary semaphores
52:             *                  - Free all task descriptors
53:             *                  - Clear all timeouts for old style static timers
54:             *                  - Set _OS_LastTask and _OS_CurTask variables at last task
55:             *                    descriptor
56:             *
57:             *  parameters:     none
58:             *
59:             *  on return:      _OSCurTask points to last task descriptor.
60:             *
61:             *  Overloaded in:  -
62:             *
63:             ********************************************************************************
64:             */
65:            
66:            
67:            void OS_Init (void)
68:            {
69:                #ifdef __OSA_PIC24_MPLABC__
70:                _OS_Flags = (OST_SYSTEM_FLAGS){0};
71:                #else
72:                *(OS_RAM_NEAR OST_WORD*)&_OS_Flags = 0;
40B8  6A3A     CLRF _OS_Flags, ACCESS
73:                #endif
74:            
75:                _OS_INIT_PROC_SPEC();     /* Specific controller type's init operations   */
76:            
77:            
78:            
79:                #if OS_PRIORITY_LEVEL == OS_PRIORITY_NORMAL
80:            
81:                    _OS_LastTask = (OST_TASK_POINTER) _OS_Tasks + (OS_TASKS - 1);
40BA  0E19     MOVLW 0x19
40BC  6E02     MOVWF _OS_LastTask, ACCESS
40BE  0E00     MOVLW 0x0
40C0  6E03     MOVWF 0x3, ACCESS
82:            
83:                #endif
84:            
85:            
86:            
87:                /*--------------------------------------*
88:                 *                                      *
89:                 *  Zero all old style static timers    *
90:                 *                                      *
91:                 *--------------------------------------*/
92:            
93:                #if OS_TIMERS > 11*8 || ((OS_TIMERS > 0) && defined(__OSA_PIC24_MPLABC__))
94:            
95:                    _OS_Temp = sizeof(OS_Timeouts) / sizeof(OST_WORD);
96:                    do
97:                    {
98:                        OS_Timeouts[_OS_Temp-1] = 0;
99:                    } while (--_OS_Temp);
100:           
101:               #else
102:                   #if OS_TIMERS > 0
103:                       OS_Timeouts[0] = 0;
104:                   #endif
105:           
106:                   #if OS_TIMERS > 1*8
107:                       OS_Timeouts[1] = 0;
108:                   #endif
109:           
110:                   #if OS_TIMERS > 2*8
111:                       OS_Timeouts[2] = 0;
112:                   #endif
113:           
114:                   #if OS_TIMERS > 3*8
115:                       OS_Timeouts[3] = 0;
116:                   #endif
117:           
118:                   #if OS_TIMERS > 4*8
119:                       OS_Timeouts[4] = 0;
120:                   #endif
121:           
122:                   #if OS_TIMERS > 5*8
123:                       OS_Timeouts[5] = 0;
124:                   #endif
125:           
126:                   #if OS_TIMERS > 6*8
127:                       OS_Timeouts[6] = 0;
128:                   #endif
129:           
130:                   #if OS_TIMERS > 7*8
131:                       OS_Timeouts[7] = 0;
132:                   #endif
133:           
134:                   #if OS_TIMERS > 8*8
135:                       OS_Timeouts[8] = 0;
136:                   #endif
137:           
138:                   #if OS_TIMERS > 9*8
139:                       OS_Timeouts[9] = 0;
140:                   #endif
141:           
142:                   #if OS_TIMERS > 10*8
143:                       OS_Timeouts[10] = 0;
144:                   #endif
145:           
146:               #endif
147:           
148:           
149:               /*--------------------------------------*
150:                *                                      *
151:                *  Clear list of dynamic timers        *
152:                *                                      *
153:                *--------------------------------------*/
154:           
155:               #if defined(OS_ENABLE_DTIMERS)
156:                   *((OS_BANK OST_WORD*)&_OS_DTimers.Flags) = 0;
157:                   _OS_DTimers.Flags.bNextEnable = 0;
158:                   _OS_DTimers.Flags.bActive = 1;
159:               #endif
160:           
161:               /*--------------------------------------*
162:                *                                      *
163:                *  Clear list of fast timers           *
164:                *                                      *
165:                *--------------------------------------*/
166:           
167:           
168:               #if defined(OS_ENABLE_QTIMERS)
169:                   *((OS_BANK OST_WORD*)&_OS_Qtimers.Flags) = 0;
170:                   // Default:
171:                   //  bNextEnable     = 0
172:                   //  bListFunction   = 0 (FUNCTION_ADD)
173:                   //  bListGetTime    = 0
174:                   _OS_Qtimers.Flags.bActive = 1;
175:               #endif
176:           
177:               /*--------------------------------------*
178:                *                                      *
179:                *  Make all static timers free         *
180:                *                                      *
181:                *--------------------------------------*/
182:           
183:               #if defined (OS_ENABLE_STIMERS)
184:               #if defined (OS_STIMERS_ENABLE_ALLOCATION)
185:           
186:               #if OS_STIMERS > 11*8 || ((OS_STIMERS > 0) && defined(__OSA_PIC24_MPLABC__))
187:           
188:                   _OS_Temp = sizeof(_OS_StimersFree) / sizeof(OST_WORD);
189:                   do
190:                   {
191:                       _OS_StimersFree[_OS_Temp-1] = (OST_WORD)-1;
192:                   } while (--_OS_Temp);
193:           
194:               #else
195:                   #if OS_STIMERS > 1*8
196:                       _OS_StimersFree[0] = (OST_WORD)-1;
197:                   #endif
198:           
199:                   #if OS_STIMERS > 2*8
200:                       _OS_StimersFree[1] = (OST_WORD)-1;
201:                   #endif
202:           
203:                   #if OS_STIMERS > 3*8
204:                       _OS_StimersFree[2] = (OST_WORD)-1;
205:                   #endif
206:           
207:                   #if OS_STIMERS > 4*8
208:                       _OS_StimersFree[3] = (OST_WORD)-1;
209:                   #endif
210:           
211:                   #if OS_STIMERS > 5*8
212:                       _OS_StimersFree[4] = (OST_WORD)-1;
213:                   #endif
214:           
215:                   #if OS_STIMERS > 6*8
216:                       _OS_StimersFree[5] = (OST_WORD)-1;
217:                   #endif
218:           
219:                   #if OS_STIMERS > 7*8
220:                       _OS_StimersFree[6] = (OST_WORD)-1;
221:                   #endif
222:           
223:                   #if OS_STIMERS > 8*8
224:                       _OS_StimersFree[7] = (OST_WORD)-1;
225:                   #endif
226:           
227:                   #if OS_STIMERS > 9*8
228:                       _OS_StimersFree[8] = (OST_WORD)-1;
229:                   #endif
230:           
231:                   #if OS_STIMERS > 10*8
232:                       _OS_StimersFree[ 9] = (OST_WORD)-1;
233:                   #endif
234:           
235:               #endif
236:           
237:                   #if (OS_STIMERS & _OST_INT_MASK) != 0
238:                   _OS_StimersFree[OS_STIMERS >> _OST_INT_SHIFT] = (1 << (OS_STIMERS & _OST_INT_MASK)) - 1;
239:                   #endif
240:           
241:               #endif
242:               #endif
243:           
244:               /*--------------------------------------*
245:                *                                      *
246:                *  Zero all binary semaphores          *
247:                *                                      *
248:                *--------------------------------------*/
249:           
250:               #if OS_BSEMS > 11*8 || ((OS_BSEMS > 0) && defined(__OSA_PIC24_MPLABC__))
251:           
252:                   _OS_Temp = sizeof(_OS_Bsems) / sizeof(OST_WORD);
253:                   do
254:                   {
255:                       _OS_Bsems[_OS_Temp-1] = 0;
256:                   } while (--_OS_Temp);
257:           
258:               #else
259:                   #if OS_BSEMS > 0
260:                       _OS_Bsems[0] = 0;
261:                   #endif
262:           
263:                   #if OS_BSEMS > 1*8
264:                       _OS_Bsems[1] = 0;
265:                   #endif
266:           
267:                   #if OS_BSEMS > 2*8
268:                       _OS_Bsems[2] = 0;
269:                   #endif
270:           
271:                   #if OS_BSEMS > 3*8
272:                       _OS_Bsems[3] = 0;
273:                   #endif
274:           
275:                   #if OS_BSEMS > 4*8
276:                       _OS_Bsems[4] = 0;
277:                   #endif
278:           
279:                   #if OS_BSEMS > 5*8
280:                       _OS_Bsems[5] = 0;
281:                   #endif
282:           
283:                   #if OS_BSEMS > 6*8
284:                       _OS_Bsems[6] = 0;
285:                   #endif
286:           
287:                   #if OS_BSEMS > 7*8
288:                       _OS_Bsems[7] = 0;
289:                   #endif
290:           
291:                   #if OS_BSEMS > 8*8
292:                       _OS_Bsems[8] = 0;
293:                   #endif
294:           
295:                   #if OS_BSEMS > 9*8
296:                       _OS_Bsems[9] = 0;
297:                   #endif
298:           
299:                   #if OS_BSEMS > 10*8
300:                       _OS_Bsems[10] = 0;
301:                   #endif
302:               #endif
303:           
304:           
305:               /*--------------------------------------*
306:                *                                      *
307:                *  Zero all task descriptors           *
308:                *                                      *
309:                *--------------------------------------*/
310:           
311:               #if OS_TASKS > 10
312:                   _OS_SET_IRP_CUR_TASK();
313:                   _OS_CurTask = (OST_TASK_POINTER) _OS_Tasks;
314:                   _OS_Temp = OS_TASKS;
315:                   do {
316:                       _OS_CurTask->State.bEnable = 0;
317:                       _OS_CurTask ++;
318:                   } while (--_OS_Temp);
319:                   _OS_CLR_IRP();
320:               #else
321:           
322:                   #if OS_PRIORITY_LEVEL == OS_PRIORITY_DISABLED
323:                       _OS_CurTask = (OST_TASK_POINTER) _OS_Tasks + (OS_TASKS-1);
324:                   #endif
325:           
326:                   _OS_Tasks[0].State.bEnable = 0;
40C2  9C05     BCF _OS_Tasks, 6, ACCESS
327:           
328:                   #if OS_TASKS > 1
329:                      _OS_Tasks[1].State.bEnable = 0;
40C4  9C0A     BCF 0xA, 6, ACCESS
330:                   #endif
331:           
332:                   #if OS_TASKS > 2
333:                      _OS_Tasks[2].State.bEnable = 0;
40C6  9C0F     BCF 0xF, 6, ACCESS
334:                   #endif
335:           
336:                   #if OS_TASKS > 3
337:                      _OS_Tasks[3].State.bEnable = 0;
40C8  9C14     BCF 0x14, 6, ACCESS
338:                   #endif
339:           
340:                   #if OS_TASKS > 4
341:                      _OS_Tasks[4].State.bEnable = 0;
40CA  9C19     BCF 0x19, 6, ACCESS
342:                   #endif
343:           
344:                   #if OS_TASKS > 5
345:                      _OS_Tasks[5].State.bEnable = 0;
346:                   #endif
347:           
348:                   #if OS_TASKS > 6
349:                      _OS_Tasks[6].State.bEnable = 0;
350:                   #endif
351:           
352:                   #if OS_TASKS > 7
353:                      _OS_Tasks[7].State.bEnable = 0;
354:                   #endif
355:           
356:                   #if OS_TASKS > 8
357:                      _OS_Tasks[8].State.bEnable = 0;
358:                   #endif
359:           
360:                   #if OS_TASKS > 9
361:                      _OS_Tasks[9].State.bEnable = 0;
362:                   #endif
363:           
364:               #endif
365:           
366:           
367:               /*--------------------------------------*
368:                *                                      *
369:                *  Zero task queue for extended        *
370:                *  priority mode                       *
371:                *                                      *
372:                *--------------------------------------*/
373:           
374:               //------------------------------------------------------------------------------
375:               #if (OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED)
376:               //------------------------------------------------------------------------------
377:           
378:           
379:               _OS_SET_IRP_CUR_TASK();
380:               _OS_CurTask = (OST_TASK_POINTER) _OS_Tasks;
381:               _OS_Temp = OS_TASKS;
382:               do
383:               {
384:                   _OS_TaskQueue[_OS_Temp-1] = _OS_Temp-1;
385:                   _OS_TaskLevel[_OS_Temp-1] = 0;
386:               } while (--_OS_Temp);
387:               _OS_CLR_IRP();
388:           
389:               //------------------------------------------------------------------------------
390:               #endif
391:               //------------------------------------------------------------------------------
392:           
393:           
394:           }
40CC  0012     RETURN 0
395:           
396:           
397:           
398:           /*
399:            ************************************************************************************************
400:            *                                                                                              *
401:            *                         C R I T I C A L   S E C T I O N S                                    *
402:            *                                                                                              *
403:            ************************************************************************************************
404:            */
405:           
406:           //------------------------------------------------------------------------------
407:           #ifdef OS_ENABLE_CRITICAL_SECTION
408:           //------------------------------------------------------------------------------
409:           
410:           /*
411:            ********************************************************************************
412:            *
413:            *   void OS_EnterCriticalSection (void)
414:            *
415:            *------------------------------------------------------------------------------
416:            *
417:            *   description:   Enter critical section.
418:            *                  This function disables interrupts (with saving current
419:            *                  state) and sets system flag bInCriticalSection
420:            *
421:            *
422:            *  parameters:     none
423:            *
424:            *  on return:      none
425:            *
426:            *  Overloaded in:  "osa_pic16_htpicc.c"
427:            *                  "osa_pic16_mikroc.c"
428:            *                  "osa_pic16_ccs.c"
429:            *                  "osa_pic24_mplabc.c"
430:            *                  "osa_stm8_cosmic.c"
431:            *
432:            ********************************************************************************
433:            */
434:           
435:           //------------------------------------------------------------------------------
436:           #if !defined(OS_EnterCriticalSection_DEFINED)
437:           //------------------------------------------------------------------------------
438:           
439:           
440:           //------------------------------------------------------------------------------
441:           #ifdef      __OSA18__
442:           //------------------------------------------------------------------------------
443:           
444:               void OS_EnterCriticalSection (void)
445:               {
446:                   OST_UINT temp;
447:           
448:                   temp = OS_DI();
449:                   _OS_Flags.bInCriticalSection = 1;
450:           
451:                   _OS_Flags.bGIE_CTemp = 0;
452:                   if (temp & 0x80) _OS_Flags.bGIE_CTemp = 1;
453:           
454:                   _OS_Flags.bGIEL_CTemp = 0;
455:                   if (temp & 0x40) _OS_Flags.bGIEL_CTemp = 1;
456:               }
457:           
458:           
459:           //------------------------------------------------------------------------------
460:           #else   //  __OSA18__
461:           //------------------------------------------------------------------------------
462:           
463:               void OS_EnterCriticalSection (void)
464:               {
465:                   _OS_Flags.bGIE_CTemp = 0;
466:                   if (OS_DI() & 0x80) _OS_Flags.bGIE_CTemp = 1;
467:                   _OS_Flags.bInCriticalSection = 1;
468:           
469:               }
470:           
471:           //------------------------------------------------------------------------------
472:           #endif  //  __OSA18__
473:           //------------------------------------------------------------------------------
474:           
475:           //------------------------------------------------------------------------------
476:           #endif
477:           //------------------------------------------------------------------------------
478:           
479:           
480:           
481:           
482:           /*
483:            ********************************************************************************
484:            *
485:            *   void OS_LeaveCriticalSection (void)
486:            *
487:            *------------------------------------------------------------------------------
488:            *
489:            *  description:    Leave critical section.
490:            *                  This function restore interrupt state from OS_Flag temp bits
491:            *                  and clears system flag bInCriticalSection
492:            *
493:            *  parameters:     none
494:            *
495:            *  on return:      none
496:            *
497:            *
498:            *  Overloaded in:  "osa_pic16_htpicc.c"
499:            *                  "osa_pic16_ccs.c"
500:            *                  "osa_pic16_mikroc.c"
501:            *                  "osa_pic24_mplabc.c"
502:            *                  "osa_stm8_cosmic.c"
503:            *
504:            ********************************************************************************
505:            */
506:           
507:           //------------------------------------------------------------------------------
508:           #if !defined(OS_LeaveCriticalSection_DEFINED)
509:           //------------------------------------------------------------------------------
510:           
511:           //------------------------------------------------------------------------------
512:           #ifdef      __OSA18__
513:           //------------------------------------------------------------------------------
514:           
515:               void OS_LeaveCriticalSection (void)
516:               {
517:                   char temp;
518:                   _OS_Flags.bInCriticalSection = 0;
519:                   temp = 0;
520:                   if (_OS_Flags.bGIE_CTemp)  temp |= 0x80;
521:                   if (_OS_Flags.bGIEL_CTemp) temp |= 0x40;
522:                   OS_RI(temp);
523:               }
524:           
525:           //------------------------------------------------------------------------------
526:           #else   //  __OSA18__
527:           //------------------------------------------------------------------------------
528:           
529:               void OS_LeaveCriticalSection (void)
530:               {
531:                   _OS_Flags.bInCriticalSection = 0;
532:                   if (_OS_Flags.bGIE_CTemp) OS_RI(0x80);
533:               }
534:           
535:           //------------------------------------------------------------------------------
536:           #endif  //  __OSA18__
537:           //------------------------------------------------------------------------------
538:           
539:           //------------------------------------------------------------------------------
540:           #endif
541:           //------------------------------------------------------------------------------
542:           
543:           //------------------------------------------------------------------------------
544:           #endif  //  OS_ENABLE_CRITICAL_SECTION
545:           //------------------------------------------------------------------------------
546:           
547:           
548:           
549:           
550:           
551:           
552:           
553:           
554:           /*
555:            ************************************************************************************************
556:            *                                                                                              *
557:            *                                   S Y S T E M   T I M E R                                    *
558:            *                                                                                              *
559:            ************************************************************************************************
560:            */
561:           
562:           
563:           
564:           //-----------------------------------------------------------------
565:           #ifdef OS_ENABLE_OS_TIMER
566:           #ifndef OS_USE_INLINE_TIMER
567:           //-----------------------------------------------------------------
568:           void OS_Timer (void)
569:           {
570:               __OS_TimerInline();
40CE  0100     MOVLB 0x0
40D0  A905     BTFSS _OS_Tasks, 4, BANKED
40D2  D002     BRA 0x40D8
40D4  4B09     INFSNZ 0x9, F, BANKED
40D6  9905     BCF _OS_Tasks, 4, BANKED
40D8  A90A     BTFSS 0xA, 4, BANKED
40DA  D002     BRA 0x40E0
40DC  4B0E     INFSNZ 0xE, F, BANKED
40DE  990A     BCF 0xA, 4, BANKED
40E0  A90F     BTFSS 0xF, 4, BANKED
40E2  D002     BRA 0x40E8
40E4  4B13     INFSNZ 0x13, F, BANKED
40E6  990F     BCF 0xF, 4, BANKED
40E8  A914     BTFSS 0x14, 4, BANKED
40EA  D002     BRA 0x40F0
40EC  4B18     INFSNZ 0x18, F, BANKED
40EE  9914     BCF 0x14, 4, BANKED
40F0  A919     BTFSS 0x19, 4, BANKED
40F2  D002     BRA 0x40F8
40F4  4B1D     INFSNZ 0x1D, F, BANKED
40F6  9919     BCF 0x19, 4, BANKED
571:           }
40F8  0012     RETURN 0
572:           //-----------------------------------------------------------------
573:           #endif  // OS_ENABLE_OS_TIMER
574:           #endif  // OS_USE_INLINE_TIMER
575:           //-----------------------------------------------------------------
576:           
577:           
578:           
579:           
580:           
581:           
582:           /*
583:            ********************************************************************************
584:            *
585:            *  OST_BOOL _OS_CheckEvent (char bEvent)
586:            *
587:            *------------------------------------------------------------------------------
588:            *
589:            *  description:    (Internal function called by system kernel througth
590:            *                  waiting services)
591:            *
592:            *                  Check condition of bEvent. Accordint to bEvent value and
593:            *                  current state of bReady, bDelay and bCanContinue flags,
594:            *                  task becames ready to execute or still remains in waiting
595:            *                  mode.
596:            *
597:            *  parameters:     bEvent - zero, or non-zero condition
598:            *
599:            *  on return:      1 - when condition is true, or timeout occured
600:            *                  0 - condition is false and no timeout
601:            *
602:            *  Overloaded in:  "osa_pic12_htpicc.c"
603:            *                  "osa_pic16_htpicc.c"
604:            *                  "osa_pic18_htpicc.c"
605:            *                  "osa_pic16_mikroc.c"
606:            *                  "osa_pic18_mikroc.c"
607:            *                  "osa_pic18_mplabc.c"
608:            *                  "osa_pic24_mplabc.c"
609:            *                  "osa_pic16_ccs.c"
610:            *                  "osa_pic18_ccs.c"
611:            *
612:            ********************************************************************************
613:            */
614:           
615:           //------------------------------------------------------------------------------
616:           #if !defined(_OS_CheckEvent_DEFINED)
617:           //------------------------------------------------------------------------------
618:           
619:               OST_BOOL _OS_CheckEvent (char bEvent)
620:               {
621:                   _OS_Flags.bTimeout = 0;
622:           
623:                   if (bEvent)
624:                   {
625:                       if (_OS_CurTask->State.bReady)
626:                       {
627:                           #ifdef OS_ENABLE_TTIMERS
628:                               _OS_TASK_ATOMIC_WRITE_A(_OS_CurTask->State.bDelay = 0);
629:                           #endif
630:           
631:                           #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED
632:                           _OS_Flags.bEventOK = 1;
633:                           #endif
634:           
635:                           return 1;
636:                       }
637:           
638:                       _OS_bTaskReady = 1;
639:           
640:                   } else {
641:                       _OS_bTaskReady = 0;
642:                   }
643:           
644:                   #ifdef OS_ENABLE_TTIMERS
645:           
646:                       if (!_OS_CurTask->State.bDelay && _OS_CurTask->State.bCanContinue)
647:                       {
648:                           _OS_bTaskReady = 1;
649:                           _OS_Flags.bTimeout = 1;
650:           
651:                           #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED
652:                           _OS_Flags.bEventOK = 1;
653:                           #endif
654:           
655:                           return 1;
656:           
657:                       }
658:           
659:                   #endif
660:           
661:                   return 0;
662:           
663:               }
664:           
665:           //------------------------------------------------------------------------------
666:           #endif  // !defined(_OS_CheckEvent_DEFINED)
667:           //------------------------------------------------------------------------------
668:           
669:           
670:           
671:           //******************************************************************************
672:           //  END OF FILE osa_system.c
673:           //******************************************************************************
674:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_sound/module_sound.c  ---------------------
1:             #include "module_sound.h"
2:             #include <p18cxxx.h>
3:             #include "module_management.h"
4:             #include "module_logic_inputs.h"
5:             
6:             #define TIME_BUTTON_SUBMERGENCE_CONST		75U				//время подзвучки кнопки в мс
7:             #define TIME_FLASH_SOUND_CONST				500U			//время звука в аварийном режиме в мс
8:             #define SOUND_PIN							LATCbits.LATC5	//пин звука
9:             #define SOUND_TRIS							TRISCbits.TRISC5	//пин звука
10:            
11:            typedef struct 
12:            {
13:            	uint16_t time_flash_sound;
14:            	BOOL flag_flash_sound;
15:            	uint16_t time_button_submergence;
16:            }TimeMSound;
17:            
18:            
19:            /*Структуры модуля  */
20:            static TimeMSound time_M_Sound = { 0, 0, 0};
21:            
22:            
23:            /* Переменные модуля */
24:            BOOL button_submergence = 0; 	//флаг подзвучки кнопки
25:            
26:            
27:            /*Методы модуля */
28:            
29:            void M_Sound_ctor( void )
30:            {
31:                SOUND_TRIS = OUT;
479E  9A94     BCF TRISC, 5, ACCESS
32:                SOUND_PIN = OFF;
47A0  9A8B     BCF LATC, 5, ACCESS
33:            }
47A2  0012     RETURN 0
34:            
35:            /* Установка флага подзвучки кнопок */
36:            void M_Sound_set_button_submergence (BOOL value)
47A4  CFD9     MOVFF FSR2, POSTINC1
47A6  FFE6     NOP
47A8  CFE1     MOVFF FSR1, FSR2
47AA  FFD9     NOP
37:            {
38:            	button_submergence = value;
47AC  0EFE     MOVLW 0xFE
47AE  CFDB     MOVFF PLUSW2, button_submergence
47B0  F0FC     NOP
39:            }
47B2  52E5     MOVF POSTDEC1, F, ACCESS
47B4  CFE7     MOVFF INDF1, FSR2
47B6  FFD9     NOP
47B8  0012     RETURN 0
40:            
41:            
42:            void M_Sound_run (void)
43:            {
44:            	if(M_Mngm_Get_parameters_buffer()->menu_parameters.enable_sound && M_Mngm_Get_state() != STATE_PAUSE)  //если звук разрешён
47BA  EC8E     CALL 0x151C, 0
47BC  F00A     NOP
47BE  CFF3     MOVFF PROD, FSR0
47C0  FFE9     NOP
47C2  CFF4     MOVFF PRODH, FSR0H
47C4  FFEA     NOP
47C6  0E29     MOVLW 0x29
47C8  26E9     ADDWF FSR0, F, ACCESS
47CA  0E00     MOVLW 0x0
47CC  22EA     ADDWFC FSR0H, F, ACCESS
47CE  50EF     MOVF INDF0, W, ACCESS
47D0  E04F     BZ 0x4870
47D2  ECA7     CALL 0x154E, 0
47D4  F00A     NOP
47D6  0803     SUBLW 0x3
47D8  E04B     BZ 0x4870
45:            	{
46:            		if(button_submergence) 	//если установлено разрешение подзвучки кнопок
47DA  0100     MOVLB 0x0
47DC  51FC     MOVF button_submergence, W, BANKED
47DE  E014     BZ 0x4808
47:            		{
48:            			SOUND_PIN = !SOUND_PIN;
47E0  7A8B     BTG LATC, 5, ACCESS
49:            			//отсчёт времени подзвучки кнопок
50:            			if(time_M_Sound.time_button_submergence++ == TIME_BUTTON_SUBMERGENCE_CONST)
47E2  0100     MOVLB 0x0
47E4  C0FA     MOVFF 0xFA, __tmp_0
47E6  F032     NOP
47E8  C0FB     MOVFF 0xFB, 0x33
47EA  F033     NOP
47EC  2BFA     INCF 0xFA, F, BANKED
47EE  0E00     MOVLW 0x0
47F0  23FB     ADDWFC 0xFB, F, BANKED
47F2  0E4B     MOVLW 0x4B
47F4  1832     XORWF __tmp_0, W, ACCESS
47F6  E101     BNZ 0x47FA
47F8  5033     MOVF 0x33, W, ACCESS
47FA  E106     BNZ 0x4808
51:            			{
52:            				time_M_Sound.time_button_submergence = 0;
47FC  0100     MOVLB 0x0
47FE  6BFA     CLRF 0xFA, BANKED
4800  6BFB     CLRF 0xFB, BANKED
53:            				SOUND_PIN = OFF;
4802  9A8B     BCF LATC, 5, ACCESS
54:            				button_submergence = OFF;
4804  0100     MOVLB 0x0
4806  6BFC     CLRF button_submergence, BANKED
55:            			}
56:            		}	
57:            		//в состоянии аварии звук "меандром" с периодом TIME_FLASH_SOUND_CONST*2
58:            		if(M_Mngm_Get_state() ==  STATE_FAILURE) 
4808  ECA7     CALL 0x154E, 0
480A  F00A     NOP
480C  0805     SUBLW 0x5
480E  E129     BNZ 0x4862
59:            		{
60:            			SOUND_PIN = time_M_Sound.flag_flash_sound ? OFF : !SOUND_PIN; 
4810  0100     MOVLB 0x0
4812  51F9     MOVF 0xF9, W, BANKED
4814  E002     BZ 0x481A
4816  0E00     MOVLW 0x0
4818  D005     BRA 0x4824
481A  508B     MOVF LATC, W, ACCESS
481C  0B20     ANDLW 0x20
481E  0A20     XORLW 0x20
4820  E001     BZ 0x4824
4822  0E01     MOVLW 0x1
4824  B0E8     BTFSC WREG, 0, ACCESS
4826  8A8B     BSF LATC, 5, ACCESS
4828  A0E8     BTFSS WREG, 0, ACCESS
482A  9A8B     BCF LATC, 5, ACCESS
61:            			if(time_M_Sound. time_flash_sound++ == TIME_FLASH_SOUND_CONST)
482C  0100     MOVLB 0x0
482E  C0F7     MOVFF time_M_Sound, __tmp_0
4830  F032     NOP
4832  C0F8     MOVFF 0xF8, 0x33
4834  F033     NOP
4836  2BF7     INCF time_M_Sound, F, BANKED
4838  0E00     MOVLW 0x0
483A  23F8     ADDWFC 0xF8, F, BANKED
483C  0EF4     MOVLW 0xF4
483E  1832     XORWF __tmp_0, W, ACCESS
4840  E102     BNZ 0x4846
4842  0E01     MOVLW 0x1
4844  1833     XORWF 0x33, W, ACCESS
4846  E10C     BNZ 0x4860
62:            			{
63:            				time_M_Sound. time_flash_sound = 0;
4848  0100     MOVLB 0x0
484A  6BF7     CLRF time_M_Sound, BANKED
484C  6BF8     CLRF 0xF8, BANKED
64:            				time_M_Sound.flag_flash_sound = !time_M_Sound.flag_flash_sound;
484E  0100     MOVLB 0x0
4850  51F9     MOVF 0xF9, W, BANKED
4852  E002     BZ 0x4858
4854  0E00     MOVLW 0x0
4856  D001     BRA 0x485A
4858  0E01     MOVLW 0x1
485A  0100     MOVLB 0x0
485C  6FF9     MOVWF 0xF9, BANKED
65:            				SOUND_PIN = !SOUND_PIN;	
485E  7A8B     BTG LATC, 5, ACCESS
66:            			}	
67:            		}
68:            		else
4860  D006     BRA 0x486E
69:            		{
70:            			if(!button_submergence)  
4862  0100     MOVLB 0x0
4864  51FC     MOVF button_submergence, W, BANKED
4866  E103     BNZ 0x486E
71:            			{	
72:            				SOUND_PIN = OFF;	
4868  9A8B     BCF LATC, 5, ACCESS
73:            				time_M_Sound.flag_flash_sound = OFF;
486A  0100     MOVLB 0x0
486C  6BF9     CLRF 0xF9, BANKED
74:            			}
75:            		}
76:            	}
77:            	else
486E  D008     BRA 0x4880
78:            	{
79:            		SOUND_PIN = OFF;
4870  9A8B     BCF LATC, 5, ACCESS
80:            		button_submergence = FALSE;
4872  0100     MOVLB 0x0
4874  6BFC     CLRF button_submergence, BANKED
81:            		time_M_Sound.time_button_submergence = 0;
4876  0100     MOVLB 0x0
4878  6BFA     CLRF 0xFA, BANKED
487A  6BFB     CLRF 0xFB, BANKED
82:            		time_M_Sound.flag_flash_sound = OFF;
487C  0100     MOVLB 0x0
487E  6BF9     CLRF 0xF9, BANKED
83:            	}
84:            }
4880  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_motor/module_motor.c  ---------------------
1:             #include "module_management.h"
2:             #include <p18cxxx.h>
3:             #include <string.h>
4:             #include "module_motor.h"
5:             #include "module_logic_inputs.h"
6:             #include "module_indication.h"
7:             #include "interrupts.h"
8:             #include "main.h"
9:             #include "OSA.h"
10:            
11:            
12:            #define PWM_PERIOD                  25U  			//25 шагов ШИМа. Период ШИМа примерно 211мкс*25
13:            #define MAX_PWM_DUTY_PERCENT        100U
14:            
15:            #define ENABLE_TMR2_INTR            2
16:            #define DISABLE_TMR2_INTR           0
17:            
18:            #define NULL                        0
19:            
20:            #define ACCELERATION_MOTOR			0U
21:            #define WORKING_MOTOR				1U
22:            #define STOPPING_MOTOR				2U
23:            #define BRAKING_MOTOR				3U
24:            
25:            #define CALC_PARAMS									0U
26:            #define ACCELERATION								1U
27:            #define MOTOR_IS_ACCELERATED						2U
28:            
29:            #define MOTOR_IN_START_OR_END_POSITION              1U
30:            #define MOTOR_IN_FAILURE                            2U
31:            #define MOTOR_CHECKING                              0U
32:            
33:            #define TIME_BRAKE_MOTOR_CONST                      50U  	 //время торможения двигателя 20 мс
34:            #define TIME_PAUSE_DISPENSER_CONST                  2000U   //время паузы дозатора при загрузке топлива (в мс)
35:            #define TIME_AGITATOR_SENSOR_SURVEY                 8500U
36:            
37:            //#define TIME_CTRL_LS_AFTER_BEGIN				1500U
38:            //#define TIME_CTRL_LS_AFTER_BEGIN				2000U	  //время (мc), по истечении которого при вращении двигателя должен изменить состояние концевик
39:            #define TIME_CTRL_LS_AFTER_BEGIN				3000U
40:            #define TIME_ROTATE_MOTOR_IN_REVERSE            45U  	 //время (мc) торможения противовключением
41:            //#define TIME_ROTATE_MOTOR_IN_REVERSE          30U
42:            #define TIME_PAUSE_SHATTER_CONST                2000U    //время паузы заслонки при загрузке топлива
43:            
44:            #define TIMER2_INIT_VALUE                       0b00001101
45:            #define TIMER2_OFF_VALUE                        0
46:            
47:            #define FAILURE                                 3U
48:            #define NEED_REVERSE                            2U
49:            #define NEED_NEXT_STEP                          1U
50:            #define IS_BUSY                                 0U
51:            
52:            #define IS_FALSE_LS_FAILURE                     1
53:            #define NO_FALSE_LS_FAILURE                     0
54:            
55:            #define BRAKE_HIGH_SW                           1
56:            #define ROTATE_REVERSE                          0
57:            
58:            
59:            #define QUESTION_LS_FALSE_OFF 		1
60:            #define QUESTION_LS_FALSE_ON 		0
61:            
62:            #define PIN_COMMON_HALF_BRIDGE_H        LATHbits.LATH0     
63:            #define PIN_COMMON_HALF_BRIDGE_L        LATHbits.LATH1
64:            #define TRIS_COMMON_HALF_BRIDGE_H       TRISHbits.TRISH0
65:            #define TRIS_COMMON_HALF_BRIDGE_L       TRISHbits.TRISH1
66:            
67:            #define PIN_AGITATOR_1_SECOND_HALF_H    LATHbits.LATH3
68:            #define PIN_AGITATOR_1_SECOND_HALF_L    LATEbits.LATE0
69:            #define TRIS_AGITATOR_1_SECOND_HALF_H   TRISHbits.TRISH3
70:            #define TRIS_AGITATOR_1_SECOND_HALF_L   TRISEbits.TRISE0
71:            
72:            #define PIN_AGITATOR_2_SECOND_HALF_H    LATHbits.LATH2   
73:            #define PIN_AGITATOR_2_SECOND_HALF_L    LATEbits.LATE1
74:            #define TRIS_AGITATOR_2_SECOND_HALF_H   TRISHbits.TRISH2
75:            #define TRIS_AGITATOR_2_SECOND_HALF_L   TRISEbits.TRISE1
76:            
77:            #define PIN_DISPENSER_SECOND_HALF_H     LATGbits.LATG3
78:            #define PIN_DISPENSER_SECOND_HALF_L     LATGbits.LATG0
79:            #define TRIS_DISPENSER_SECOND_HALF_H    TRISGbits.TRISG3
80:            #define TRIS_DISPENSER_SECOND_HALF_L    TRISGbits.TRISG3
81:            
82:            #define PIN_SHATTER_SECOND_HALF_H       LATFbits.LATF5   
83:            #define PIN_SHATTER_SECOND_HALF_L       LATFbits.LATF6
84:            #define TRIS_SHATTER_SECOND_HALF_H      TRISFbits.TRISF5
85:            #define TRIS_SHATTER_SECOND_HALF_L      TRISFbits.TRISF6
86:            
87:            #define PIN_ASH_CLEANING_SECOND_HALF_H  LATFbits.LATF7
88:            #define PIN_ASH_CLEANING_SECOND_HALF_L  LATGbits.LATG4
89:            #define TRIS_ASH_CLEANING_SECOND_HALF_H TRISFbits.TRISF7
90:            #define TRIS_ASH_CLEANING_SECOND_HALF_L TRISGbits.TRISG4
91:            
92:            typedef struct 
93:            {
94:            	uint16_t time_step_accel;				//для отсчёта времени приращения разгона двигателя
95:            	uint16_t time_work_motor;               //для отсчёта времени максимальной работы двигателя		
96:            	uint16_t time_brake_motor;              //для отсчёта времени торможения двигателя
97:            	uint16_t time_rotate_motor_in_reverse;  //для отсчёта времени реверса двигателя при торможении
98:            	uint16_t time_pause;					//для отсчёта время паузы переж возвращением дозатора или заслонки назад	
99:            	uint16_t time_ctrl_ls_after_begin;		//для отсчёта времени после которого проверяется состояние концевика при вращении двигателя
100:           	uint16_t time_ls_agitator_survey;		//для отсчёта периода проеврки импульса датчика ворошителя
101:           }TIME_M_Motor;
102:           
103:           
104:           //TO DO исправить время работы ворошителя с 15 с на 30 с, время опроса датчика с 5 с на 15 с (#define TIME_AGITATOR_SENSOR_SURVEY)
105:           
106:           uint8_t cnt_duty = 0;
107:           uint8_t accel_state = 0;
108:           uint8_t saved_cnt_duty = 0;
109:           uint8_t M_Motor_PWM_period = 0;
110:           uint8_t M_Motor_state = 0;
111:           BOOL ctrl = OFF;
112:           uint8_t direction = TO_FORWARD_DISPENSER;
113:           uint8_t num_motor = 0;
114:           uint8_t ctrl_shatter = NO_MOVEMENT;  //для управления заслонкой в режиме чистки дымохода
115:           uint8_t cnt_step = 0;
116:           BOOL M_Motor_false_state_LS[QUANTITY_FALSE_LS] = {0, 0, 0, 0, 0};   				//для опроса ложно сработанных концевиков
117:           BOOL M_Motor_direction_question_LS[QUANTITY_FALSE_LS] = {0, 0, 0, 0, 0};  	//1 - опрос на ложное отключение, 0 - опрос на ложное включение
118:           BOOL* temp_start_ls = NULL;
119:           uint8_t temp_index;
120:           uint8_t M_Motor_prev_state = 0;
121:           
122:           TIME_M_Motor time_M_Motor = {0, 0, 0, 0, 0, 0, 0};
123:           FailureMotor M_Motor_failure_motor[QUANTITY_MOTORS] = {{0, 0}, {0, 0}, {0,0}}; 
124:           
125:           
126:           /* Массив структур пинов верхних и нижних ключей для вращения двигателя в прямом направлении */
127:           const rom IOport_motor motor_pins_forward[QUANTITY_MOTORS] =
128:           {
129:           	//дозатор
130:           	{
131:                   (volatile uint8_t* const)&LATH, 0,  //верхний ключ 1-го полумоста
132:                   (volatile uint8_t* const)&LATG, 0   //нижний ключ 2-го полумоста
133:               }, 			
134:           	
135:           	//ворошитель
136:           	{
137:                   (volatile uint8_t* const)&LATH, 0,	//верхний ключ 1-го полумоста
138:                   (volatile uint8_t* const)&LATE, 0   //нижний ключ 3-го полумоста
139:               }, 			
140:           	
141:               //заслонка 
142:           	{
143:                   (volatile uint8_t* const)&LATH, 0,		//верхний ключ 1-го полумоста
144:                   (volatile uint8_t* const)&LATG, 4       //нижний ключ 5-го полумоста
145:               },			
146:               
147:               //чистка золы
148:               {
149:                   (volatile uint8_t* const)&LATH, 0,		//верхний ключ 1-го полумоста
150:                   (volatile uint8_t* const)&LATF, 6       //нижний ключ 4-го полумоста
151:               }
152:           };
153:           
154:           /* Массив структур верхних и нижних ключей для вращения двигателя в обратном направлении */
155:           const rom IOport_motor motor_pins_backward[QUANTITY_MOTORS] =
156:           {
157:           	//дозатор
158:           	{
159:                   (volatile uint8_t* const)&LATG, 3,	//верхний ключ 2-го полумоста
160:                   (volatile uint8_t* const)&LATH, 1   //нижний ключ 1-го полумоста
161:               }, 		
162:           
163:           	//ворошитель
164:           	{
165:                   (volatile uint8_t* const)&LATH, 3,	//верхний ключ 3-го полумоста
166:                   (volatile uint8_t* const)&LATH, 1   //нижний ключ 1-го полумоста
167:               }, 		
168:               	
169:               //заслонка 
170:           	{
171:                   (volatile uint8_t* const)&LATF, 5,	//верхний ключ 4-го полумоста
172:                   (volatile uint8_t* const)&LATH, 1   //нижний ключ 1-го полумоста
173:               },		
174:               
175:               //чистка золы
176:               {
177:                   (volatile uint8_t* const)&LATF, 7,	//верхний ключ 1-го полумоста
178:                   (volatile uint8_t* const)&LATH, 1   //нижний ключ 1-го полумоста
179:               }
180:           };
181:           
182:           /* Массив структур верхних ключей двух полумостов для торможения */
183:           const rom IOport_motor  motor_pins_brake_high_sw[QUANTITY_MOTORS] = 
184:           {
185:           	//дозатор
186:           	{
187:                   (volatile uint8_t* const)&LATH, 0,	//верхний ключ 1-го полумоста
188:                   (volatile uint8_t* const)&LATG, 3   //верхний ключ 2-го полумоста
189:               }, 		
190:           
191:           	//ворошитель
192:           	{
193:                   (volatile uint8_t* const)&LATH, 0,	//верхний ключ 1-го полумоста
194:                   (volatile uint8_t* const)&LATH, 3   //верхний ключ 3-го полумоста
195:               }, 		
196:           
197:           	//заслонка 
198:           	{
199:                   (volatile uint8_t* const)&LATH, 0,	//верхний ключ 1-го полумоста
200:                   (volatile uint8_t* const)&LATF, 5   //верхний ключ 4-го полумоста
201:               },		
202:               
203:               //чистка золы
204:               {
205:                   (volatile uint8_t* const)&LATH, 0,		//верхний ключ 1-го полумоста
206:                   (volatile uint8_t* const)&LATF, 7   //нижний ключ 1-го полумоста
207:               }
208:           };
209:           
210:           /* Массив структур нижних ключей двух полумостов для торможения */
211:           const rom IOport_motor  motor_pins_brake_low_sw[QUANTITY_MOTORS] = 
212:           {
213:           	//дозатор
214:           	{
215:                   (volatile uint8_t* const)&LATH, 1,	//нижний ключ 1-го полумоста
216:                   (volatile uint8_t* const)&LATG, 0   //нижний ключ 2-го полумоста
217:               }, 		
218:           
219:           	//ворошитель
220:           	{
221:                   (volatile uint8_t* const)&LATH, 1,	//нижний ключ 1-го полумоста
222:                   (volatile uint8_t* const)&LATE, 0   //нижний ключ 3-го полумоста
223:               }, 		
224:           
225:           	//заслонка 
226:           	{
227:                   (volatile uint8_t* const)&LATH, 1,	//нижний ключ 1-го полумоста
228:                   (volatile uint8_t* const)&LATG, 4   //нижний ключ 4-го полумоста
229:               },		
230:           
231:               //чистка золы 
232:           	{
233:                   (volatile uint8_t* const)&LATH, 1,	//нижний ключ 1-го полумоста
234:                   (volatile uint8_t* const)&LATF, 6   //нижний ключ 4-го полумоста
235:               }	
236:           };
237:           
238:           const rom IOport_motor*  ptr_to_motor_pins = &motor_pins_forward [INDEX_OF_DISPENSER]; 
239:           											
240:           //Локальные функции модуля 
241:           static BOOL    M_Motor_check_ls_after_begin_start(BOOL ls, uint8_t index);
242:           static void    M_Motor_check_false_LS (LimitSwitch* struct_ls, const uint8_t size);
243:           static void    M_motor_forming_direction_question_LS(BOOL disp_st, BOOL disp_fin, BOOL shat_st, BOOL shat_fin, BOOL shat_after_fin);
244:           static uint8_t M_Motor_check_motor(uint8_t index, BOOL limit_switch, uint8_t type_of_ls, uint8_t* cnt_fail);
245:           static BOOL    M_Motor_is_brake(const rom IOport_motor* motor_pins, uint8_t which_ls, uint8_t num);
246:           static void    M_Motor_Timer2_change(const uint8_t value_timer_ctrl, const uint8_t en_intr);
247:           static void    M_Motor_clear_accel_state ( void );
248:           static uint8_t M_Motor_rotate (uint8_t index, BOOL limit_switch, uint8_t type_of_ls );
249:           static void    M_Motor_is_stopped ( const rom IOport_motor* motor_pins );
250:           static void    M_Motor_is_worked ( const rom IOport_motor* motor_pins );
251:           static void    M_Motor_accel ( uint8_t index );
252:           
253:           
254:           void M_Motor_ctor( void )
255:           {
256:               PIN_COMMON_HALF_BRIDGE_H           = OFF;         
0088  9090     BCF LATH, 0, ACCESS
257:               PIN_COMMON_HALF_BRIDGE_L           = OFF;  
008A  9290     BCF LATH, 1, ACCESS
258:               TRIS_COMMON_HALF_BRIDGE_H          = OUT;  
008C  9099     BCF TRISH, 0, ACCESS
259:               TRIS_COMMON_HALF_BRIDGE_L          = OUT;  
008E  9299     BCF TRISH, 1, ACCESS
260:           
261:               PIN_AGITATOR_1_SECOND_HALF_H       = OFF;   
0090  9690     BCF LATH, 3, ACCESS
262:               PIN_AGITATOR_1_SECOND_HALF_L       = OFF; 
0092  908D     BCF LATE, 0, ACCESS
263:               TRIS_AGITATOR_1_SECOND_HALF_H      = OUT; 
0094  9699     BCF TRISH, 3, ACCESS
264:               TRIS_AGITATOR_1_SECOND_HALF_L      = OUT; 
0096  9096     BCF TRISE, 0, ACCESS
265:           
266:               PIN_AGITATOR_2_SECOND_HALF_H       = OFF;           
0098  9490     BCF LATH, 2, ACCESS
267:               PIN_AGITATOR_2_SECOND_HALF_L       = OFF;    
009A  928D     BCF LATE, 1, ACCESS
268:               TRIS_AGITATOR_2_SECOND_HALF_H      = OUT; 
009C  9499     BCF TRISH, 2, ACCESS
269:               TRIS_AGITATOR_2_SECOND_HALF_L      = OUT; 
009E  9296     BCF TRISE, 1, ACCESS
270:           
271:               PIN_DISPENSER_SECOND_HALF_H        = OFF;     
00A0  968F     BCF LATG, 3, ACCESS
272:               PIN_DISPENSER_SECOND_HALF_L        = OFF;     
00A2  908F     BCF LATG, 0, ACCESS
273:               TRIS_DISPENSER_SECOND_HALF_H       = OUT; 
00A4  9698     BCF TRISG, 3, ACCESS
274:               TRIS_DISPENSER_SECOND_HALF_L       = OUT; 
00A6  9698     BCF TRISG, 3, ACCESS
275:           
276:               PIN_SHATTER_SECOND_HALF_H          = OFF;      
00A8  9A8E     BCF LATF, 5, ACCESS
277:               PIN_SHATTER_SECOND_HALF_L          = OFF;        
00AA  9C8E     BCF LATF, 6, ACCESS
278:               TRIS_SHATTER_SECOND_HALF_H         = OUT; 
00AC  9A97     BCF TRISF, 5, ACCESS
279:               TRIS_SHATTER_SECOND_HALF_L         = OUT; 
00AE  9C97     BCF TRISF, 6, ACCESS
280:           
281:               PIN_ASH_CLEANING_SECOND_HALF_H     = OFF;  
00B0  9E8E     BCF LATF, 7, ACCESS
282:               PIN_ASH_CLEANING_SECOND_HALF_L     = OFF;   
00B2  988F     BCF LATG, 4, ACCESS
283:               TRIS_ASH_CLEANING_SECOND_HALF_H    = OUT; 
00B4  9E97     BCF TRISF, 7, ACCESS
284:               TRIS_ASH_CLEANING_SECOND_HALF_L    = OUT; 
00B6  9898     BCF TRISG, 4, ACCESS
285:           }
00B8  0012     RETURN 0
286:           
287:           
288:           void M_Motor_clear_parameters(void)
289:           {
290:           	M_Motor_state = STATE_MODULE_MOTOR_WAITING;
00BA  0100     MOVLB 0x0
00BC  0E01     MOVLW 0x1
00BE  6F64     MOVWF M_Motor_state, BANKED
291:           	direction = TO_FORWARD_DISPENSER;
00C0  0100     MOVLB 0x0
00C2  0E01     MOVLW 0x1
00C4  6F66     MOVWF direction, BANKED
292:           	cnt_step = 0;
00C6  0100     MOVLB 0x0
00C8  6B69     CLRF cnt_step, BANKED
293:           	num_motor = INDEX_OF_AGITATOR;
00CA  0100     MOVLB 0x0
00CC  0E01     MOVLW 0x1
00CE  6F67     MOVWF num_motor, BANKED
294:           	ctrl = OFF;
00D0  0100     MOVLB 0x0
00D2  6B65     CLRF ctrl, BANKED
295:           }
00D4  0012     RETURN 0
296:           
297:           /* 
298:           Функция проверки изменения состояния концевика после начала вращения двигателя 
299:           через время TIME_CTRL_LS_AFTER_BEGIN 
300:           Входные параметры:
301:           
302:           */
303:           static BOOL M_Motor_check_ls_after_begin_start(BOOL ls, uint8_t index)
00D6  CFD9     MOVFF FSR2, POSTINC1
00D8  FFE6     NOP
00DA  CFE1     MOVFF FSR1, FSR2
00DC  FFD9     NOP
304:           {
305:           	if(M_LI_Get_Limit_Switches()->ls_hopper_cover_state)  //в режиме "Пауза эта проверка не делается"
00DE  ECBD     CALL 0x3B7A, 0
00E0  F01D     NOP
00E2  CFF3     MOVFF PROD, FSR0
00E4  FFE9     NOP
00E6  CFF4     MOVFF PRODH, FSR0H
00E8  FFEA     NOP
00EA  0E06     MOVLW 0x6
00EC  26E9     ADDWF FSR0, F, ACCESS
00EE  0E00     MOVLW 0x0
00F0  22EA     ADDWFC FSR0H, F, ACCESS
00F2  50EF     MOVF INDF0, W, ACCESS
00F4  E02E     BZ 0x152
306:           	{
307:           		if(time_M_Motor.time_ctrl_ls_after_begin++ == TIME_CTRL_LS_AFTER_BEGIN )
00F6  0100     MOVLB 0x0
00F8  C085     MOVFF 0x85, __tmp_0
00FA  F032     NOP
00FC  C086     MOVFF 0x86, 0x33
00FE  F033     NOP
0100  2B85     INCF 0x85, F, BANKED
0102  0E00     MOVLW 0x0
0104  2386     ADDWFC 0x86, F, BANKED
0106  0EB8     MOVLW 0xB8
0108  1832     XORWF __tmp_0, W, ACCESS
010A  E102     BNZ 0x110
010C  0E0B     MOVLW 0xB
010E  1833     XORWF 0x33, W, ACCESS
0110  E120     BNZ 0x152
308:           		{
309:           			M_Motor_false_state_LS[index] = ls;
0112  0EFD     MOVLW 0xFD
0114  50DB     MOVF PLUSW2, W, ACCESS
0116  6AEA     CLRF FSR0H, ACCESS
0118  0F6A     ADDLW 0x6A
011A  6EE9     MOVWF FSR0, ACCESS
011C  0E00     MOVLW 0x0
011E  22EA     ADDWFC FSR0H, F, ACCESS
0120  0EFE     MOVLW 0xFE
0122  CFDB     MOVFF PLUSW2, INDF0
0124  FFEF     NOP
310:           			time_M_Motor.time_ctrl_ls_after_begin = 0;
0126  0100     MOVLB 0x0
0128  6B85     CLRF 0x85, BANKED
012A  6B86     CLRF 0x86, BANKED
311:           			if(ls)
012C  0EFE     MOVLW 0xFE
012E  50DB     MOVF PLUSW2, W, ACCESS
0130  E00E     BZ 0x14E
312:           			{	
313:           				M_Motor_state = STATE_MODULE_MOTOR_FAILURE;			
0132  0100     MOVLB 0x0
0134  0E02     MOVLW 0x2
0136  6F64     MOVWF M_Motor_state, BANKED
314:           			 	M_Motor_is_stopped(ptr_to_motor_pins);
0138  C091     MOVFF ptr_to_motor_pins, POSTINC1
013A  FFE6     NOP
013C  C092     MOVFF 0x92, POSTINC1
013E  FFE6     NOP
0140  ECF0     CALL 0xFE0, 0
0142  F007     NOP
0144  52E5     MOVF POSTDEC1, F, ACCESS
0146  52E5     MOVF POSTDEC1, F, ACCESS
315:           			 	return IS_FALSE_LS_FAILURE;
0148  0E01     MOVLW 0x1
014A  D005     BRA 0x156
316:           			}
317:           			else
014C  D002     BRA 0x152
318:           				return NO_FALSE_LS_FAILURE;
014E  0E00     MOVLW 0x0
0150  D002     BRA 0x156
319:           		}	
320:           	}
321:           	return NO_FALSE_LS_FAILURE;
0152  0E00     MOVLW 0x0
0154  D000     BRA 0x156
322:           }
0156  52E5     MOVF POSTDEC1, F, ACCESS
0158  CFE7     MOVFF INDF1, FSR2
015A  FFD9     NOP
015C  0012     RETURN 0
323:           
324:           /* Формирование маски опроса концевиков в массив M_Motor_direction_question_LS */
325:           static void M_motor_forming_direction_question_LS(BOOL disp_st, BOOL disp_fin, BOOL shat_st, BOOL shat_fin, BOOL shat_after_fin)
015E  CFD9     MOVFF FSR2, POSTINC1
0160  FFE6     NOP
0162  CFE1     MOVFF FSR1, FSR2
0164  FFD9     NOP
326:           {
327:           	M_Motor_direction_question_LS[0] = disp_st; 
0166  0EFE     MOVLW 0xFE
0168  CFDB     MOVFF PLUSW2, M_Motor_direction_question_LS
016A  F071     NOP
328:           	M_Motor_direction_question_LS[1] = disp_fin;
016C  0EFD     MOVLW 0xFD
016E  CFDB     MOVFF PLUSW2, 0x72
0170  F072     NOP
329:           	M_Motor_direction_question_LS[2] = shat_st;
0172  0EFC     MOVLW 0xFC
0174  CFDB     MOVFF PLUSW2, 0x73
0176  F073     NOP
330:           	M_Motor_direction_question_LS[3] = shat_fin;
0178  0EFB     MOVLW 0xFB
017A  CFDB     MOVFF PLUSW2, 0x74
017C  F074     NOP
331:           	M_Motor_direction_question_LS[4] = shat_after_fin;
017E  0EFA     MOVLW 0xFA
0180  CFDB     MOVFF PLUSW2, 0x75
0182  F075     NOP
332:           }
0184  52E5     MOVF POSTDEC1, F, ACCESS
0186  CFE7     MOVFF INDF1, FSR2
0188  FFD9     NOP
018A  0012     RETURN 0
333:           
334:           void M_Motor_clear_false_state_LS(const uint8_t size)
018C  CFD9     MOVFF FSR2, POSTINC1
018E  FFE6     NOP
0190  CFE1     MOVFF FSR1, FSR2
0192  FFD9     NOP
0194  52E6     MOVF POSTINC1, F, ACCESS
335:           {
336:           	uint8_t counter;	
337:           
338:           	for(counter = 0; counter < size; counter++)
0196  6ADF     CLRF INDF2, ACCESS
0198  0EFE     MOVLW 0xFE
019A  50DB     MOVF PLUSW2, W, ACCESS
019C  5CDF     SUBWF INDF2, W, ACCESS
019E  E209     BC 0x1B2
01AE  2ADF     INCF INDF2, F, ACCESS
01B0  D7F3     BRA 0x198
339:           	{
340:           		M_Motor_false_state_LS[counter] = 0;
01A0  50DF     MOVF INDF2, W, ACCESS
01A2  6AEA     CLRF FSR0H, ACCESS
01A4  0F6A     ADDLW 0x6A
01A6  6EE9     MOVWF FSR0, ACCESS
01A8  0E00     MOVLW 0x0
01AA  22EA     ADDWFC FSR0H, F, ACCESS
01AC  6AEF     CLRF INDF0, ACCESS
341:           	}
342:           }
01B2  52E5     MOVF POSTDEC1, F, ACCESS
01B4  52E5     MOVF POSTDEC1, F, ACCESS
01B6  CFE7     MOVFF INDF1, FSR2
01B8  FFD9     NOP
01BA  0012     RETURN 0
343:           
344:           /* Проверка ложного состояния концевиков в отстутствие вращения двигателей */
345:           static void M_Motor_check_false_LS (LimitSwitch* struct_ls, const uint8_t size)
01BC  CFD9     MOVFF FSR2, POSTINC1
01BE  FFE6     NOP
01C0  CFE1     MOVFF FSR1, FSR2
01C2  FFD9     NOP
01C4  52E6     MOVF POSTINC1, F, ACCESS
346:           {
347:           	uint8_t counter;	
348:           
349:           	for(counter = 0; counter < size; counter++)
01C6  6ADF     CLRF INDF2, ACCESS
01C8  0EFC     MOVLW 0xFC
01CA  50DB     MOVF PLUSW2, W, ACCESS
01CC  5CDF     SUBWF INDF2, W, ACCESS
01CE  E209     BC 0x1E2
01DE  2ADF     INCF INDF2, F, ACCESS
01E0  D7F3     BRA 0x1C8
350:           	{
351:           		#ifdef NO_CONTROL_FALSE_STATE_LS
352:           			M_Motor_false_state_LS[counter] = 0;
01D0  50DF     MOVF INDF2, W, ACCESS
01D2  6AEA     CLRF FSR0H, ACCESS
01D4  0F6A     ADDLW 0x6A
01D6  6EE9     MOVWF FSR0, ACCESS
01D8  0E00     MOVLW 0x0
01DA  22EA     ADDWFC FSR0H, F, ACCESS
01DC  6AEF     CLRF INDF0, ACCESS
353:           		#else
354:           			M_Motor_false_state_LS[counter] = *((BOOL*)struct_ls + counter) ^ M_Motor_direction_question_LS[counter] ;
355:           		#endif
356:           	}
357:           }
01E2  52E5     MOVF POSTDEC1, F, ACCESS
01E4  52E5     MOVF POSTDEC1, F, ACCESS
01E6  CFE7     MOVFF INDF1, FSR2
01E8  FFD9     NOP
01EA  0012     RETURN 0
358:           
359:           BOOL* M_Motor_get_false_state_LS(void)
360:           {
361:           	return M_Motor_false_state_LS;
01EC  0E6A     MOVLW 0x6A
01EE  6E32     MOVWF __tmp_0, ACCESS
01F0  0E00     MOVLW 0x0
01F2  6E33     MOVWF 0x33, ACCESS
01F4  C032     MOVFF __tmp_0, PROD
01F6  FFF3     NOP
01F8  C033     MOVFF 0x33, PRODH
01FA  FFF4     NOP
01FC  D000     BRA 0x1FE
362:           }
01FE  0012     RETURN 0
363:           
364:           void M_Motor_set_state (uint8_t value)
0200  CFD9     MOVFF FSR2, POSTINC1
0202  FFE6     NOP
0204  CFE1     MOVFF FSR1, FSR2
0206  FFD9     NOP
365:           {
366:           	M_Motor_state = value;
0208  0EFE     MOVLW 0xFE
020A  CFDB     MOVFF PLUSW2, M_Motor_state
020C  F064     NOP
367:           }
020E  52E5     MOVF POSTDEC1, F, ACCESS
0210  CFE7     MOVFF INDF1, FSR2
0212  FFD9     NOP
0214  0012     RETURN 0
368:           
369:           uint8_t M_Motor_get_direction(void)
370:           {
371:           	return direction;
0216  0100     MOVLB 0x0
0218  5166     MOVF direction, W, BANKED
021A  D000     BRA 0x21C
372:           }
021C  0012     RETURN 0
373:           
374:           void M_Motor_set_work (BOOL value)
021E  CFD9     MOVFF FSR2, POSTINC1
0220  FFE6     NOP
0222  CFE1     MOVFF FSR1, FSR2
0224  FFD9     NOP
375:           {
376:           	ctrl = value;
0226  0EFE     MOVLW 0xFE
0228  CFDB     MOVFF PLUSW2, ctrl
022A  F065     NOP
377:           }
022C  52E5     MOVF POSTDEC1, F, ACCESS
022E  CFE7     MOVFF INDF1, FSR2
0230  FFD9     NOP
0232  0012     RETURN 0
378:           
379:           BOOL M_Motor_get_work(void)
380:           {
381:           	return ctrl;
0234  0100     MOVLB 0x0
0236  5165     MOVF ctrl, W, BANKED
0238  D000     BRA 0x23A
382:           }
023A  0012     RETURN 0
383:           
384:           uint8_t	M_Motor_get_state(void)
385:           {
386:           	return M_Motor_state;
023C  0100     MOVLB 0x0
023E  5164     MOVF M_Motor_state, W, BANKED
0240  D000     BRA 0x242
387:           }
0242  0012     RETURN 0
388:           
389:           void M_Motor_set_ctrl_shatter (uint8_t value)
0244  CFD9     MOVFF FSR2, POSTINC1
0246  FFE6     NOP
0248  CFE1     MOVFF FSR1, FSR2
024A  FFD9     NOP
390:           {
391:           	ctrl_shatter = value;
024C  0EFE     MOVLW 0xFE
024E  CFDB     MOVFF PLUSW2, ctrl_shatter
0250  F068     NOP
392:           }
0252  52E5     MOVF POSTDEC1, F, ACCESS
0254  CFE7     MOVFF INDF1, FSR2
0256  FFD9     NOP
0258  0012     RETURN 0
393:           
394:           uint8_t M_Motor_get_ctrl_shatter (void)
395:           {
396:           	return ctrl_shatter;
025A  0100     MOVLB 0x0
025C  5168     MOVF ctrl_shatter, W, BANKED
025E  D000     BRA 0x260
397:           }
0260  0012     RETURN 0
398:           
399:           
400:           FailureMotor* M_Motor_get_state_failure(uint8_t index)
0262  CFD9     MOVFF FSR2, POSTINC1
0264  FFE6     NOP
0266  CFE1     MOVFF FSR1, FSR2
0268  FFD9     NOP
401:           {
402:           	return &M_Motor_failure_motor[index];
026A  0EFE     MOVLW 0xFE
026C  6A33     CLRF 0x33, ACCESS
026E  34DB     RLCF PLUSW2, W, ACCESS
0270  0BFE     ANDLW 0xFE
0272  3633     RLCF 0x33, F, ACCESS
0274  6E32     MOVWF __tmp_0, ACCESS
0276  0E89     MOVLW 0x89
0278  2632     ADDWF __tmp_0, F, ACCESS
027A  0E00     MOVLW 0x0
027C  2233     ADDWFC 0x33, F, ACCESS
027E  C032     MOVFF __tmp_0, PROD
0280  FFF3     NOP
0282  C033     MOVFF 0x33, PRODH
0284  FFF4     NOP
0286  D000     BRA 0x288
403:           }
0288  52E5     MOVF POSTDEC1, F, ACCESS
028A  CFE7     MOVFF INDF1, FSR2
028C  FFD9     NOP
028E  0012     RETURN 0
404:           
405:           void M_Motor_clear_struct_failure_motor(void)
0290  CFD9     MOVFF FSR2, POSTINC1
0292  FFE6     NOP
0294  CFE1     MOVFF FSR1, FSR2
0296  FFD9     NOP
0298  52E6     MOVF POSTINC1, F, ACCESS
406:           {
407:           	uint8_t count;
408:           	for(count = 0; count < SIZE_STRUCT_MOTORS; count++)
029A  6ADF     CLRF INDF2, ACCESS
029C  0E03     MOVLW 0x3
029E  5CDF     SUBWF INDF2, W, ACCESS
02A0  E219     BC 0x2D4
02D0  2ADF     INCF INDF2, F, ACCESS
02D2  D7E4     BRA 0x29C
409:           		memset(&M_Motor_failure_motor[count], 0, sizeof M_Motor_failure_motor[count]);
02A2  0E02     MOVLW 0x2
02A4  6EE6     MOVWF POSTINC1, ACCESS
02A6  6AE6     CLRF POSTINC1, ACCESS
02A8  6AE6     CLRF POSTINC1, ACCESS
02AA  6A33     CLRF 0x33, ACCESS
02AC  34DF     RLCF INDF2, W, ACCESS
02AE  0BFE     ANDLW 0xFE
02B0  3633     RLCF 0x33, F, ACCESS
02B2  6E32     MOVWF __tmp_0, ACCESS
02B4  0E89     MOVLW 0x89
02B6  2632     ADDWF __tmp_0, F, ACCESS
02B8  0E00     MOVLW 0x0
02BA  2233     ADDWFC 0x33, F, ACCESS
02BC  C032     MOVFF __tmp_0, POSTINC1
02BE  FFE6     NOP
02C0  C033     MOVFF 0x33, POSTINC1
02C2  FFE6     NOP
02C4  EC59     CALL 0x4CB2, 0
02C6  F026     NOP
02C8  6E34     MOVWF 0x34, ACCESS
02CA  0E05     MOVLW 0x5
02CC  5EE1     SUBWF FSR1, F, ACCESS
02CE  5034     MOVF 0x34, W, ACCESS
410:           	memset(&time_M_Motor, 0, sizeof time_M_Motor);
02D4  0E0E     MOVLW 0xE
02D6  6EE6     MOVWF POSTINC1, ACCESS
02D8  6AE6     CLRF POSTINC1, ACCESS
02DA  6AE6     CLRF POSTINC1, ACCESS
02DC  0E7B     MOVLW 0x7B
02DE  6EE6     MOVWF POSTINC1, ACCESS
02E0  0E00     MOVLW 0x0
02E2  6EE6     MOVWF POSTINC1, ACCESS
02E4  EC59     CALL 0x4CB2, 0
02E6  F026     NOP
02E8  6E32     MOVWF __tmp_0, ACCESS
02EA  0E05     MOVLW 0x5
02EC  5EE1     SUBWF FSR1, F, ACCESS
02EE  5032     MOVF __tmp_0, W, ACCESS
411:           }
02F0  52E5     MOVF POSTDEC1, F, ACCESS
02F2  52E5     MOVF POSTDEC1, F, ACCESS
02F4  CFE7     MOVFF INDF1, FSR2
02F6  FFD9     NOP
02F8  0012     RETURN 0
412:           
413:           
414:           uint8_t M_Motor_get_prev_state(void)
415:           {
416:           	return M_Motor_prev_state;
02FA  0100     MOVLB 0x0
02FC  517A     MOVF M_Motor_prev_state, W, BANKED
02FE  D000     BRA 0x300
417:           }
0300  0012     RETURN 0
418:           
419:           
420:           /*Установка двигателей в начальное положение
421:           Входные параметры: 
422:           - индекс массива структур двигателей index
423:           - состояние соответствующего стартового концевика limit_switch
424:           - тип концевика type_of_ls
425:           */
426:           static uint8_t M_Motor_rotate(uint8_t index, BOOL limit_switch, uint8_t type_of_ls)
0302  CFD9     MOVFF FSR2, POSTINC1
0304  FFE6     NOP
0306  CFE1     MOVFF FSR1, FSR2
0308  FFD9     NOP
030A  52E6     MOVF POSTINC1, F, ACCESS
427:           {
428:           	
429:           	uint8_t pos_motor = MOTOR_CHECKING; 
030C  6ADF     CLRF INDF2, ACCESS
430:           	static BOOL is_motor_failure = FALSE;
431:           	
432:           	if(!M_LI_Get_Limit_Switches()->ls_hopper_cover_state )
030E  ECBD     CALL 0x3B7A, 0
0310  F01D     NOP
0312  CFF3     MOVFF PROD, FSR0
0314  FFE9     NOP
0316  CFF4     MOVFF PRODH, FSR0H
0318  FFEA     NOP
031A  0E06     MOVLW 0x6
031C  26E9     ADDWF FSR0, F, ACCESS
031E  0E00     MOVLW 0x0
0320  22EA     ADDWFC FSR0H, F, ACCESS
0322  50EF     MOVF INDF0, W, ACCESS
0324  E109     BNZ 0x338
433:           	{
434:           		M_Motor_is_stopped(ptr_to_motor_pins);
0326  C091     MOVFF ptr_to_motor_pins, POSTINC1
0328  FFE6     NOP
032A  C092     MOVFF 0x92, POSTINC1
032C  FFE6     NOP
032E  ECF0     CALL 0xFE0, 0
0330  F007     NOP
0332  52E5     MOVF POSTDEC1, F, ACCESS
0334  52E5     MOVF POSTDEC1, F, ACCESS
435:           	}
436:           	else
0336  D179     BRA 0x62A
437:           	{
438:           		switch(cnt_step) 
0338  0100     MOVLB 0x0
033A  5169     MOVF cnt_step, W, BANKED
033C  0A03     XORLW 0x3
033E  E101     BNZ 0x342
0340  D105     BRA 0x54C
0342  0A01     XORLW 0x1
0344  E101     BNZ 0x348
0346  D0EC     BRA 0x520
0348  0A03     XORLW 0x3
034A  E03E     BZ 0x3C8
034C  0A01     XORLW 0x1
034E  E001     BZ 0x352
0350  D16C     BRA 0x62A
439:           		{
440:           			case ACCELERATION_MOTOR:   		//состояние разгона двигателя
441:           				if(limit_switch && type_of_ls != AGITATOR_LS) //двигатель в стартовом положении, переход на останов (не проверять для датчика ворошителя) 
0352  0EFD     MOVLW 0xFD
0354  50DB     MOVF PLUSW2, W, ACCESS
0356  E029     BZ 0x3AA
0358  0EFC     MOVLW 0xFC
035A  50DB     MOVF PLUSW2, W, ACCESS
035C  0804     SUBLW 0x4
035E  E025     BZ 0x3AA
442:           				{
443:           					if(!accel_state)
0360  0100     MOVLB 0x0
0362  5161     MOVF accel_state, W, BANKED
0364  E104     BNZ 0x36E
444:           					{
445:           						pos_motor =  MOTOR_IN_START_OR_END_POSITION;
0366  0E01     MOVLW 0x1
0368  6EDF     MOVWF INDF2, ACCESS
446:           						break;		
036A  D15F     BRA 0x62A
447:           					}
448:           					else
036C  D01E     BRA 0x3AA
449:           					{
450:           						M_Motor_is_stopped(ptr_to_motor_pins);
036E  C091     MOVFF ptr_to_motor_pins, POSTINC1
0370  FFE6     NOP
0372  C092     MOVFF 0x92, POSTINC1
0374  FFE6     NOP
0376  ECF0     CALL 0xFE0, 0
0378  F007     NOP
037A  52E5     MOVF POSTDEC1, F, ACCESS
037C  52E5     MOVF POSTDEC1, F, ACCESS
451:           						M_Motor_failure_motor[index].is_failure = OFF;
037E  0EFE     MOVLW 0xFE
0380  6AEA     CLRF FSR0H, ACCESS
0382  34DB     RLCF PLUSW2, W, ACCESS
0384  0BFE     ANDLW 0xFE
0386  36EA     RLCF FSR0H, F, ACCESS
0388  6EE9     MOVWF FSR0, ACCESS
038A  0E89     MOVLW 0x89
038C  26E9     ADDWF FSR0, F, ACCESS
038E  0E00     MOVLW 0x0
0390  22EA     ADDWFC FSR0H, F, ACCESS
0392  6AEF     CLRF INDF0, ACCESS
452:           						M_Motor_clear_accel_state();
0394  EC07     CALL 0xE0E, 0
0396  F007     NOP
453:           						time_M_Motor.time_step_accel = 0;
0398  0100     MOVLB 0x0
039A  6B7B     CLRF time_M_Motor, BANKED
039C  6B7C     CLRF 0x7C, BANKED
454:           						cnt_step = STOPPING_MOTOR;
039E  0100     MOVLB 0x0
03A0  0E02     MOVLW 0x2
03A2  6F69     MOVWF cnt_step, BANKED
455:           						 is_motor_failure = FALSE;
03A4  0100     MOVLB 0x0
03A6  6B93     CLRF 0x93, BANKED
456:           						break;
03A8  D140     BRA 0x62A
457:           					}
458:           				}
459:           				M_Motor_accel(index); 							//разогнать двигатель
03AA  0EFE     MOVLW 0xFE
03AC  CFDB     MOVFF PLUSW2, POSTINC1
03AE  FFE6     NOP
03B0  EC52     CALL 0x10A4, 0
03B2  F008     NOP
03B4  52E5     MOVF POSTDEC1, F, ACCESS
460:           				if (accel_state == MOTOR_IS_ACCELERATED) 		//если двигатель разогнан
03B6  0E02     MOVLW 0x2
03B8  0100     MOVLB 0x0
03BA  5D61     SUBWF accel_state, W, BANKED
03BC  E104     BNZ 0x3C6
461:           				{
462:           					M_Motor_clear_accel_state(); 	
03BE  EC07     CALL 0xE0E, 0
03C0  F007     NOP
463:           					cnt_step++; 									//перейти к счёту максимального времени работы двигателя
03C2  0100     MOVLB 0x0
03C4  2B69     INCF cnt_step, F, BANKED
464:           				}	
465:           				break;
03C6  D131     BRA 0x62A
466:           			case WORKING_MOTOR:			//рабочее состояние двигателя (работа на максимальных оборотах)
467:           				M_Motor_is_worked(ptr_to_motor_pins); 		//включить соответствующий верхний и нижний ключ статически
03C8  C091     MOVFF ptr_to_motor_pins, POSTINC1
03CA  FFE6     NOP
03CC  C092     MOVFF 0x92, POSTINC1
03CE  FFE6     NOP
03D0  EC11     CALL 0xE22, 0
03D2  F007     NOP
03D4  52E5     MOVF POSTDEC1, F, ACCESS
03D6  52E5     MOVF POSTDEC1, F, ACCESS
468:           				if(limit_switch && type_of_ls != AGITATOR_LS) //двигатель в стартовом положении 
03D8  0EFD     MOVLW 0xFD
03DA  50DB     MOVF PLUSW2, W, ACCESS
03DC  E020     BZ 0x41E
03DE  0EFC     MOVLW 0xFC
03E0  50DB     MOVF PLUSW2, W, ACCESS
03E2  0804     SUBLW 0x4
03E4  E01C     BZ 0x41E
469:           				{
470:           					cnt_step++;
03E6  0100     MOVLB 0x0
03E8  2B69     INCF cnt_step, F, BANKED
471:           					time_M_Motor.time_work_motor = 0;
03EA  0100     MOVLB 0x0
03EC  6B7D     CLRF 0x7D, BANKED
03EE  6B7E     CLRF 0x7E, BANKED
472:           					M_Motor_failure_motor[index].is_failure = OFF;
03F0  0EFE     MOVLW 0xFE
03F2  6AEA     CLRF FSR0H, ACCESS
03F4  34DB     RLCF PLUSW2, W, ACCESS
03F6  0BFE     ANDLW 0xFE
03F8  36EA     RLCF FSR0H, F, ACCESS
03FA  6EE9     MOVWF FSR0, ACCESS
03FC  0E89     MOVLW 0x89
03FE  26E9     ADDWF FSR0, F, ACCESS
0400  0E00     MOVLW 0x0
0402  22EA     ADDWFC FSR0H, F, ACCESS
0404  6AEF     CLRF INDF0, ACCESS
473:           					M_Motor_is_stopped(ptr_to_motor_pins);
0406  C091     MOVFF ptr_to_motor_pins, POSTINC1
0408  FFE6     NOP
040A  C092     MOVFF 0x92, POSTINC1
040C  FFE6     NOP
040E  ECF0     CALL 0xFE0, 0
0410  F007     NOP
0412  52E5     MOVF POSTDEC1, F, ACCESS
0414  52E5     MOVF POSTDEC1, F, ACCESS
474:           					is_motor_failure = FALSE;
0416  0100     MOVLB 0x0
0418  6B93     CLRF 0x93, BANKED
475:           					break;
041A  D107     BRA 0x62A
476:           				}
477:           				else if(type_of_ls == AGITATOR_LS)  //для ворошителя
041C  D02F     BRA 0x47C
041E  0EFC     MOVLW 0xFC
0420  50DB     MOVF PLUSW2, W, ACCESS
0422  0804     SUBLW 0x4
0424  E12B     BNZ 0x47C
478:           				{
479:           					//если отсчитан интервал опроса датчика ворошителя
480:           					if(time_M_Motor.time_ls_agitator_survey ++ == TIME_AGITATOR_SENSOR_SURVEY )
0426  0100     MOVLB 0x0
0428  C087     MOVFF 0x87, __tmp_0
042A  F032     NOP
042C  C088     MOVFF 0x88, 0x33
042E  F033     NOP
0430  2B87     INCF 0x87, F, BANKED
0432  0E00     MOVLW 0x0
0434  2388     ADDWFC 0x88, F, BANKED
0436  0E34     MOVLW 0x34
0438  1832     XORWF __tmp_0, W, ACCESS
043A  E102     BNZ 0x440
043C  0E21     MOVLW 0x21
043E  1833     XORWF 0x33, W, ACCESS
0440  E11D     BNZ 0x47C
481:           					{
482:           						time_M_Motor.time_ls_agitator_survey = 0;
0442  0100     MOVLB 0x0
0444  6B87     CLRF 0x87, BANKED
0446  6B88     CLRF 0x88, BANKED
483:           						if(Intr_get_is_impulse_agitator_sensor())  //за период опроса был импульс на датчике	
0448  EC4C     CALL 0x4498, 0
044A  F022     NOP
044C  0900     IORLW 0x0
044E  E005     BZ 0x45A
484:           						{
485:           							Intr_set_is_impulse_agitator_sensor(FALSE);	
0450  6AE6     CLRF POSTINC1, ACCESS
0452  EC50     CALL 0x44A0, 0
0454  F022     NOP
0456  52E5     MOVF POSTDEC1, F, ACCESS
486:           						}
487:           						else  //переход к торможению двигателя и установке признака аварии
0458  D011     BRA 0x47C
488:           						{
489:           							time_M_Motor.time_work_motor = 0;
045A  0100     MOVLB 0x0
045C  6B7D     CLRF 0x7D, BANKED
045E  6B7E     CLRF 0x7E, BANKED
490:           							cnt_step++;
0460  0100     MOVLB 0x0
0462  2B69     INCF cnt_step, F, BANKED
491:           							M_Motor_is_stopped(ptr_to_motor_pins);
0464  C091     MOVFF ptr_to_motor_pins, POSTINC1
0466  FFE6     NOP
0468  C092     MOVFF 0x92, POSTINC1
046A  FFE6     NOP
046C  ECF0     CALL 0xFE0, 0
046E  F007     NOP
0470  52E5     MOVF POSTDEC1, F, ACCESS
0472  52E5     MOVF POSTDEC1, F, ACCESS
492:           							is_motor_failure = TRUE;
0474  0100     MOVLB 0x0
0476  0E01     MOVLW 0x1
0478  6F93     MOVWF 0x93, BANKED
493:           							break;
047A  D0D7     BRA 0x62A
494:           						}
495:           					}
496:           				}
497:           				//если отсчёт максимального времени работы двигателя окончен, а стартовый концевик не сработал
498:           				if(time_M_Motor.time_work_motor++ == (M_Mngm_Get_parameters_buffer()->menu_parameters.Motor[index].max_time_work)*1000U)
047C  0100     MOVLB 0x0
047E  C07D     MOVFF 0x7D, __tmp_0
0480  F032     NOP
0482  C07E     MOVFF 0x7E, 0x33
0484  F033     NOP
0486  2B7D     INCF 0x7D, F, BANKED
0488  0E00     MOVLW 0x0
048A  237E     ADDWFC 0x7E, F, BANKED
048C  C032     MOVFF __tmp_0, POSTINC1
048E  FFE6     NOP
0490  C033     MOVFF 0x33, POSTINC1
0492  FFE6     NOP
0494  EC8E     CALL 0x151C, 0
0496  F00A     NOP
0498  52E5     MOVF POSTDEC1, F, ACCESS
049A  CFE7     MOVFF INDF1, 0x33
049C  F033     NOP
049E  52E5     MOVF POSTDEC1, F, ACCESS
04A0  CFE7     MOVFF INDF1, __tmp_0
04A2  F032     NOP
04A4  CFF3     MOVFF PROD, FSR0
04A6  FFE9     NOP
04A8  CFF4     MOVFF PRODH, FSR0H
04AA  FFEA     NOP
04AC  CFE9     MOVFF FSR0, 0x36
04AE  F036     NOP
04B0  CFEA     MOVFF FSR0H, 0x37
04B2  F037     NOP
04B4  0EFE     MOVLW 0xFE
04B6  50DB     MOVF PLUSW2, W, ACCESS
04B8  0D04     MULLW 0x4
04BA  5036     MOVF 0x36, W, ACCESS
04BC  24F3     ADDWF PROD, W, ACCESS
04BE  6EE9     MOVWF FSR0, ACCESS
04C0  5037     MOVF 0x37, W, ACCESS
04C2  20F4     ADDWFC PRODH, W, ACCESS
04C4  6EEA     MOVWF FSR0H, ACCESS
04C6  52EE     MOVF POSTINC0, F, ACCESS
04C8  50EF     MOVF INDF0, W, ACCESS
04CA  6E34     MOVWF 0x34, ACCESS
04CC  6A35     CLRF 0x35, ACCESS
04CE  0EE8     MOVLW 0xE8
04D0  0235     MULWF 0x35, ACCESS
04D2  CFF3     MOVFF PROD, 0x35
04D4  F035     NOP
04D6  0E03     MOVLW 0x3
04D8  0234     MULWF 0x34, ACCESS
04DA  50F3     MOVF PROD, W, ACCESS
04DC  2635     ADDWF 0x35, F, ACCESS
04DE  0EE8     MOVLW 0xE8
04E0  0234     MULWF 0x34, ACCESS
04E2  CFF3     MOVFF PROD, 0x34
04E4  F034     NOP
04E6  50F4     MOVF PRODH, W, ACCESS
04E8  2635     ADDWF 0x35, F, ACCESS
04EA  5034     MOVF 0x34, W, ACCESS
04EC  1832     XORWF __tmp_0, W, ACCESS
04EE  E102     BNZ 0x4F4
04F0  5035     MOVF 0x35, W, ACCESS
04F2  1833     XORWF 0x33, W, ACCESS
04F4  E114     BNZ 0x51E
499:           				{
500:           					cnt_step++;
04F6  0100     MOVLB 0x0
04F8  2B69     INCF cnt_step, F, BANKED
501:           					Intr_set_is_impulse_agitator_sensor(FALSE);
04FA  6AE6     CLRF POSTINC1, ACCESS
04FC  EC50     CALL 0x44A0, 0
04FE  F022     NOP
0500  52E5     MOVF POSTDEC1, F, ACCESS
502:           					time_M_Motor.time_ls_agitator_survey = 0;
0502  0100     MOVLB 0x0
0504  6B87     CLRF 0x87, BANKED
0506  6B88     CLRF 0x88, BANKED
503:           					M_Motor_is_stopped(ptr_to_motor_pins);
0508  C091     MOVFF ptr_to_motor_pins, POSTINC1
050A  FFE6     NOP
050C  C092     MOVFF 0x92, POSTINC1
050E  FFE6     NOP
0510  ECF0     CALL 0xFE0, 0
0512  F007     NOP
0514  52E5     MOVF POSTDEC1, F, ACCESS
0516  52E5     MOVF POSTDEC1, F, ACCESS
504:           					time_M_Motor.time_work_motor = 0;
0518  0100     MOVLB 0x0
051A  6B7D     CLRF 0x7D, BANKED
051C  6B7E     CLRF 0x7E, BANKED
505:           				}
506:           				break;
051E  D085     BRA 0x62A
507:           			case STOPPING_MOTOR:		//останов двигателя
508:           				M_Motor_is_stopped(&motor_pins_brake_high_sw[index]);
0520  0EFE     MOVLW 0xFE
0522  50DB     MOVF PLUSW2, W, ACCESS
0524  0D06     MULLW 0x6
0526  CFF3     MOVFF PROD, __tmp_0
0528  F032     NOP
052A  CFF4     MOVFF PRODH, 0x33
052C  F033     NOP
052E  0E0E     MOVLW 0xE
0530  2632     ADDWF __tmp_0, F, ACCESS
0532  0E4C     MOVLW 0x4C
0534  2233     ADDWFC 0x33, F, ACCESS
0536  C032     MOVFF __tmp_0, POSTINC1
0538  FFE6     NOP
053A  C033     MOVFF 0x33, POSTINC1
053C  FFE6     NOP
053E  ECF0     CALL 0xFE0, 0
0540  F007     NOP
0542  52E5     MOVF POSTDEC1, F, ACCESS
0544  52E5     MOVF POSTDEC1, F, ACCESS
509:           				cnt_step++;
0546  0100     MOVLB 0x0
0548  2B69     INCF cnt_step, F, BANKED
510:           				break;
054A  D06F     BRA 0x62A
511:           			case BRAKING_MOTOR:		//торможение двигателя (включение верхних ключей в обоимх полумостах)
512:           				if(M_Motor_is_brake(&motor_pins_brake_high_sw[index], type_of_ls, index))
054C  0EFE     MOVLW 0xFE
054E  CFDB     MOVFF PLUSW2, POSTINC1
0550  FFE6     NOP
0552  0EFC     MOVLW 0xFC
0554  CFDB     MOVFF PLUSW2, POSTINC1
0556  FFE6     NOP
0558  0EFE     MOVLW 0xFE
055A  50DB     MOVF PLUSW2, W, ACCESS
055C  0D06     MULLW 0x6
055E  CFF3     MOVFF PROD, __tmp_0
0560  F032     NOP
0562  CFF4     MOVFF PRODH, 0x33
0564  F033     NOP
0566  0E0E     MOVLW 0xE
0568  2632     ADDWF __tmp_0, F, ACCESS
056A  0E4C     MOVLW 0x4C
056C  2233     ADDWFC 0x33, F, ACCESS
056E  C032     MOVFF __tmp_0, POSTINC1
0570  FFE6     NOP
0572  C033     MOVFF 0x33, POSTINC1
0574  FFE6     NOP
0576  EC63     CALL 0xEC6, 0
0578  F007     NOP
057A  52E5     MOVF POSTDEC1, F, ACCESS
057C  52E5     MOVF POSTDEC1, F, ACCESS
057E  52E5     MOVF POSTDEC1, F, ACCESS
0580  52E5     MOVF POSTDEC1, F, ACCESS
0582  0900     IORLW 0x0
0584  E051     BZ 0x628
513:           				{
514:           					M_Motor_is_stopped(&motor_pins_brake_high_sw[index]);
0586  0EFE     MOVLW 0xFE
0588  50DB     MOVF PLUSW2, W, ACCESS
058A  0D06     MULLW 0x6
058C  CFF3     MOVFF PROD, __tmp_0
058E  F032     NOP
0590  CFF4     MOVFF PRODH, 0x33
0592  F033     NOP
0594  0E0E     MOVLW 0xE
0596  2632     ADDWF __tmp_0, F, ACCESS
0598  0E4C     MOVLW 0x4C
059A  2233     ADDWFC 0x33, F, ACCESS
059C  C032     MOVFF __tmp_0, POSTINC1
059E  FFE6     NOP
05A0  C033     MOVFF 0x33, POSTINC1
05A2  FFE6     NOP
05A4  ECF0     CALL 0xFE0, 0
05A6  F007     NOP
05A8  52E5     MOVF POSTDEC1, F, ACCESS
05AA  52E5     MOVF POSTDEC1, F, ACCESS
515:           					cnt_step = ACCELERATION_MOTOR;  
05AC  0100     MOVLB 0x0
05AE  6B69     CLRF cnt_step, BANKED
516:           					if((limit_switch && type_of_ls != AGITATOR_LS) || (type_of_ls == AGITATOR_LS && !is_motor_failure))
05B0  0EFD     MOVLW 0xFD
05B2  50DB     MOVF PLUSW2, W, ACCESS
05B4  E004     BZ 0x5BE
05B6  0EFC     MOVLW 0xFC
05B8  50DB     MOVF PLUSW2, W, ACCESS
05BA  0804     SUBLW 0x4
05BC  E107     BNZ 0x5CC
05BE  0EFC     MOVLW 0xFC
05C0  50DB     MOVF PLUSW2, W, ACCESS
05C2  0804     SUBLW 0x4
05C4  E105     BNZ 0x5D0
05C6  0100     MOVLB 0x0
05C8  5193     MOVF 0x93, W, BANKED
05CA  E102     BNZ 0x5D0
517:           						pos_motor =  MOTOR_IN_START_OR_END_POSITION;
05CC  0E01     MOVLW 0x1
05CE  6EDF     MOVWF INDF2, ACCESS
518:           					if((!limit_switch && type_of_ls != AGITATOR_LS) ||  (type_of_ls == AGITATOR_LS && is_motor_failure))
05D0  0EFD     MOVLW 0xFD
05D2  50DB     MOVF PLUSW2, W, ACCESS
05D4  E104     BNZ 0x5DE
05D6  0EFC     MOVLW 0xFC
05D8  50DB     MOVF PLUSW2, W, ACCESS
05DA  0804     SUBLW 0x4
05DC  E107     BNZ 0x5EC
05DE  0EFC     MOVLW 0xFC
05E0  50DB     MOVF PLUSW2, W, ACCESS
05E2  0804     SUBLW 0x4
05E4  E121     BNZ 0x628
05E6  0100     MOVLB 0x0
05E8  5193     MOVF 0x93, W, BANKED
05EA  E01E     BZ 0x628
519:           					{
520:           						is_motor_failure = FALSE;
05EC  0100     MOVLB 0x0
05EE  6B93     CLRF 0x93, BANKED
521:           						pos_motor =  MOTOR_IN_FAILURE;
05F0  0E02     MOVLW 0x2
05F2  6EDF     MOVWF INDF2, ACCESS
522:           						M_Motor_failure_motor[index].is_failure = ON; //сформировать код аварии
05F4  0EFE     MOVLW 0xFE
05F6  6AEA     CLRF FSR0H, ACCESS
05F8  34DB     RLCF PLUSW2, W, ACCESS
05FA  0BFE     ANDLW 0xFE
05FC  36EA     RLCF FSR0H, F, ACCESS
05FE  6EE9     MOVWF FSR0, ACCESS
0600  0E89     MOVLW 0x89
0602  26E9     ADDWF FSR0, F, ACCESS
0604  0E00     MOVLW 0x0
0606  22EA     ADDWFC FSR0H, F, ACCESS
0608  0E01     MOVLW 0x1
060A  6EEF     MOVWF INDF0, ACCESS
523:           						M_Motor_failure_motor[index].type_ls = type_of_ls;
060C  0EFE     MOVLW 0xFE
060E  6AEA     CLRF FSR0H, ACCESS
0610  34DB     RLCF PLUSW2, W, ACCESS
0612  0BFE     ANDLW 0xFE
0614  36EA     RLCF FSR0H, F, ACCESS
0616  6EE9     MOVWF FSR0, ACCESS
0618  0E89     MOVLW 0x89
061A  26E9     ADDWF FSR0, F, ACCESS
061C  0E00     MOVLW 0x0
061E  22EA     ADDWFC FSR0H, F, ACCESS
0620  52EE     MOVF POSTINC0, F, ACCESS
0622  0EFC     MOVLW 0xFC
0624  CFDB     MOVFF PLUSW2, INDF0
0626  FFEF     NOP
524:           					}
525:           				}
526:           				break;
0628  D000     BRA 0x62A
527:           		}
528:           	}
529:           	return pos_motor;
062A  50DF     MOVF INDF2, W, ACCESS
062C  D000     BRA 0x62E
530:           }
062E  52E5     MOVF POSTDEC1, F, ACCESS
0630  52E5     MOVF POSTDEC1, F, ACCESS
0632  CFE7     MOVFF INDF1, FSR2
0634  FFD9     NOP
0636  0012     RETURN 0
531:           
532:           
533:           const rom  IOport_motor* M_Motor_get_ptr_to_motor_pins(void)
534:           {
535:           	return ptr_to_motor_pins;
0638  C091     MOVFF ptr_to_motor_pins, PROD
063A  FFF3     NOP
063C  C092     MOVFF 0x92, PRODH
063E  FFF4     NOP
0640  D000     BRA 0x642
536:           }
0642  0012     RETURN 0
537:           
538:           
539:           static uint8_t M_Motor_check_motor(uint8_t index, BOOL limit_switch, uint8_t type_of_ls, uint8_t* cnt_fail)
0644  CFD9     MOVFF FSR2, POSTINC1
0646  FFE6     NOP
0648  CFE1     MOVFF FSR1, FSR2
064A  FFD9     NOP
540:           {
541:           	if(M_Motor_rotate(index, limit_switch, type_of_ls) != MOTOR_CHECKING)
064C  0EFC     MOVLW 0xFC
064E  CFDB     MOVFF PLUSW2, POSTINC1
0650  FFE6     NOP
0652  0EFD     MOVLW 0xFD
0654  CFDB     MOVFF PLUSW2, POSTINC1
0656  FFE6     NOP
0658  0EFE     MOVLW 0xFE
065A  CFDB     MOVFF PLUSW2, POSTINC1
065C  FFE6     NOP
065E  DE51     RCALL M_Motor_rotate
0660  52E5     MOVF POSTDEC1, F, ACCESS
0662  52E5     MOVF POSTDEC1, F, ACCESS
0664  52E5     MOVF POSTDEC1, F, ACCESS
0666  0900     IORLW 0x0
0668  E05C     BZ 0x722
542:           	{ 
543:           		if(M_Motor_failure_motor[index].is_failure)  //если есть признак аварии
066A  0EFE     MOVLW 0xFE
066C  6AEA     CLRF FSR0H, ACCESS
066E  34DB     RLCF PLUSW2, W, ACCESS
0670  0BFE     ANDLW 0xFE
0672  36EA     RLCF FSR0H, F, ACCESS
0674  6EE9     MOVWF FSR0, ACCESS
0676  0E89     MOVLW 0x89
0678  26E9     ADDWF FSR0, F, ACCESS
067A  0E00     MOVLW 0x0
067C  22EA     ADDWFC FSR0H, F, ACCESS
067E  50EF     MOVF INDF0, W, ACCESS
0680  E046     BZ 0x70E
544:           		{
545:           			if((*cnt_fail) == M_Mngm_Get_parameters_buffer()->menu_parameters.Motor[index].quantity_repeat_try)
0682  0EFA     MOVLW 0xFA
0684  CFDB     MOVFF PLUSW2, FSR0
0686  FFE9     NOP
0688  0EFB     MOVLW 0xFB
068A  CFDB     MOVFF PLUSW2, FSR0H
068C  FFEA     NOP
068E  CFEF     MOVFF INDF0, __tmp_0
0690  F032     NOP
0692  C032     MOVFF __tmp_0, POSTINC1
0694  FFE6     NOP
0696  EC8E     CALL 0x151C, 0
0698  F00A     NOP
069A  52E5     MOVF POSTDEC1, F, ACCESS
069C  CFE7     MOVFF INDF1, __tmp_0
069E  F032     NOP
06A0  CFF3     MOVFF PROD, FSR0
06A2  FFE9     NOP
06A4  CFF4     MOVFF PRODH, FSR0H
06A6  FFEA     NOP
06A8  CFE9     MOVFF FSR0, 0x33
06AA  F033     NOP
06AC  CFEA     MOVFF FSR0H, 0x34
06AE  F034     NOP
06B0  0EFE     MOVLW 0xFE
06B2  50DB     MOVF PLUSW2, W, ACCESS
06B4  0D04     MULLW 0x4
06B6  5033     MOVF 0x33, W, ACCESS
06B8  24F3     ADDWF PROD, W, ACCESS
06BA  6EE9     MOVWF FSR0, ACCESS
06BC  5034     MOVF 0x34, W, ACCESS
06BE  20F4     ADDWFC PRODH, W, ACCESS
06C0  6EEA     MOVWF FSR0H, ACCESS
06C2  0E03     MOVLW 0x3
06C4  26E9     ADDWF FSR0, F, ACCESS
06C6  0E00     MOVLW 0x0
06C8  22EA     ADDWFC FSR0H, F, ACCESS
06CA  50EF     MOVF INDF0, W, ACCESS
06CC  5C32     SUBWF __tmp_0, W, ACCESS
06CE  E10A     BNZ 0x6E4
546:           			{		
547:           				*cnt_fail = 0;
06D0  0EFA     MOVLW 0xFA
06D2  CFDB     MOVFF PLUSW2, FSR0
06D4  FFE9     NOP
06D6  0EFB     MOVLW 0xFB
06D8  CFDB     MOVFF PLUSW2, FSR0H
06DA  FFEA     NOP
06DC  6AEF     CLRF INDF0, ACCESS
548:           				return FAILURE;
06DE  0E03     MOVLW 0x3
06E0  D022     BRA 0x726
549:           			}
550:           			else
06E2  D014     BRA 0x70C
551:           			{
552:           				(*cnt_fail)++;
06E4  0EFA     MOVLW 0xFA
06E6  CFDB     MOVFF PLUSW2, FSR0
06E8  FFE9     NOP
06EA  0EFB     MOVLW 0xFB
06EC  CFDB     MOVFF PLUSW2, FSR0H
06EE  FFEA     NOP
06F0  2AEF     INCF INDF0, F, ACCESS
553:           				M_Motor_failure_motor[index].is_failure = 0;		/*вставка на этапе отладки */
06F2  0EFE     MOVLW 0xFE
06F4  6AEA     CLRF FSR0H, ACCESS
06F6  34DB     RLCF PLUSW2, W, ACCESS
06F8  0BFE     ANDLW 0xFE
06FA  36EA     RLCF FSR0H, F, ACCESS
06FC  6EE9     MOVWF FSR0, ACCESS
06FE  0E89     MOVLW 0x89
0700  26E9     ADDWF FSR0, F, ACCESS
0702  0E00     MOVLW 0x0
0704  22EA     ADDWFC FSR0H, F, ACCESS
0706  6AEF     CLRF INDF0, ACCESS
554:           				return NEED_REVERSE;
0708  0E02     MOVLW 0x2
070A  D00D     BRA 0x726
555:           			}
556:           		}
557:           		else
070C  D009     BRA 0x720
558:           		{	
559:           			*cnt_fail = 0;
070E  0EFA     MOVLW 0xFA
0710  CFDB     MOVFF PLUSW2, FSR0
0712  FFE9     NOP
0714  0EFB     MOVLW 0xFB
0716  CFDB     MOVFF PLUSW2, FSR0H
0718  FFEA     NOP
071A  6AEF     CLRF INDF0, ACCESS
560:           			return NEED_NEXT_STEP;
071C  0E01     MOVLW 0x1
071E  D003     BRA 0x726
561:           		}
562:           	}
563:           	else
0720  D002     BRA 0x726
564:           	{
565:           		return IS_BUSY;
0722  0E00     MOVLW 0x0
0724  D000     BRA 0x726
566:           	}
567:           }
0726  52E5     MOVF POSTDEC1, F, ACCESS
0728  CFE7     MOVFF INDF1, FSR2
072A  FFD9     NOP
072C  0012     RETURN 0
568:           
569:           /* Реализация автомата состояний модуля двигателей  */
570:           void M_Motor_Run(void)
571:           {
572:           	static uint8_t cnt_failure_forward = 0;
573:           	static uint8_t cnt_failure_backward = 0;
574:           	static BOOL after_pause = OFF;
575:           	static BOOL shatter_reverse = OFF;
576:           	static uint8_t ls_type;
577:           		
578:           	if(M_Ind_Get_state() == STATE_IND_INIT)
072E  ECA3     CALL 0x2B46, 0
0730  F015     NOP
0732  0900     IORLW 0x0
0734  E101     BNZ 0x738
579:           	{
580:           		return;
0736  D36A     BRA 0xE0C
581:           	}
582:           	
583:           	switch(M_Motor_state)
0738  0100     MOVLB 0x0
073A  5164     MOVF M_Motor_state, W, BANKED
073C  0A03     XORLW 0x3
073E  E101     BNZ 0x742
0740  D168     BRA 0xA12
0742  0A06     XORLW 0x6
0744  E101     BNZ 0x748
0746  D0DC     BRA 0x900
0748  0A01     XORLW 0x1
074A  E101     BNZ 0x74E
074C  D097     BRA 0x87C
074E  0A05     XORLW 0x5
0750  E064     BZ 0x81A
0752  0A03     XORLW 0x3
0754  E05F     BZ 0x814
0756  0A02     XORLW 0x2
0758  E001     BZ 0x75C
075A  D358     BRA 0xE0C
584:           	{
585:           		//проверка начального положения двигателей (дозатора и заслонки)
586:           		//Заслонка проверяется только после окончания проверки дозатора
587:           		//Далее переход либо в состояние ожидания, либо в состояние аварии модуля
588:           		case CHECK_START_POSITION: 				
589:           			M_Motor_prev_state = M_Motor_state;
075C  C064     MOVFF M_Motor_state, M_Motor_prev_state
075E  F07A     NOP
590:           			switch(num_motor)
0760  0100     MOVLB 0x0
0762  5167     MOVF num_motor, W, BANKED
0764  0A02     XORLW 0x2
0766  E02D     BZ 0x7C2
0768  0A02     XORLW 0x2
076A  E001     BZ 0x76E
076C  D052     BRA 0x812
591:           			{
592:           				case INDEX_OF_DISPENSER:
593:           					ptr_to_motor_pins = &motor_pins_backward[INDEX_OF_DISPENSER];
076E  0100     MOVLB 0x0
0770  0EF6     MOVLW 0xF6
0772  6F91     MOVWF ptr_to_motor_pins, BANKED
0774  0E4B     MOVLW 0x4B
0776  6F92     MOVWF 0x92, BANKED
594:           					if (M_Motor_rotate(INDEX_OF_DISPENSER, M_LI_Get_Limit_Switches()->ls_dispenser_start_state, 
077C  ECBD     CALL 0x3B7A, 0
077E  F01D     NOP
0780  CFF3     MOVFF PROD, FSR0
0782  FFE9     NOP
0784  CFF4     MOVFF PRODH, FSR0H
0786  FFEA     NOP
0788  50EF     MOVF INDF0, W, ACCESS
078A  6EE6     MOVWF POSTINC1, ACCESS
078C  6AE6     CLRF POSTINC1, ACCESS
595:           					START_LS) != MOTOR_CHECKING)
0778  0E01     MOVLW 0x1
077A  6EE6     MOVWF POSTINC1, ACCESS
078E  DDB9     RCALL M_Motor_rotate
0790  52E5     MOVF POSTDEC1, F, ACCESS
0792  52E5     MOVF POSTDEC1, F, ACCESS
0794  52E5     MOVF POSTDEC1, F, ACCESS
0796  0900     IORLW 0x0
0798  E013     BZ 0x7C0
596:           					{
597:           						if(M_Motor_failure_motor[INDEX_OF_DISPENSER].is_failure)
079A  0100     MOVLB 0x0
079C  5189     MOVF M_Motor_failure_motor, W, BANKED
079E  E006     BZ 0x7AC
598:           						{
599:           							cnt_step = 0;
07A0  0100     MOVLB 0x0
07A2  6B69     CLRF cnt_step, BANKED
600:           							M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
07A4  0100     MOVLB 0x0
07A6  0E02     MOVLW 0x2
07A8  6F64     MOVWF M_Motor_state, BANKED
601:           						}
602:           						else
07AA  D00A     BRA 0x7C0
603:           						{
604:           							cnt_step = 0;
07AC  0100     MOVLB 0x0
07AE  6B69     CLRF cnt_step, BANKED
605:           							num_motor = INDEX_OF_SHATTER;
07B0  0100     MOVLB 0x0
07B2  0E02     MOVLW 0x2
07B4  6F67     MOVWF num_motor, BANKED
606:           							ptr_to_motor_pins = &motor_pins_backward[INDEX_OF_SHATTER];
07B6  0100     MOVLB 0x0
07B8  0E02     MOVLW 0x2
07BA  6F91     MOVWF ptr_to_motor_pins, BANKED
07BC  0E4C     MOVLW 0x4C
07BE  6F92     MOVWF 0x92, BANKED
607:           						}
608:           					}
609:           				break;	
07C0  D028     BRA 0x812
610:           				case INDEX_OF_SHATTER:		
611:           					if(M_Motor_rotate(INDEX_OF_SHATTER, M_LI_Get_Limit_Switches()->ls_shatter_start_state,
07C6  ECBD     CALL 0x3B7A, 0
07C8  F01D     NOP
07CA  CFF3     MOVFF PROD, FSR0
07CC  FFE9     NOP
07CE  CFF4     MOVFF PRODH, FSR0H
07D0  FFEA     NOP
07D2  0E02     MOVLW 0x2
07D4  26E9     ADDWF FSR0, F, ACCESS
07D6  0E00     MOVLW 0x0
07D8  22EA     ADDWFC FSR0H, F, ACCESS
07DA  50EF     MOVF INDF0, W, ACCESS
07DC  6EE6     MOVWF POSTINC1, ACCESS
07DE  0E02     MOVLW 0x2
07E0  6EE6     MOVWF POSTINC1, ACCESS
612:           					START_LS) != MOTOR_CHECKING)
07C2  0E01     MOVLW 0x1
07C4  6EE6     MOVWF POSTINC1, ACCESS
07E2  DD8F     RCALL M_Motor_rotate
07E4  52E5     MOVF POSTDEC1, F, ACCESS
07E6  52E5     MOVF POSTDEC1, F, ACCESS
07E8  52E5     MOVF POSTDEC1, F, ACCESS
07EA  0900     IORLW 0x0
07EC  E011     BZ 0x810
613:           					{
614:           						if(M_Motor_failure_motor[INDEX_OF_SHATTER].is_failure)
07EE  0100     MOVLB 0x0
07F0  518D     MOVF 0x8D, W, BANKED
07F2  E006     BZ 0x800
615:           						{
616:           							cnt_step = 0;
07F4  0100     MOVLB 0x0
07F6  6B69     CLRF cnt_step, BANKED
617:           							M_Motor_state = STATE_MODULE_MOTOR_FAILURE;		
07F8  0100     MOVLB 0x0
07FA  0E02     MOVLW 0x2
07FC  6F64     MOVWF M_Motor_state, BANKED
618:           						}
619:           						else 
07FE  D008     BRA 0x810
620:           						{
621:           							cnt_step = 0;
0800  0100     MOVLB 0x0
0802  6B69     CLRF cnt_step, BANKED
622:           							M_Motor_state = STATE_MODULE_MOTOR_WAITING;
0804  0100     MOVLB 0x0
0806  0E01     MOVLW 0x1
0808  6F64     MOVWF M_Motor_state, BANKED
623:           							num_motor = INDEX_OF_AGITATOR;
080A  0100     MOVLB 0x0
080C  0E01     MOVLW 0x1
080E  6F67     MOVWF num_motor, BANKED
624:           						}
625:           					}
626:           				break;
0810  D000     BRA 0x812
627:           			}
628:           			break;
0812  D2FC     BRA 0xE0C
629:           		
630:           		case STATE_MODULE_MOTOR_FAILURE:	//режим "Авария"
631:           			ctrl = OFF;
0814  0100     MOVLB 0x0
0816  6B65     CLRF ctrl, BANKED
632:           
633:           			break;
0818  D2F9     BRA 0xE0C
634:           		case STATE_MODULE_MOTOR_WAITING:	//режим ожидания команды вращения мотора
635:           			//ctrl = TRUE; //!!!!!!для отладки
636:           			M_Motor_prev_state = M_Motor_state;
081A  C064     MOVFF M_Motor_state, M_Motor_prev_state
081C  F07A     NOP
637:           			if(ctrl)
081E  0100     MOVLB 0x0
0820  5165     MOVF ctrl, W, BANKED
0822  E00F     BZ 0x842
638:           			{
639:           				cnt_step = 0;
0824  0100     MOVLB 0x0
0826  6B69     CLRF cnt_step, BANKED
640:           				M_Motor_state = STATE_MODULE_MOTOR_WORKING;
0828  0100     MOVLB 0x0
082A  0E03     MOVLW 0x3
082C  6F64     MOVWF M_Motor_state, BANKED
641:           				M_Ind_Set_state(STATE_VIEW_SUPPLY_FUEL);
082E  0E07     MOVLW 0x7
0830  6EE6     MOVWF POSTINC1, ACCESS
0832  EC98     CALL 0x2B30, 0
0834  F015     NOP
0836  52E5     MOVF POSTDEC1, F, ACCESS
642:           				M_Ind_Set_blink_mode(NEED_BLINK);
0838  0E01     MOVLW 0x1
083A  6EE6     MOVWF POSTINC1, ACCESS
083C  EC7E     CALL 0x2AFC, 0
083E  F015     NOP
0840  52E5     MOVF POSTDEC1, F, ACCESS
643:           			}
644:           				M_motor_forming_direction_question_LS(QUESTION_LS_FALSE_OFF, QUESTION_LS_FALSE_ON, QUESTION_LS_FALSE_OFF, QUESTION_LS_FALSE_ON, QUESTION_LS_FALSE_ON);
0842  6AE6     CLRF POSTINC1, ACCESS
0844  6AE6     CLRF POSTINC1, ACCESS
0846  0E01     MOVLW 0x1
0848  6EE6     MOVWF POSTINC1, ACCESS
084A  6AE6     CLRF POSTINC1, ACCESS
084C  0E01     MOVLW 0x1
084E  6EE6     MOVWF POSTINC1, ACCESS
0850  DC86     RCALL M_motor_forming_direction_question_LS
0852  6E32     MOVWF __tmp_0, ACCESS
0854  0E05     MOVLW 0x5
0856  5EE1     SUBWF FSR1, F, ACCESS
0858  5032     MOVF __tmp_0, W, ACCESS
645:           				//#ifndef NO_CONTROL_FALSE_STATE_LS
646:           					M_Motor_check_false_LS(M_LI_Get_Limit_Switches(), QUANTITY_FALSE_LS);
085A  0E07     MOVLW 0x7
085C  6EE6     MOVWF POSTINC1, ACCESS
085E  ECBD     CALL 0x3B7A, 0
0860  F01D     NOP
0862  CFF3     MOVFF PROD, __tmp_0
0864  F032     NOP
0866  CFF4     MOVFF PRODH, 0x33
0868  F033     NOP
086A  C032     MOVFF __tmp_0, POSTINC1
086C  FFE6     NOP
086E  C033     MOVFF 0x33, POSTINC1
0870  FFE6     NOP
0872  DCA4     RCALL M_Motor_check_false_LS
0874  52E5     MOVF POSTDEC1, F, ACCESS
0876  52E5     MOVF POSTDEC1, F, ACCESS
0878  52E5     MOVF POSTDEC1, F, ACCESS
647:           				//#endif
648:           		break;
087A  D2C8     BRA 0xE0C
649:           		case STATE_MODULE_MOTOR_CLEAN_CHIMNEY:		//режим "Чистка дымохода"
650:           				M_Motor_prev_state = M_Motor_state;
087C  C064     MOVFF M_Motor_state, M_Motor_prev_state
087E  F07A     NOP
651:           				M_Ind_Set_blink_mode(NEED_BLINK);
0880  0E01     MOVLW 0x1
0882  6EE6     MOVWF POSTINC1, ACCESS
0884  EC7E     CALL 0x2AFC, 0
0886  F015     NOP
0888  52E5     MOVF POSTDEC1, F, ACCESS
652:           				if(M_Motor_check_ls_after_begin_start(*temp_start_ls, temp_index))
088A  C10A     MOVFF temp_index, POSTINC1
088C  FFE6     NOP
088E  C078     MOVFF temp_start_ls, FSR0
0890  FFE9     NOP
0892  C079     MOVFF 0x79, FSR0H
0894  FFEA     NOP
0896  50EF     MOVF INDF0, W, ACCESS
0898  6EE6     MOVWF POSTINC1, ACCESS
089A  DC1D     RCALL M_Motor_check_ls_after_begin_start
089C  52E5     MOVF POSTDEC1, F, ACCESS
089E  52E5     MOVF POSTDEC1, F, ACCESS
08A0  0900     IORLW 0x0
08A2  E007     BZ 0x8B2
653:           				{	
654:           					time_M_Motor.time_ctrl_ls_after_begin = 0;
08A4  0100     MOVLB 0x0
08A6  6B85     CLRF 0x85, BANKED
08A8  6B86     CLRF 0x86, BANKED
655:           					M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
08AA  0100     MOVLB 0x0
08AC  0E02     MOVLW 0x2
08AE  6F64     MOVWF M_Motor_state, BANKED
656:           					break;		
08B0  D2AD     BRA 0xE0C
657:           				}
658:           				if (M_Motor_rotate(INDEX_OF_SHATTER, *(M_LI_get_ptr_to_ls()), 
08B6  ECA9     CALL 0x3B52, 0
08B8  F01D     NOP
08BA  CFF3     MOVFF PROD, FSR0
08BC  FFE9     NOP
08BE  CFF4     MOVFF PRODH, FSR0H
08C0  FFEA     NOP
08C2  50EF     MOVF INDF0, W, ACCESS
08C4  6EE6     MOVWF POSTINC1, ACCESS
08C6  0E02     MOVLW 0x2
08C8  6EE6     MOVWF POSTINC1, ACCESS
659:           				ls_type) != MOTOR_CHECKING)
08B2  C10B     MOVFF 0x10B, POSTINC1
08B4  FFE6     NOP
08CA  DD1B     RCALL M_Motor_rotate
08CC  52E5     MOVF POSTDEC1, F, ACCESS
08CE  52E5     MOVF POSTDEC1, F, ACCESS
08D0  52E5     MOVF POSTDEC1, F, ACCESS
08D2  0900     IORLW 0x0
08D4  E014     BZ 0x8FE
660:           				{
661:           					time_M_Motor.time_ctrl_ls_after_begin = 0;
08D6  0100     MOVLB 0x0
08D8  6B85     CLRF 0x85, BANKED
08DA  6B86     CLRF 0x86, BANKED
662:           					if(M_Motor_failure_motor[INDEX_OF_SHATTER].is_failure)
08DC  0100     MOVLB 0x0
08DE  518D     MOVF 0x8D, W, BANKED
08E0  E004     BZ 0x8EA
663:           					{
664:           						M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
08E2  0100     MOVLB 0x0
08E4  0E02     MOVLW 0x2
08E6  6F64     MOVWF M_Motor_state, BANKED
665:           					}
666:           					else
08E8  D00A     BRA 0x8FE
667:           					{
668:           						M_Motor_state = STATE_MODULE_MOTOR_WAITING_FOR_MOVE_CLEAN_CHIMNEY;
08EA  0100     MOVLB 0x0
08EC  0E05     MOVLW 0x5
08EE  6F64     MOVWF M_Motor_state, BANKED
669:           						ctrl_shatter = WAITING_MOVEMENT;
08F0  0100     MOVLB 0x0
08F2  0E03     MOVLW 0x3
08F4  6F68     MOVWF ctrl_shatter, BANKED
670:           						M_Ind_Set_blink_mode(NO_NEED_BLINK);
08F6  6AE6     CLRF POSTINC1, ACCESS
08F8  EC7E     CALL 0x2AFC, 0
08FA  F015     NOP
08FC  52E5     MOVF POSTDEC1, F, ACCESS
671:           					}
672:           				}
673:           		break;
08FE  D286     BRA 0xE0C
674:           		case STATE_MODULE_MOTOR_WAITING_FOR_MOVE_CLEAN_CHIMNEY:		//установка параметров перед вращением двигателя заслонки в режиме "Чистка дымохода"
675:           			M_Motor_prev_state = M_Motor_state;
0900  C064     MOVFF M_Motor_state, M_Motor_prev_state
0902  F07A     NOP
676:           			if(ctrl_shatter == MOVEMENT_FORWARD) 		//подготовка к вращению мотора заслонки для её открытия
0904  0100     MOVLB 0x0
0906  0568     DECF ctrl_shatter, W, BANKED
0908  E13A     BNZ 0x97E
677:           			{
678:           				M_LI_set_ptr_to_ls(&(M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state));	
090A  ECBD     CALL 0x3B7A, 0
090C  F01D     NOP
090E  CFF3     MOVFF PROD, FSR0
0910  FFE9     NOP
0912  CFF4     MOVFF PRODH, FSR0H
0914  FFEA     NOP
0916  0E04     MOVLW 0x4
0918  26E9     ADDWF FSR0, F, ACCESS
091A  0E00     MOVLW 0x0
091C  22EA     ADDWFC FSR0H, F, ACCESS
091E  CFE9     MOVFF FSR0, __tmp_0
0920  F032     NOP
0922  CFEA     MOVFF FSR0H, 0x33
0924  F033     NOP
0926  C032     MOVFF __tmp_0, POSTINC1
0928  FFE6     NOP
092A  C033     MOVFF 0x33, POSTINC1
092C  FFE6     NOP
092E  ECAF     CALL 0x3B5E, 0
0930  F01D     NOP
0932  52E5     MOVF POSTDEC1, F, ACCESS
0934  52E5     MOVF POSTDEC1, F, ACCESS
679:           				M_Motor_state = STATE_MODULE_MOTOR_CLEAN_CHIMNEY;
0936  0100     MOVLB 0x0
0938  0E04     MOVLW 0x4
093A  6F64     MOVWF M_Motor_state, BANKED
680:           				ptr_to_motor_pins = &motor_pins_forward[INDEX_OF_SHATTER];
093C  0100     MOVLB 0x0
093E  0EEA     MOVLW 0xEA
0940  6F91     MOVWF ptr_to_motor_pins, BANKED
0942  0E4B     MOVLW 0x4B
0944  6F92     MOVWF 0x92, BANKED
681:           				ls_type = AFTER_FINISH_LS;
0946  0101     MOVLB 0x1
0948  0E03     MOVLW 0x3
094A  6F0B     MOVWF 0xB, BANKED
682:           				M_Ind_Set_blink_mode(NEED_BLINK);
094C  0E01     MOVLW 0x1
094E  6EE6     MOVWF POSTINC1, ACCESS
0950  EC7E     CALL 0x2AFC, 0
0952  F015     NOP
0954  52E5     MOVF POSTDEC1, F, ACCESS
683:           				cnt_step = 0;
0956  0100     MOVLB 0x0
0958  6B69     CLRF cnt_step, BANKED
684:           				temp_start_ls = &(M_LI_Get_Limit_Switches()->ls_shatter_start_state); 
095A  ECBD     CALL 0x3B7A, 0
095C  F01D     NOP
095E  CFF3     MOVFF PROD, FSR0
0960  FFE9     NOP
0962  CFF4     MOVFF PRODH, FSR0H
0964  FFEA     NOP
0966  0E02     MOVLW 0x2
0968  26E9     ADDWF FSR0, F, ACCESS
096A  0E00     MOVLW 0x0
096C  22EA     ADDWFC FSR0H, F, ACCESS
096E  CFE9     MOVFF FSR0, temp_start_ls
0970  F078     NOP
0972  CFEA     MOVFF FSR0H, 0x79
0974  F079     NOP
685:           				temp_index =  INDEX_FALSE_STATE_LS_START_SHATTER;
0976  0101     MOVLB 0x1
0978  0E02     MOVLW 0x2
097A  6F0A     MOVWF 0xA, BANKED
686:           			}
687:           			else if(ctrl_shatter == MOVEMENT_BACKWARD)		//подготовка к вращению мотора заслонки для её закрытия	
097C  D049     BRA 0xA10
097E  0E02     MOVLW 0x2
0980  0100     MOVLB 0x0
0982  5D68     SUBWF ctrl_shatter, W, BANKED
0984  E13A     BNZ 0x9FA
688:           			{
689:           				M_LI_set_ptr_to_ls(&(M_LI_Get_Limit_Switches()->ls_shatter_start_state));
0986  ECBD     CALL 0x3B7A, 0
0988  F01D     NOP
098A  CFF3     MOVFF PROD, FSR0
098C  FFE9     NOP
098E  CFF4     MOVFF PRODH, FSR0H
0990  FFEA     NOP
0992  0E02     MOVLW 0x2
0994  26E9     ADDWF FSR0, F, ACCESS
0996  0E00     MOVLW 0x0
0998  22EA     ADDWFC FSR0H, F, ACCESS
099A  CFE9     MOVFF FSR0, __tmp_0
099C  F032     NOP
099E  CFEA     MOVFF FSR0H, 0x33
09A0  F033     NOP
09A2  C032     MOVFF __tmp_0, POSTINC1
09A4  FFE6     NOP
09A6  C033     MOVFF 0x33, POSTINC1
09A8  FFE6     NOP
09AA  ECAF     CALL 0x3B5E, 0
09AC  F01D     NOP
09AE  52E5     MOVF POSTDEC1, F, ACCESS
09B0  52E5     MOVF POSTDEC1, F, ACCESS
690:           				M_Motor_state = STATE_MODULE_MOTOR_CLEAN_CHIMNEY;
09B2  0100     MOVLB 0x0
09B4  0E04     MOVLW 0x4
09B6  6F64     MOVWF M_Motor_state, BANKED
691:           				ptr_to_motor_pins = &motor_pins_backward[INDEX_OF_SHATTER];
09B8  0100     MOVLB 0x0
09BA  0E02     MOVLW 0x2
09BC  6F91     MOVWF ptr_to_motor_pins, BANKED
09BE  0E4C     MOVLW 0x4C
09C0  6F92     MOVWF 0x92, BANKED
692:           				ls_type = START_LS;
09C2  0101     MOVLB 0x1
09C4  0E01     MOVLW 0x1
09C6  6F0B     MOVWF 0xB, BANKED
693:           				M_Ind_Set_blink_mode(NEED_BLINK);
09C8  0E01     MOVLW 0x1
09CA  6EE6     MOVWF POSTINC1, ACCESS
09CC  EC7E     CALL 0x2AFC, 0
09CE  F015     NOP
09D0  52E5     MOVF POSTDEC1, F, ACCESS
694:           				cnt_step = 0;
09D2  0100     MOVLB 0x0
09D4  6B69     CLRF cnt_step, BANKED
695:           				temp_start_ls = &(M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state);
09D6  ECBD     CALL 0x3B7A, 0
09D8  F01D     NOP
09DA  CFF3     MOVFF PROD, FSR0
09DC  FFE9     NOP
09DE  CFF4     MOVFF PRODH, FSR0H
09E0  FFEA     NOP
09E2  0E04     MOVLW 0x4
09E4  26E9     ADDWF FSR0, F, ACCESS
09E6  0E00     MOVLW 0x0
09E8  22EA     ADDWFC FSR0H, F, ACCESS
09EA  CFE9     MOVFF FSR0, temp_start_ls
09EC  F078     NOP
09EE  CFEA     MOVFF FSR0H, 0x79
09F0  F079     NOP
696:           				temp_index = INDEX_FALSE_STATE_LS_AFTER_FINISH_SHATTER;
09F2  0101     MOVLB 0x1
09F4  0E04     MOVLW 0x4
09F6  6F0A     MOVWF 0xA, BANKED
697:           			}
698:           			else if(ctrl_shatter == NO_MOVEMENT)
09F8  D00B     BRA 0xA10
09FA  0100     MOVLB 0x0
09FC  5168     MOVF ctrl_shatter, W, BANKED
09FE  E104     BNZ 0xA08
699:           			{
700:           				M_Motor_state = STATE_MODULE_MOTOR_WAITING;
0A00  0100     MOVLB 0x0
0A02  0E01     MOVLW 0x1
0A04  6F64     MOVWF M_Motor_state, BANKED
701:           			}
702:           			else if(ctrl_shatter == WAITING_MOVEMENT)
0A06  D004     BRA 0xA10
0A08  0E03     MOVLW 0x3
0A0A  0100     MOVLB 0x0
0A0C  5D68     SUBWF ctrl_shatter, W, BANKED
0A0E  E100     BNZ 0xA10
703:           			{
704:           			
705:           			}
706:           		break;
0A10  D1FD     BRA 0xE0C
707:           		
708:           		case STATE_MODULE_MOTOR_WORKING:	//алгоритм засыпки топлива из бункера в котёл
709:           			M_Motor_prev_state = M_Motor_state;
0A12  C064     MOVFF M_Motor_state, M_Motor_prev_state
0A14  F07A     NOP
710:           			switch(num_motor)
0A16  0100     MOVLB 0x0
0A18  5167     MOVF num_motor, W, BANKED
0A1A  0A02     XORLW 0x2
0A1C  E101     BNZ 0xA20
0A1E  D110     BRA 0xC40
0A20  0A02     XORLW 0x2
0A22  E039     BZ 0xA96
0A24  0A01     XORLW 0x1
0A26  E001     BZ 0xA2A
0A28  D1F0     BRA 0xE0A
711:           			{
712:           				case INDEX_OF_AGITATOR:		//вращение ворошителя
713:           						//LED_FAN_PIN = ON;
714:           						ptr_to_motor_pins = &motor_pins_forward[INDEX_OF_AGITATOR];
0A2A  0100     MOVLB 0x0
0A2C  0EE4     MOVLW 0xE4
0A2E  6F91     MOVWF ptr_to_motor_pins, BANKED
0A30  0E4B     MOVLW 0x4B
0A32  6F92     MOVWF 0x92, BANKED
715:           						switch(M_Motor_check_motor(INDEX_OF_AGITATOR, M_LI_Get_Limit_Switches()->ls_agitator_state, AGITATOR_LS,
0A3C  0E04     MOVLW 0x4
0A3E  6EE6     MOVWF POSTINC1, ACCESS
0A40  ECBD     CALL 0x3B7A, 0
0A42  F01D     NOP
0A44  CFF3     MOVFF PROD, FSR0
0A46  FFE9     NOP
0A48  CFF4     MOVFF PRODH, FSR0H
0A4A  FFEA     NOP
0A4C  0E05     MOVLW 0x5
0A4E  26E9     ADDWF FSR0, F, ACCESS
0A50  0E00     MOVLW 0x0
0A52  22EA     ADDWFC FSR0H, F, ACCESS
0A54  50EF     MOVF INDF0, W, ACCESS
0A56  6EE6     MOVWF POSTINC1, ACCESS
0A58  0E01     MOVLW 0x1
0A5A  6EE6     MOVWF POSTINC1, ACCESS
0A66  0A00     XORLW 0x0
0A68  E014     BZ 0xA92
0A6A  0A01     XORLW 0x1
0A6C  E009     BZ 0xA80
0A6E  0A02     XORLW 0x2
0A70  E001     BZ 0xA74
0A72  D010     BRA 0xA94
716:           						&cnt_failure_forward))
0A34  0E94     MOVLW 0x94
0A36  6EE6     MOVWF POSTINC1, ACCESS
0A38  0E00     MOVLW 0x0
0A3A  6EE6     MOVWF POSTINC1, ACCESS
0A5C  DDF3     RCALL M_Motor_check_motor
0A5E  6E32     MOVWF __tmp_0, ACCESS
0A60  0E05     MOVLW 0x5
0A62  5EE1     SUBWF FSR1, F, ACCESS
0A64  5032     MOVF __tmp_0, W, ACCESS
717:           						{
718:           							case FAILURE:
719:           								M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
0A74  0100     MOVLB 0x0
0A76  0E02     MOVLW 0x2
0A78  6F64     MOVWF M_Motor_state, BANKED
720:           								cnt_step = 0;
0A7A  0100     MOVLB 0x0
0A7C  6B69     CLRF cnt_step, BANKED
721:           							break;
0A7E  D00A     BRA 0xA94
722:           							case NEED_NEXT_STEP:
723:           								cnt_step = 0;
0A80  0100     MOVLB 0x0
0A82  6B69     CLRF cnt_step, BANKED
724:           								num_motor = INDEX_OF_SHATTER; 
0A84  0100     MOVLB 0x0
0A86  0E02     MOVLW 0x2
0A88  6F67     MOVWF num_motor, BANKED
725:           								direction = TO_FORWARD_SHATTER;
0A8A  0100     MOVLB 0x0
0A8C  0E04     MOVLW 0x4
0A8E  6F66     MOVWF direction, BANKED
726:           								//LED_FAN_PIN = OFF;
727:           								break;
0A90  D001     BRA 0xA94
728:           							case IS_BUSY:
729:           							
730:           							break;
0A92  D000     BRA 0xA94
731:           						}
732:           					break;
0A94  D1BA     BRA 0xE0A
733:           				case INDEX_OF_DISPENSER:	//вращение дозатора
734:           					switch(direction)		
0A96  0100     MOVLB 0x0
0A98  5166     MOVF direction, W, BANKED
0A9A  0A03     XORLW 0x3
0A9C  E101     BNZ 0xAA0
0A9E  D0B7     BRA 0xC0E
0AA0  0A01     XORLW 0x1
0AA2  E056     BZ 0xB50
0AA4  0A03     XORLW 0x3
0AA6  E001     BZ 0xAAA
0AA8  D0CA     BRA 0xC3E
735:           					{
736:           						case TO_FORWARD_DISPENSER:	//направление вращения "вперёд"
737:           							ptr_to_motor_pins = &motor_pins_forward[INDEX_OF_DISPENSER];
0AAA  0100     MOVLB 0x0
0AAC  0EDE     MOVLW 0xDE
0AAE  6F91     MOVWF ptr_to_motor_pins, BANKED
0AB0  0E4B     MOVLW 0x4B
0AB2  6F92     MOVWF 0x92, BANKED
738:           							if(M_Motor_check_ls_after_begin_start(M_LI_Get_Limit_Switches()->ls_dispenser_start_state, INDEX_FALSE_STATE_LS_START_DISPENSER))
0AB4  6AE6     CLRF POSTINC1, ACCESS
0AB6  ECBD     CALL 0x3B7A, 0
0AB8  F01D     NOP
0ABA  CFF3     MOVFF PROD, FSR0
0ABC  FFE9     NOP
0ABE  CFF4     MOVFF PRODH, FSR0H
0AC0  FFEA     NOP
0AC2  50EF     MOVF INDF0, W, ACCESS
0AC4  6EE6     MOVWF POSTINC1, ACCESS
0AC6  EC6B     CALL 0xD6, 0
0AC8  F000     NOP
0ACA  52E5     MOVF POSTDEC1, F, ACCESS
0ACC  52E5     MOVF POSTDEC1, F, ACCESS
0ACE  0900     IORLW 0x0
0AD0  E004     BZ 0xADA
739:           							{	
740:           								M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
0AD2  0100     MOVLB 0x0
0AD4  0E02     MOVLW 0x2
0AD6  6F64     MOVWF M_Motor_state, BANKED
741:           								break;
0AD8  D0B2     BRA 0xC3E
742:           							}
743:           							switch(M_Motor_check_motor(INDEX_OF_DISPENSER, M_LI_Get_Limit_Switches()->ls_dispenser_finish_state, FINISH_LS,
0AE2  0E02     MOVLW 0x2
0AE4  6EE6     MOVWF POSTINC1, ACCESS
0AE6  ECBD     CALL 0x3B7A, 0
0AE8  F01D     NOP
0AEA  CFF3     MOVFF PROD, FSR0
0AEC  FFE9     NOP
0AEE  CFF4     MOVFF PRODH, FSR0H
0AF0  FFEA     NOP
0AF2  52EE     MOVF POSTINC0, F, ACCESS
0AF4  50EF     MOVF INDF0, W, ACCESS
0AF6  6EE6     MOVWF POSTINC1, ACCESS
0AF8  6AE6     CLRF POSTINC1, ACCESS
0B04  0A00     XORLW 0x0
0B06  E022     BZ 0xB4C
0B08  0A02     XORLW 0x2
0B0A  E017     BZ 0xB3A
0B0C  0A03     XORLW 0x3
0B0E  E00C     BZ 0xB28
0B10  0A02     XORLW 0x2
0B12  E001     BZ 0xB16
0B14  D01C     BRA 0xB4E
744:           							&cnt_failure_forward))
0ADA  0E94     MOVLW 0x94
0ADC  6EE6     MOVWF POSTINC1, ACCESS
0ADE  0E00     MOVLW 0x0
0AE0  6EE6     MOVWF POSTINC1, ACCESS
0AFA  DDA4     RCALL M_Motor_check_motor
0AFC  6E32     MOVWF __tmp_0, ACCESS
0AFE  0E05     MOVLW 0x5
0B00  5EE1     SUBWF FSR1, F, ACCESS
0B02  5032     MOVF __tmp_0, W, ACCESS
745:           							{
746:           								case FAILURE:
747:           									cnt_step = 0;
0B16  0100     MOVLB 0x0
0B18  6B69     CLRF cnt_step, BANKED
748:           									M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
0B1A  0100     MOVLB 0x0
0B1C  0E02     MOVLW 0x2
0B1E  6F64     MOVWF M_Motor_state, BANKED
749:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0B20  0100     MOVLB 0x0
0B22  6B85     CLRF 0x85, BANKED
0B24  6B86     CLRF 0x86, BANKED
750:           								break;
0B26  D013     BRA 0xB4E
751:           								case NEED_NEXT_STEP:
752:           									cnt_step = 0;
0B28  0100     MOVLB 0x0
0B2A  6B69     CLRF cnt_step, BANKED
753:           									direction = TIME_PAUSE_DISPENSER;
0B2C  0100     MOVLB 0x0
0B2E  0E03     MOVLW 0x3
0B30  6F66     MOVWF direction, BANKED
754:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0B32  0100     MOVLB 0x0
0B34  6B85     CLRF 0x85, BANKED
0B36  6B86     CLRF 0x86, BANKED
755:           								break;
0B38  D00A     BRA 0xB4E
756:           								case NEED_REVERSE:
757:           									cnt_step = 0;
0B3A  0100     MOVLB 0x0
0B3C  6B69     CLRF cnt_step, BANKED
758:           									direction = TO_BACKWARD_DISPENSER;							
0B3E  0100     MOVLB 0x0
0B40  0E02     MOVLW 0x2
0B42  6F66     MOVWF direction, BANKED
759:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0B44  0100     MOVLB 0x0
0B46  6B85     CLRF 0x85, BANKED
0B48  6B86     CLRF 0x86, BANKED
760:           								break;
0B4A  D001     BRA 0xB4E
761:           								case IS_BUSY:
762:           								break;	
0B4C  D000     BRA 0xB4E
763:           							}
764:           							break;
0B4E  D077     BRA 0xC3E
765:           						case TO_BACKWARD_DISPENSER:		//направление вращения "назад"
766:           							ptr_to_motor_pins = &motor_pins_backward[INDEX_OF_DISPENSER];
0B50  0100     MOVLB 0x0
0B52  0EF6     MOVLW 0xF6
0B54  6F91     MOVWF ptr_to_motor_pins, BANKED
0B56  0E4B     MOVLW 0x4B
0B58  6F92     MOVWF 0x92, BANKED
767:           							if(M_Motor_check_ls_after_begin_start(M_LI_Get_Limit_Switches()->ls_dispenser_finish_state, INDEX_FALSE_STATE_LS_FINISH_DISPENSER))
0B5A  0E01     MOVLW 0x1
0B5C  6EE6     MOVWF POSTINC1, ACCESS
0B5E  ECBD     CALL 0x3B7A, 0
0B60  F01D     NOP
0B62  CFF3     MOVFF PROD, FSR0
0B64  FFE9     NOP
0B66  CFF4     MOVFF PRODH, FSR0H
0B68  FFEA     NOP
0B6A  52EE     MOVF POSTINC0, F, ACCESS
0B6C  50EF     MOVF INDF0, W, ACCESS
0B6E  6EE6     MOVWF POSTINC1, ACCESS
0B70  EC6B     CALL 0xD6, 0
0B72  F000     NOP
0B74  52E5     MOVF POSTDEC1, F, ACCESS
0B76  52E5     MOVF POSTDEC1, F, ACCESS
0B78  0900     IORLW 0x0
0B7A  E004     BZ 0xB84
768:           							{	
769:           								M_Motor_state = STATE_MODULE_MOTOR_FAILURE;	
0B7C  0100     MOVLB 0x0
0B7E  0E02     MOVLW 0x2
0B80  6F64     MOVWF M_Motor_state, BANKED
770:           								break;
0B82  D05D     BRA 0xC3E
771:           							}
772:           							switch(M_Motor_check_motor(INDEX_OF_DISPENSER, M_LI_Get_Limit_Switches()->ls_dispenser_start_state, 
0B90  ECBD     CALL 0x3B7A, 0
0B92  F01D     NOP
0B94  CFF3     MOVFF PROD, FSR0
0B96  FFE9     NOP
0B98  CFF4     MOVFF PRODH, FSR0H
0B9A  FFEA     NOP
0B9C  50EF     MOVF INDF0, W, ACCESS
0B9E  6EE6     MOVWF POSTINC1, ACCESS
0BA0  6AE6     CLRF POSTINC1, ACCESS
0BAC  0A00     XORLW 0x0
0BAE  E02D     BZ 0xC0A
0BB0  0A02     XORLW 0x2
0BB2  E022     BZ 0xBF8
0BB4  0A03     XORLW 0x3
0BB6  E00C     BZ 0xBD0
0BB8  0A02     XORLW 0x2
0BBA  E001     BZ 0xBBE
0BBC  D027     BRA 0xC0C
773:           							START_LS, &cnt_failure_backward))
0B84  0E95     MOVLW 0x95
0B86  6EE6     MOVWF POSTINC1, ACCESS
0B88  0E00     MOVLW 0x0
0B8A  6EE6     MOVWF POSTINC1, ACCESS
0B8C  0E01     MOVLW 0x1
0B8E  6EE6     MOVWF POSTINC1, ACCESS
0BA2  DD50     RCALL M_Motor_check_motor
0BA4  6E32     MOVWF __tmp_0, ACCESS
0BA6  0E05     MOVLW 0x5
0BA8  5EE1     SUBWF FSR1, F, ACCESS
0BAA  5032     MOVF __tmp_0, W, ACCESS
774:           							{
775:           								case FAILURE:
776:           									cnt_step = 0;
0BBE  0100     MOVLB 0x0
0BC0  6B69     CLRF cnt_step, BANKED
777:           									M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
0BC2  0100     MOVLB 0x0
0BC4  0E02     MOVLW 0x2
0BC6  6F64     MOVWF M_Motor_state, BANKED
778:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0BC8  0100     MOVLB 0x0
0BCA  6B85     CLRF 0x85, BANKED
0BCC  6B86     CLRF 0x86, BANKED
779:           								break;
0BCE  D01E     BRA 0xC0C
780:           								case NEED_NEXT_STEP:
781:           									direction = TO_FORWARD_DISPENSER;
0BD0  0100     MOVLB 0x0
0BD2  0E01     MOVLW 0x1
0BD4  6F66     MOVWF direction, BANKED
782:           									cnt_step = 0;
0BD6  0100     MOVLB 0x0
0BD8  6B69     CLRF cnt_step, BANKED
783:           									if(after_pause)
0BDA  0100     MOVLB 0x0
0BDC  5196     MOVF 0x96, W, BANKED
0BDE  E008     BZ 0xBF0
784:           									{
785:           										num_motor = INDEX_OF_SHATTER;
0BE0  0100     MOVLB 0x0
0BE2  0E02     MOVLW 0x2
0BE4  6F67     MOVWF num_motor, BANKED
786:           										after_pause = OFF;
0BE6  0100     MOVLB 0x0
0BE8  6B96     CLRF 0x96, BANKED
787:           										direction = TO_BACKWARD_SHATTER;
0BEA  0100     MOVLB 0x0
0BEC  0E05     MOVLW 0x5
0BEE  6F66     MOVWF direction, BANKED
788:           									}
789:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0BF0  0100     MOVLB 0x0
0BF2  6B85     CLRF 0x85, BANKED
0BF4  6B86     CLRF 0x86, BANKED
790:           								break;
0BF6  D00A     BRA 0xC0C
791:           								case NEED_REVERSE:
792:           									cnt_step = 0;
0BF8  0100     MOVLB 0x0
0BFA  6B69     CLRF cnt_step, BANKED
793:           									direction = TO_FORWARD_DISPENSER;							
0BFC  0100     MOVLB 0x0
0BFE  0E01     MOVLW 0x1
0C00  6F66     MOVWF direction, BANKED
794:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0C02  0100     MOVLB 0x0
0C04  6B85     CLRF 0x85, BANKED
0C06  6B86     CLRF 0x86, BANKED
795:           									break;
0C08  D001     BRA 0xC0C
796:           								case IS_BUSY:
797:           								break;	
0C0A  D000     BRA 0xC0C
798:           							}
799:           							break;
0C0C  D018     BRA 0xC3E
800:           						
801:           						case TIME_PAUSE_DISPENSER:		//пауза после вращения вперёд с отключенным двигателем на время TIME_PAUSE_DISPENSER_CONST
802:           							if(time_M_Motor.time_pause++ == TIME_PAUSE_DISPENSER_CONST)
0C0E  0100     MOVLB 0x0
0C10  C083     MOVFF 0x83, __tmp_0
0C12  F032     NOP
0C14  C084     MOVFF 0x84, 0x33
0C16  F033     NOP
0C18  2B83     INCF 0x83, F, BANKED
0C1A  0E00     MOVLW 0x0
0C1C  2384     ADDWFC 0x84, F, BANKED
0C1E  0ED0     MOVLW 0xD0
0C20  1832     XORWF __tmp_0, W, ACCESS
0C22  E102     BNZ 0xC28
0C24  0E07     MOVLW 0x7
0C26  1833     XORWF 0x33, W, ACCESS
0C28  E109     BNZ 0xC3C
803:           							{
804:           								time_M_Motor.time_pause = 0;
0C2A  0100     MOVLB 0x0
0C2C  6B83     CLRF 0x83, BANKED
0C2E  6B84     CLRF 0x84, BANKED
805:           								direction = TO_BACKWARD_DISPENSER;	
0C30  0100     MOVLB 0x0
0C32  0E02     MOVLW 0x2
0C34  6F66     MOVWF direction, BANKED
806:           								after_pause = ON;
0C36  0100     MOVLB 0x0
0C38  0E01     MOVLW 0x1
0C3A  6F96     MOVWF 0x96, BANKED
807:           							}	
808:           							break;
0C3C  D000     BRA 0xC3E
809:           						
810:           					}
811:           					break;
0C3E  D0E5     BRA 0xE0A
812:           				case INDEX_OF_SHATTER:	//вращение двигателя заслонки
813:           					switch(direction)		
0C40  0100     MOVLB 0x0
0C42  5166     MOVF direction, W, BANKED
0C44  0A05     XORLW 0x5
0C46  E06A     BZ 0xD1C
0C48  0A01     XORLW 0x1
0C4A  E001     BZ 0xC4E
0C4C  D0DD     BRA 0xE08
814:           					{
815:           						case TO_FORWARD_SHATTER:		//направление вращения "вперёд"
816:           							ptr_to_motor_pins = &motor_pins_forward[INDEX_OF_SHATTER];
0C4E  0100     MOVLB 0x0
0C50  0EEA     MOVLW 0xEA
0C52  6F91     MOVWF ptr_to_motor_pins, BANKED
0C54  0E4B     MOVLW 0x4B
0C56  6F92     MOVWF 0x92, BANKED
817:           							if(M_Motor_check_ls_after_begin_start(M_LI_Get_Limit_Switches()->ls_shatter_start_state, INDEX_FALSE_STATE_LS_START_SHATTER))
0C58  0E02     MOVLW 0x2
0C5A  6EE6     MOVWF POSTINC1, ACCESS
0C5C  ECBD     CALL 0x3B7A, 0
0C5E  F01D     NOP
0C60  CFF3     MOVFF PROD, FSR0
0C62  FFE9     NOP
0C64  CFF4     MOVFF PRODH, FSR0H
0C66  FFEA     NOP
0C68  0E02     MOVLW 0x2
0C6A  26E9     ADDWF FSR0, F, ACCESS
0C6C  0E00     MOVLW 0x0
0C6E  22EA     ADDWFC FSR0H, F, ACCESS
0C70  50EF     MOVF INDF0, W, ACCESS
0C72  6EE6     MOVWF POSTINC1, ACCESS
0C74  EC6B     CALL 0xD6, 0
0C76  F000     NOP
0C78  52E5     MOVF POSTDEC1, F, ACCESS
0C7A  52E5     MOVF POSTDEC1, F, ACCESS
0C7C  0900     IORLW 0x0
0C7E  E004     BZ 0xC88
818:           							{	
819:           								M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
0C80  0100     MOVLB 0x0
0C82  0E02     MOVLW 0x2
0C84  6F64     MOVWF M_Motor_state, BANKED
820:           								break;
0C86  D0C0     BRA 0xE08
821:           							}
822:           							switch(M_Motor_check_motor(INDEX_OF_SHATTER, M_LI_Get_Limit_Switches()->ls_shatter_finish_state, FINISH_LS,
0C90  0E02     MOVLW 0x2
0C92  6EE6     MOVWF POSTINC1, ACCESS
0C94  ECBD     CALL 0x3B7A, 0
0C96  F01D     NOP
0C98  CFF3     MOVFF PROD, FSR0
0C9A  FFE9     NOP
0C9C  CFF4     MOVFF PRODH, FSR0H
0C9E  FFEA     NOP
0CA0  0E03     MOVLW 0x3
0CA2  26E9     ADDWF FSR0, F, ACCESS
0CA4  0E00     MOVLW 0x0
0CA6  22EA     ADDWFC FSR0H, F, ACCESS
0CA8  50EF     MOVF INDF0, W, ACCESS
0CAA  6EE6     MOVWF POSTINC1, ACCESS
0CAC  0E02     MOVLW 0x2
0CAE  6EE6     MOVWF POSTINC1, ACCESS
0CBA  0A00     XORLW 0x0
0CBC  E02D     BZ 0xD18
0CBE  0A02     XORLW 0x2
0CC0  E022     BZ 0xD06
0CC2  0A03     XORLW 0x3
0CC4  E00C     BZ 0xCDE
0CC6  0A02     XORLW 0x2
0CC8  E001     BZ 0xCCC
0CCA  D027     BRA 0xD1A
823:           							&cnt_failure_forward))
0C88  0E94     MOVLW 0x94
0C8A  6EE6     MOVWF POSTINC1, ACCESS
0C8C  0E00     MOVLW 0x0
0C8E  6EE6     MOVWF POSTINC1, ACCESS
0CB0  DCC9     RCALL M_Motor_check_motor
0CB2  6E32     MOVWF __tmp_0, ACCESS
0CB4  0E05     MOVLW 0x5
0CB6  5EE1     SUBWF FSR1, F, ACCESS
0CB8  5032     MOVF __tmp_0, W, ACCESS
824:           							{
825:           								case FAILURE:
826:           									cnt_step = 0;
0CCC  0100     MOVLB 0x0
0CCE  6B69     CLRF cnt_step, BANKED
827:           									M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
0CD0  0100     MOVLB 0x0
0CD2  0E02     MOVLW 0x2
0CD4  6F64     MOVWF M_Motor_state, BANKED
828:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0CD6  0100     MOVLB 0x0
0CD8  6B85     CLRF 0x85, BANKED
0CDA  6B86     CLRF 0x86, BANKED
829:           									break;
0CDC  D01E     BRA 0xD1A
830:           								case NEED_NEXT_STEP:
831:           									cnt_step = 0;
0CDE  0100     MOVLB 0x0
0CE0  6B69     CLRF cnt_step, BANKED
832:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0CE2  0100     MOVLB 0x0
0CE4  6B85     CLRF 0x85, BANKED
0CE6  6B86     CLRF 0x86, BANKED
833:           									if(!shatter_reverse) 
0CE8  0100     MOVLB 0x0
0CEA  5197     MOVF 0x97, W, BANKED
0CEC  E106     BNZ 0xCFA
834:           									{
835:           									
836:           										num_motor = INDEX_OF_DISPENSER; 
0CEE  0100     MOVLB 0x0
0CF0  6B67     CLRF num_motor, BANKED
837:           										direction = TO_FORWARD_DISPENSER;
0CF2  0100     MOVLB 0x0
0CF4  0E01     MOVLW 0x1
0CF6  6F66     MOVWF direction, BANKED
838:           									}
839:           									else  //если застряли на преграде при движении заслонки назад, откатываем её вперёд и повторяем движение назад
0CF8  D005     BRA 0xD04
840:           									{
841:           										shatter_reverse = OFF;
0CFA  0100     MOVLB 0x0
0CFC  6B97     CLRF 0x97, BANKED
842:           										direction = TO_BACKWARD_SHATTER;	
0CFE  0100     MOVLB 0x0
0D00  0E05     MOVLW 0x5
0D02  6F66     MOVWF direction, BANKED
843:           									}
844:           									break;
0D04  D00A     BRA 0xD1A
845:           								case NEED_REVERSE:
846:           									cnt_step = 0;
0D06  0100     MOVLB 0x0
0D08  6B69     CLRF cnt_step, BANKED
847:           									direction = TO_BACKWARD_SHATTER;							
0D0A  0100     MOVLB 0x0
0D0C  0E05     MOVLW 0x5
0D0E  6F66     MOVWF direction, BANKED
848:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0D10  0100     MOVLB 0x0
0D12  6B85     CLRF 0x85, BANKED
0D14  6B86     CLRF 0x86, BANKED
849:           									break;
0D16  D001     BRA 0xD1A
850:           								case IS_BUSY:
851:           									break;	
0D18  D000     BRA 0xD1A
852:           							}
853:           							break;
0D1A  D076     BRA 0xE08
854:           						case TO_BACKWARD_SHATTER:		//направление вращения "назад"
855:           							ptr_to_motor_pins = &motor_pins_backward[INDEX_OF_SHATTER];
0D1C  0100     MOVLB 0x0
0D1E  0E02     MOVLW 0x2
0D20  6F91     MOVWF ptr_to_motor_pins, BANKED
0D22  0E4C     MOVLW 0x4C
0D24  6F92     MOVWF 0x92, BANKED
856:           							if(M_Motor_check_ls_after_begin_start(M_LI_Get_Limit_Switches()->ls_shatter_finish_state, INDEX_FALSE_STATE_LS_FINISH_SHATTER))
0D26  0E03     MOVLW 0x3
0D28  6EE6     MOVWF POSTINC1, ACCESS
0D2A  ECBD     CALL 0x3B7A, 0
0D2C  F01D     NOP
0D2E  CFF3     MOVFF PROD, FSR0
0D30  FFE9     NOP
0D32  CFF4     MOVFF PRODH, FSR0H
0D34  FFEA     NOP
0D36  0E03     MOVLW 0x3
0D38  26E9     ADDWF FSR0, F, ACCESS
0D3A  0E00     MOVLW 0x0
0D3C  22EA     ADDWFC FSR0H, F, ACCESS
0D3E  50EF     MOVF INDF0, W, ACCESS
0D40  6EE6     MOVWF POSTINC1, ACCESS
0D42  EC6B     CALL 0xD6, 0
0D44  F000     NOP
0D46  52E5     MOVF POSTDEC1, F, ACCESS
0D48  52E5     MOVF POSTDEC1, F, ACCESS
0D4A  0900     IORLW 0x0
0D4C  E004     BZ 0xD56
857:           							{	
858:           								M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
0D4E  0100     MOVLB 0x0
0D50  0E02     MOVLW 0x2
0D52  6F64     MOVWF M_Motor_state, BANKED
859:           								break;
0D54  D059     BRA 0xE08
860:           							}
861:           							switch(M_Motor_check_motor(INDEX_OF_SHATTER, M_LI_Get_Limit_Switches()->ls_shatter_start_state, START_LS,
0D5E  0E01     MOVLW 0x1
0D60  6EE6     MOVWF POSTINC1, ACCESS
0D62  ECBD     CALL 0x3B7A, 0
0D64  F01D     NOP
0D66  CFF3     MOVFF PROD, FSR0
0D68  FFE9     NOP
0D6A  CFF4     MOVFF PRODH, FSR0H
0D6C  FFEA     NOP
0D6E  0E02     MOVLW 0x2
0D70  26E9     ADDWF FSR0, F, ACCESS
0D72  0E00     MOVLW 0x0
0D74  22EA     ADDWFC FSR0H, F, ACCESS
0D76  50EF     MOVF INDF0, W, ACCESS
0D78  6EE6     MOVWF POSTINC1, ACCESS
0D7A  0E02     MOVLW 0x2
0D7C  6EE6     MOVWF POSTINC1, ACCESS
0D88  0A00     XORLW 0x0
0D8A  E03C     BZ 0xE04
0D8C  0A02     XORLW 0x2
0D8E  E02E     BZ 0xDEC
0D90  0A03     XORLW 0x3
0D92  E00C     BZ 0xDAC
0D94  0A02     XORLW 0x2
0D96  E001     BZ 0xD9A
0D98  D036     BRA 0xE06
862:           							&cnt_failure_backward))
0D56  0E95     MOVLW 0x95
0D58  6EE6     MOVWF POSTINC1, ACCESS
0D5A  0E00     MOVLW 0x0
0D5C  6EE6     MOVWF POSTINC1, ACCESS
0D7E  DC62     RCALL M_Motor_check_motor
0D80  6E32     MOVWF __tmp_0, ACCESS
0D82  0E05     MOVLW 0x5
0D84  5EE1     SUBWF FSR1, F, ACCESS
0D86  5032     MOVF __tmp_0, W, ACCESS
863:           							{
864:           								case FAILURE:
865:           									cnt_step = 0;
0D9A  0100     MOVLB 0x0
0D9C  6B69     CLRF cnt_step, BANKED
866:           									M_Motor_state = STATE_MODULE_MOTOR_FAILURE;
0D9E  0100     MOVLB 0x0
0DA0  0E02     MOVLW 0x2
0DA2  6F64     MOVWF M_Motor_state, BANKED
867:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0DA4  0100     MOVLB 0x0
0DA6  6B85     CLRF 0x85, BANKED
0DA8  6B86     CLRF 0x86, BANKED
868:           									break;
0DAA  D02D     BRA 0xE06
869:           								case NEED_NEXT_STEP:
870:           									cnt_step = 0;
0DAC  0100     MOVLB 0x0
0DAE  6B69     CLRF cnt_step, BANKED
871:           									direction = TO_FORWARD_SHATTER;
0DB0  0100     MOVLB 0x0
0DB2  0E04     MOVLW 0x4
0DB4  6F66     MOVWF direction, BANKED
872:           									num_motor = INDEX_OF_AGITATOR;
0DB6  0100     MOVLB 0x0
0DB8  0E01     MOVLW 0x1
0DBA  6F67     MOVWF num_motor, BANKED
873:           									ctrl = OFF;
0DBC  0100     MOVLB 0x0
0DBE  6B65     CLRF ctrl, BANKED
874:           									after_pause = OFF;
0DC0  0100     MOVLB 0x0
0DC2  6B96     CLRF 0x96, BANKED
875:           									M_Ind_Set_blink_mode(NO_NEED_BLINK);
0DC4  6AE6     CLRF POSTINC1, ACCESS
0DC6  EC7E     CALL 0x2AFC, 0
0DC8  F015     NOP
0DCA  52E5     MOVF POSTDEC1, F, ACCESS
876:           									M_Motor_state = STATE_MODULE_MOTOR_WAITING;
0DCC  0100     MOVLB 0x0
0DCE  0E01     MOVLW 0x1
0DD0  6F64     MOVWF M_Motor_state, BANKED
877:           									if(M_Mngm_Get_state() == STATE_BURNING) 
0DD2  ECA7     CALL 0x154E, 0
0DD4  F00A     NOP
0DD6  0802     SUBLW 0x2
0DD8  E105     BNZ 0xDE4
878:           										M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
0DDA  0E03     MOVLW 0x3
0DDC  6EE6     MOVWF POSTINC1, ACCESS
0DDE  EC98     CALL 0x2B30, 0
0DE0  F015     NOP
0DE2  52E5     MOVF POSTDEC1, F, ACCESS
879:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0DE4  0100     MOVLB 0x0
0DE6  6B85     CLRF 0x85, BANKED
0DE8  6B86     CLRF 0x86, BANKED
880:           									break;
0DEA  D00D     BRA 0xE06
881:           								case NEED_REVERSE:
882:           									cnt_step = 0;
0DEC  0100     MOVLB 0x0
0DEE  6B69     CLRF cnt_step, BANKED
883:           									direction = TO_FORWARD_SHATTER;							
0DF0  0100     MOVLB 0x0
0DF2  0E04     MOVLW 0x4
0DF4  6F66     MOVWF direction, BANKED
884:           									time_M_Motor.time_ctrl_ls_after_begin = 0;
0DF6  0100     MOVLB 0x0
0DF8  6B85     CLRF 0x85, BANKED
0DFA  6B86     CLRF 0x86, BANKED
885:           									shatter_reverse = ON;
0DFC  0100     MOVLB 0x0
0DFE  0E01     MOVLW 0x1
0E00  6F97     MOVWF 0x97, BANKED
886:           									break;
0E02  D001     BRA 0xE06
887:           								case IS_BUSY:
888:           									break;	
0E04  D000     BRA 0xE06
889:           							}
890:           							break;
0E06  D000     BRA 0xE08
891:           				}
892:           				break;
0E08  D000     BRA 0xE0A
893:           			}	
894:           			break;
0E0A  D000     BRA 0xE0C
895:           	}
896:           }
0E0C  0012     RETURN 0
897:           
898:           
899:           static void M_Motor_clear_accel_state(void)
900:           {
901:           	accel_state = 0;
0E0E  0100     MOVLB 0x0
0E10  6B61     CLRF accel_state, BANKED
902:           	M_Motor_PWM_period = 0;
0E12  0100     MOVLB 0x0
0E14  6B63     CLRF M_Motor_PWM_period, BANKED
903:           	M_Motor_Timer2_change(TIMER2_OFF_VALUE, DISABLE_TMR2_INTR);
0E16  6AE6     CLRF POSTINC1, ACCESS
0E18  6AE6     CLRF POSTINC1, ACCESS
0E1A  D936     RCALL M_Motor_Timer2_change
0E1C  52E5     MOVF POSTDEC1, F, ACCESS
0E1E  52E5     MOVF POSTDEC1, F, ACCESS
904:           }
0E20  0012     RETURN 0
905:           
906:           
907:           /*Реализация включенного двигателя (номинальное напряжение) 
908:           Включается верхний ключ и нижний ключ в диагонали моста
909:            */
910:           static void M_Motor_is_worked(const rom IOport_motor* motor_pins)
0E22  CFD9     MOVFF FSR2, POSTINC1
0E24  FFE6     NOP
0E26  CFE1     MOVFF FSR1, FSR2
0E28  FFD9     NOP
911:           {
912:           	*motor_pins->portReg_prim_half_bridge |= 1 << (motor_pins->pin_num_prim_half_bridge);	
0E2A  0EFD     MOVLW 0xFD
0E2C  CFDB     MOVFF PLUSW2, TBLPTR
0E2E  FFF6     NOP
0E30  0EFE     MOVLW 0xFE
0E32  CFDB     MOVFF PLUSW2, TBLPTRH
0E34  FFF7     NOP
0E36  0E02     MOVLW 0x2
0E38  26F6     ADDWF TBLPTR, F, ACCESS
0E3A  0E00     MOVLW 0x0
0E3C  22F7     ADDWFC TBLPTRH, F, ACCESS
0E3E  0008     TBLRD*
0E40  50F5     MOVF TABLAT, W, ACCESS
0E42  6E33     MOVWF 0x33, ACCESS
0E44  0E01     MOVLW 0x1
0E46  5233     MOVF 0x33, F, ACCESS
0E48  E004     BZ 0xE52
0E4A  46E8     RLNCF WREG, F, ACCESS
0E4C  0BFE     ANDLW 0xFE
0E4E  0633     DECF 0x33, F, ACCESS
0E50  E1FC     BNZ 0xE4A
0E52  6E32     MOVWF __tmp_0, ACCESS
0E54  0EFD     MOVLW 0xFD
0E56  CFDB     MOVFF PLUSW2, TBLPTR
0E58  FFF6     NOP
0E5A  0EFE     MOVLW 0xFE
0E5C  CFDB     MOVFF PLUSW2, TBLPTRH
0E5E  FFF7     NOP
0E60  0009     TBLRD*+
0E62  CFF5     MOVFF TABLAT, FSR0
0E64  FFE9     NOP
0E66  0008     TBLRD*
0E68  CFF5     MOVFF TABLAT, FSR0H
0E6A  FFEA     NOP
0E6C  5032     MOVF __tmp_0, W, ACCESS
0E6E  12EF     IORWF INDF0, F, ACCESS
913:           	*motor_pins->portReg_sec_half_bridge |= 1 << (motor_pins->pin_num_sec_half_bridge);
0E70  0EFD     MOVLW 0xFD
0E72  CFDB     MOVFF PLUSW2, TBLPTR
0E74  FFF6     NOP
0E76  0EFE     MOVLW 0xFE
0E78  CFDB     MOVFF PLUSW2, TBLPTRH
0E7A  FFF7     NOP
0E7C  0E05     MOVLW 0x5
0E7E  26F6     ADDWF TBLPTR, F, ACCESS
0E80  0E00     MOVLW 0x0
0E82  22F7     ADDWFC TBLPTRH, F, ACCESS
0E84  0008     TBLRD*
0E86  50F5     MOVF TABLAT, W, ACCESS
0E88  6E33     MOVWF 0x33, ACCESS
0E8A  0E01     MOVLW 0x1
0E8C  5233     MOVF 0x33, F, ACCESS
0E8E  E004     BZ 0xE98
0E90  46E8     RLNCF WREG, F, ACCESS
0E92  0BFE     ANDLW 0xFE
0E94  0633     DECF 0x33, F, ACCESS
0E96  E1FC     BNZ 0xE90
0E98  6E32     MOVWF __tmp_0, ACCESS
0E9A  0EFD     MOVLW 0xFD
0E9C  CFDB     MOVFF PLUSW2, TBLPTR
0E9E  FFF6     NOP
0EA0  0EFE     MOVLW 0xFE
0EA2  CFDB     MOVFF PLUSW2, TBLPTRH
0EA4  FFF7     NOP
0EA6  0E03     MOVLW 0x3
0EA8  26F6     ADDWF TBLPTR, F, ACCESS
0EAA  0E00     MOVLW 0x0
0EAC  22F7     ADDWFC TBLPTRH, F, ACCESS
0EAE  0009     TBLRD*+
0EB0  CFF5     MOVFF TABLAT, FSR0
0EB2  FFE9     NOP
0EB4  0008     TBLRD*
0EB6  CFF5     MOVFF TABLAT, FSR0H
0EB8  FFEA     NOP
0EBA  5032     MOVF __tmp_0, W, ACCESS
0EBC  12EF     IORWF INDF0, F, ACCESS
914:           }
0EBE  52E5     MOVF POSTDEC1, F, ACCESS
0EC0  CFE7     MOVFF INDF1, FSR2
0EC2  FFD9     NOP
0EC4  0012     RETURN 0
915:           
916:           
917:           /* 
918:           Торможение двигателя
919:           Включается 2 верхних ключа в плечах моста
920:           Возвращает:
921:           0 -  если не прошло время торможения двигателя
922:           1 -  если прошло время торможения двигателя
923:           */
924:           static BOOL M_Motor_is_brake(const rom IOport_motor* motor_pins, uint8_t which_ls, uint8_t num)
0EC6  CFD9     MOVFF FSR2, POSTINC1
0EC8  FFE6     NOP
0ECA  CFE1     MOVFF FSR1, FSR2
0ECC  FFD9     NOP
925:           {
926:           	static uint8_t step_brake = ROTATE_REVERSE;
927:           	
928:           	switch(step_brake)
0ECE  0100     MOVLB 0x0
0ED0  5198     MOVF 0x98, W, BANKED
0ED2  0A01     XORLW 0x1
0ED4  E061     BZ 0xF98
0ED6  0A01     XORLW 0x1
0ED8  E001     BZ 0xEDC
0EDA  D07C     BRA 0xFD4
929:           	{
930:           		case ROTATE_REVERSE:
931:           			if (which_ls == AGITATOR_LS)
0EDC  0EFC     MOVLW 0xFC
0EDE  50DB     MOVF PLUSW2, W, ACCESS
0EE0  0804     SUBLW 0x4
0EE2  E104     BNZ 0xEEC
932:           			{
933:           				step_brake = BRAKE_HIGH_SW;	
0EE4  0100     MOVLB 0x0
0EE6  0E01     MOVLW 0x1
0EE8  6F98     MOVWF 0x98, BANKED
934:           				break;
0EEA  D074     BRA 0xFD4
935:           			}
936:           			M_Motor_is_worked(which_ls ==  START_LS ? &motor_pins_forward[num]  :  &motor_pins_backward[num]);
0EEC  0EFC     MOVLW 0xFC
0EEE  04DB     DECF PLUSW2, W, ACCESS
0EF0  E10C     BNZ 0xF0A
0EF2  0EFB     MOVLW 0xFB
0EF4  50DB     MOVF PLUSW2, W, ACCESS
0EF6  0D06     MULLW 0x6
0EF8  CFF3     MOVFF PROD, __tmp_0
0EFA  F032     NOP
0EFC  CFF4     MOVFF PRODH, 0x33
0EFE  F033     NOP
0F00  0EDE     MOVLW 0xDE
0F02  2632     ADDWF __tmp_0, F, ACCESS
0F04  0E4B     MOVLW 0x4B
0F06  2233     ADDWFC 0x33, F, ACCESS
0F08  D00B     BRA 0xF20
0F0A  0EFB     MOVLW 0xFB
0F0C  50DB     MOVF PLUSW2, W, ACCESS
0F0E  0D06     MULLW 0x6
0F10  CFF3     MOVFF PROD, __tmp_0
0F12  F032     NOP
0F14  CFF4     MOVFF PRODH, 0x33
0F16  F033     NOP
0F18  0EF6     MOVLW 0xF6
0F1A  2632     ADDWF __tmp_0, F, ACCESS
0F1C  0E4B     MOVLW 0x4B
0F1E  2233     ADDWFC 0x33, F, ACCESS
0F20  C032     MOVFF __tmp_0, POSTINC1
0F22  FFE6     NOP
0F24  C033     MOVFF 0x33, POSTINC1
0F26  FFE6     NOP
0F28  DF7C     RCALL M_Motor_is_worked
0F2A  52E5     MOVF POSTDEC1, F, ACCESS
0F2C  52E5     MOVF POSTDEC1, F, ACCESS
937:           			if(time_M_Motor. time_rotate_motor_in_reverse++ ==  TIME_ROTATE_MOTOR_IN_REVERSE)
0F2E  0100     MOVLB 0x0
0F30  C081     MOVFF 0x81, __tmp_0
0F32  F032     NOP
0F34  C082     MOVFF 0x82, 0x33
0F36  F033     NOP
0F38  2B81     INCF 0x81, F, BANKED
0F3A  0E00     MOVLW 0x0
0F3C  2382     ADDWFC 0x82, F, BANKED
0F3E  0E2D     MOVLW 0x2D
0F40  1832     XORWF __tmp_0, W, ACCESS
0F42  E101     BNZ 0xF46
0F44  5033     MOVF 0x33, W, ACCESS
0F46  E127     BNZ 0xF96
938:           			{
939:           				time_M_Motor. time_rotate_motor_in_reverse = 0;
0F48  0100     MOVLB 0x0
0F4A  6B81     CLRF 0x81, BANKED
0F4C  6B82     CLRF 0x82, BANKED
940:           				step_brake = BRAKE_HIGH_SW;
0F4E  0100     MOVLB 0x0
0F50  0E01     MOVLW 0x1
0F52  6F98     MOVWF 0x98, BANKED
941:           				M_Motor_is_stopped(which_ls ==  START_LS ? &motor_pins_forward[num]  :  &motor_pins_backward[num]);
0F54  0EFC     MOVLW 0xFC
0F56  04DB     DECF PLUSW2, W, ACCESS
0F58  E10C     BNZ 0xF72
0F5A  0EFB     MOVLW 0xFB
0F5C  50DB     MOVF PLUSW2, W, ACCESS
0F5E  0D06     MULLW 0x6
0F60  CFF3     MOVFF PROD, __tmp_0
0F62  F032     NOP
0F64  CFF4     MOVFF PRODH, 0x33
0F66  F033     NOP
0F68  0EDE     MOVLW 0xDE
0F6A  2632     ADDWF __tmp_0, F, ACCESS
0F6C  0E4B     MOVLW 0x4B
0F6E  2233     ADDWFC 0x33, F, ACCESS
0F70  D00B     BRA 0xF88
0F72  0EFB     MOVLW 0xFB
0F74  50DB     MOVF PLUSW2, W, ACCESS
0F76  0D06     MULLW 0x6
0F78  CFF3     MOVFF PROD, __tmp_0
0F7A  F032     NOP
0F7C  CFF4     MOVFF PRODH, 0x33
0F7E  F033     NOP
0F80  0EF6     MOVLW 0xF6
0F82  2632     ADDWF __tmp_0, F, ACCESS
0F84  0E4B     MOVLW 0x4B
0F86  2233     ADDWFC 0x33, F, ACCESS
0F88  C032     MOVFF __tmp_0, POSTINC1
0F8A  FFE6     NOP
0F8C  C033     MOVFF 0x33, POSTINC1
0F8E  FFE6     NOP
0F90  D827     RCALL M_Motor_is_stopped
0F92  52E5     MOVF POSTDEC1, F, ACCESS
0F94  52E5     MOVF POSTDEC1, F, ACCESS
942:           			}
943:           		break;
0F96  D01E     BRA 0xFD4
944:           		case BRAKE_HIGH_SW:
945:           			M_Motor_is_worked(motor_pins);
0F98  0EFD     MOVLW 0xFD
0F9A  CFDB     MOVFF PLUSW2, POSTINC1
0F9C  FFE6     NOP
0F9E  0EFE     MOVLW 0xFE
0FA0  CFDB     MOVFF PLUSW2, POSTINC1
0FA2  FFE6     NOP
0FA4  DF3E     RCALL M_Motor_is_worked
0FA6  52E5     MOVF POSTDEC1, F, ACCESS
0FA8  52E5     MOVF POSTDEC1, F, ACCESS
946:           			if(time_M_Motor.time_brake_motor++ == TIME_BRAKE_MOTOR_CONST)
0FAA  0100     MOVLB 0x0
0FAC  C07F     MOVFF 0x7F, __tmp_0
0FAE  F032     NOP
0FB0  C080     MOVFF 0x80, 0x33
0FB2  F033     NOP
0FB4  2B7F     INCF 0x7F, F, BANKED
0FB6  0E00     MOVLW 0x0
0FB8  2380     ADDWFC 0x80, F, BANKED
0FBA  0E32     MOVLW 0x32
0FBC  1832     XORWF __tmp_0, W, ACCESS
0FBE  E101     BNZ 0xFC2
0FC0  5033     MOVF 0x33, W, ACCESS
0FC2  E107     BNZ 0xFD2
947:           			{	
948:           				time_M_Motor.time_brake_motor = 0;
0FC4  0100     MOVLB 0x0
0FC6  6B7F     CLRF 0x7F, BANKED
0FC8  6B80     CLRF 0x80, BANKED
949:           				step_brake = ROTATE_REVERSE;
0FCA  0100     MOVLB 0x0
0FCC  6B98     CLRF 0x98, BANKED
950:           				return TRUE;
0FCE  0E01     MOVLW 0x1
0FD0  D003     BRA 0xFD8
951:           			}
952:           	 	break;
0FD2  D000     BRA 0xFD4
953:           	}
954:           	return FALSE;
0FD4  0E00     MOVLW 0x0
0FD6  D000     BRA 0xFD8
955:           }
0FD8  52E5     MOVF POSTDEC1, F, ACCESS
0FDA  CFE7     MOVFF INDF1, FSR2
0FDC  FFD9     NOP
0FDE  0012     RETURN 0
956:            
957:           
958:           	
959:           /*
960:           Реализация выключения двигателя 
961:           Отключается в диагонали моста верхний и нижний ключ
962:           */
963:           static void M_Motor_is_stopped(const rom IOport_motor* motor_pins)
0FE0  CFD9     MOVFF FSR2, POSTINC1
0FE2  FFE6     NOP
0FE4  CFE1     MOVFF FSR1, FSR2
0FE6  FFD9     NOP
964:           {
965:           	*motor_pins->portReg_prim_half_bridge &= ~(1 << (motor_pins->pin_num_prim_half_bridge));	
0FE8  0EFD     MOVLW 0xFD
0FEA  CFDB     MOVFF PLUSW2, TBLPTR
0FEC  FFF6     NOP
0FEE  0EFE     MOVLW 0xFE
0FF0  CFDB     MOVFF PLUSW2, TBLPTRH
0FF2  FFF7     NOP
0FF4  0E02     MOVLW 0x2
0FF6  26F6     ADDWF TBLPTR, F, ACCESS
0FF8  0E00     MOVLW 0x0
0FFA  22F7     ADDWFC TBLPTRH, F, ACCESS
0FFC  0008     TBLRD*
0FFE  50F5     MOVF TABLAT, W, ACCESS
1000  6E33     MOVWF 0x33, ACCESS
1002  0E01     MOVLW 0x1
1004  5233     MOVF 0x33, F, ACCESS
1006  E004     BZ 0x1010
1008  46E8     RLNCF WREG, F, ACCESS
100A  0BFE     ANDLW 0xFE
100C  0633     DECF 0x33, F, ACCESS
100E  E1FC     BNZ 0x1008
1010  1CE8     COMF WREG, W, ACCESS
1012  6E32     MOVWF __tmp_0, ACCESS
1014  0EFD     MOVLW 0xFD
1016  CFDB     MOVFF PLUSW2, TBLPTR
1018  FFF6     NOP
101A  0EFE     MOVLW 0xFE
101C  CFDB     MOVFF PLUSW2, TBLPTRH
101E  FFF7     NOP
1020  0009     TBLRD*+
1022  CFF5     MOVFF TABLAT, FSR0
1024  FFE9     NOP
1026  0008     TBLRD*
1028  CFF5     MOVFF TABLAT, FSR0H
102A  FFEA     NOP
102C  5032     MOVF __tmp_0, W, ACCESS
102E  16EF     ANDWF INDF0, F, ACCESS
966:           	*motor_pins->portReg_sec_half_bridge &= ~(1 << (motor_pins->pin_num_sec_half_bridge));
1030  0EFD     MOVLW 0xFD
1032  CFDB     MOVFF PLUSW2, TBLPTR
1034  FFF6     NOP
1036  0EFE     MOVLW 0xFE
1038  CFDB     MOVFF PLUSW2, TBLPTRH
103A  FFF7     NOP
103C  0E05     MOVLW 0x5
103E  26F6     ADDWF TBLPTR, F, ACCESS
1040  0E00     MOVLW 0x0
1042  22F7     ADDWFC TBLPTRH, F, ACCESS
1044  0008     TBLRD*
1046  50F5     MOVF TABLAT, W, ACCESS
1048  6E33     MOVWF 0x33, ACCESS
104A  0E01     MOVLW 0x1
104C  5233     MOVF 0x33, F, ACCESS
104E  E004     BZ 0x1058
1050  46E8     RLNCF WREG, F, ACCESS
1052  0BFE     ANDLW 0xFE
1054  0633     DECF 0x33, F, ACCESS
1056  E1FC     BNZ 0x1050
1058  1CE8     COMF WREG, W, ACCESS
105A  6E32     MOVWF __tmp_0, ACCESS
105C  0EFD     MOVLW 0xFD
105E  CFDB     MOVFF PLUSW2, TBLPTR
1060  FFF6     NOP
1062  0EFE     MOVLW 0xFE
1064  CFDB     MOVFF PLUSW2, TBLPTRH
1066  FFF7     NOP
1068  0E03     MOVLW 0x3
106A  26F6     ADDWF TBLPTR, F, ACCESS
106C  0E00     MOVLW 0x0
106E  22F7     ADDWFC TBLPTRH, F, ACCESS
1070  0009     TBLRD*+
1072  CFF5     MOVFF TABLAT, FSR0
1074  FFE9     NOP
1076  0008     TBLRD*
1078  CFF5     MOVFF TABLAT, FSR0H
107A  FFEA     NOP
107C  5032     MOVF __tmp_0, W, ACCESS
107E  16EF     ANDWF INDF0, F, ACCESS
967:           }
1080  52E5     MOVF POSTDEC1, F, ACCESS
1082  CFE7     MOVFF INDF1, FSR2
1084  FFD9     NOP
1086  0012     RETURN 0
968:           
969:           
970:           /* Для управления включением/отключением т/с2, которым формируется программный ШИМ разгона двигателя */
971:           static void M_Motor_Timer2_change(const uint8_t value_timer_ctrl, const uint8_t en_intr)
1088  CFD9     MOVFF FSR2, POSTINC1
108A  FFE6     NOP
108C  CFE1     MOVFF FSR1, FSR2
108E  FFD9     NOP
972:           {
973:           	T2CON = value_timer_ctrl;
1090  0EFE     MOVLW 0xFE
1092  50DB     MOVF PLUSW2, W, ACCESS
1094  6ECA     MOVWF T2CON, ACCESS
974:           	PIE1 =  en_intr;
1096  0EFD     MOVLW 0xFD
1098  50DB     MOVF PLUSW2, W, ACCESS
109A  6E9D     MOVWF PIE1, ACCESS
975:           }
109C  52E5     MOVF POSTDEC1, F, ACCESS
109E  CFE7     MOVFF INDF1, FSR2
10A0  FFD9     NOP
10A2  0012     RETURN 0
976:           
977:           /* Реализация плавного разгона коллекторного двигателя ШИМом от min_PWM_accel до 100%
978:           по заданному времени разгона и значению начальной длительности ШИМа
979:            вычисляется количество "ступенек" ШИМа quantity_steps_accel
980:            */
981:           static void M_Motor_accel(uint8_t index)
10A4  CFD9     MOVFF FSR2, POSTINC1
10A6  FFE6     NOP
10A8  CFE1     MOVFF FSR1, FSR2
10AA  FFD9     NOP
10AC  0E02     MOVLW 0x2
10AE  26E1     ADDWF FSR1, F, ACCESS
982:           {
983:           	static uint8_t quantity_steps_accel;
984:           	static uint16_t delta_t_accel;
985:           	uint16_t temp;
986:           	
987:           	switch(accel_state)
10B0  0100     MOVLB 0x0
10B2  5161     MOVF accel_state, W, BANKED
10B4  0A01     XORLW 0x1
10B6  E101     BNZ 0x10BA
10B8  D09B     BRA 0x11F0
10BA  0A01     XORLW 0x1
10BC  E001     BZ 0x10C0
10BE  D0BC     BRA 0x1238
988:           	{
989:           		case CALC_PARAMS: //вычисление параметров для плавного разгона ШИМом до номинального напряжения
990:           			//Получаем из меню значение минимальной длительности ШИМа в процентах
991:           			temp = M_Mngm_Get_parameters_buffer()->menu_parameters.Motor[index].min_PWM_accel;	
10C0  EC8E     CALL 0x151C, 0
10C2  F00A     NOP
10C4  CFF3     MOVFF PROD, FSR0
10C6  FFE9     NOP
10C8  CFF4     MOVFF PRODH, FSR0H
10CA  FFEA     NOP
10CC  CFE9     MOVFF FSR0, __tmp_0
10CE  F032     NOP
10D0  CFEA     MOVFF FSR0H, 0x33
10D2  F033     NOP
10D4  0EFE     MOVLW 0xFE
10D6  50DB     MOVF PLUSW2, W, ACCESS
10D8  0D04     MULLW 0x4
10DA  5032     MOVF __tmp_0, W, ACCESS
10DC  24F3     ADDWF PROD, W, ACCESS
10DE  6EE9     MOVWF FSR0, ACCESS
10E0  5033     MOVF 0x33, W, ACCESS
10E2  20F4     ADDWFC PRODH, W, ACCESS
10E4  6EEA     MOVWF FSR0H, ACCESS
10E6  0E02     MOVLW 0x2
10E8  26E9     ADDWF FSR0, F, ACCESS
10EA  0E00     MOVLW 0x0
10EC  22EA     ADDWFC FSR0H, F, ACCESS
10EE  50EF     MOVF INDF0, W, ACCESS
10F0  6EDE     MOVWF POSTINC2, ACCESS
10F2  6ADD     CLRF POSTDEC2, ACCESS
992:           			if(temp == MAX_PWM_DUTY_PERCENT)  		//если максимальный ШИМ, значит разгон не нужен
10F4  CFD9     MOVFF FSR2, FSR0
10F6  FFE9     NOP
10F8  CFDA     MOVFF FSR2H, FSR0H
10FA  FFEA     NOP
10FC  0E64     MOVLW 0x64
10FE  18EE     XORWF POSTINC0, W, ACCESS
1100  E101     BNZ 0x1104
1102  50ED     MOVF POSTDEC0, W, ACCESS
1104  E105     BNZ 0x1110
993:           			{
994:           				accel_state	= MOTOR_IS_ACCELERATED;
1106  0100     MOVLB 0x0
1108  0E02     MOVLW 0x2
110A  6F61     MOVWF accel_state, BANKED
995:           				break;
110C  D095     BRA 0x1238
996:           			}
997:           			else
110E  D06F     BRA 0x11EE
998:           			{
999:           				//Деление на 4 сдвигом, то есть вся шкала ШИМа - 25 шагов
1000:          				//вычисляем значение длительности ШИМа в каждом периоде для прерывания (от 7 до 25)
1001:          				cnt_duty = temp >> 2;			 	
1110  CFDE     MOVFF POSTINC2, __tmp_0
1112  F032     NOP
1114  CFDD     MOVFF POSTDEC2, 0x33
1116  F033     NOP
1118  90D8     BCF STATUS, 0, ACCESS
111A  3233     RRCF 0x33, F, ACCESS
111C  3232     RRCF __tmp_0, F, ACCESS
111E  90D8     BCF STATUS, 0, ACCESS
1120  3233     RRCF 0x33, F, ACCESS
1122  3232     RRCF __tmp_0, F, ACCESS
1124  C032     MOVFF __tmp_0, cnt_duty
1126  F060     NOP
1002:          				quantity_steps_accel = (100 - temp) >> 2; 	//вычисляем количество шагов приращения ШИМа
1128  CFDE     MOVFF POSTINC2, __tmp_0
112A  F032     NOP
112C  CFDD     MOVFF POSTDEC2, 0x33
112E  F033     NOP
1130  0E64     MOVLW 0x64
1132  80D8     BSF STATUS, 0, ACCESS
1134  5632     SUBFWB __tmp_0, F, ACCESS
1136  0E00     MOVLW 0x0
1138  5633     SUBFWB 0x33, F, ACCESS
113A  90D8     BCF STATUS, 0, ACCESS
113C  3233     RRCF 0x33, F, ACCESS
113E  3232     RRCF __tmp_0, F, ACCESS
1140  90D8     BCF STATUS, 0, ACCESS
1142  3233     RRCF 0x33, F, ACCESS
1144  3232     RRCF __tmp_0, F, ACCESS
1146  C032     MOVFF __tmp_0, 0x10C
1148  F10C     NOP
1003:          				
1004:          				//Получаем значение времени режима разгона двигателя
1005:          				temp = M_Mngm_Get_parameters_buffer()->menu_parameters.Motor[index].time_accel; 
114A  EC8E     CALL 0x151C, 0
114C  F00A     NOP
114E  CFF3     MOVFF PROD, FSR0
1150  FFE9     NOP
1152  CFF4     MOVFF PRODH, FSR0H
1154  FFEA     NOP
1156  CFE9     MOVFF FSR0, __tmp_0
1158  F032     NOP
115A  CFEA     MOVFF FSR0H, 0x33
115C  F033     NOP
115E  0EFE     MOVLW 0xFE
1160  50DB     MOVF PLUSW2, W, ACCESS
1162  0D04     MULLW 0x4
1164  5032     MOVF __tmp_0, W, ACCESS
1166  24F3     ADDWF PROD, W, ACCESS
1168  6EE9     MOVWF FSR0, ACCESS
116A  5033     MOVF 0x33, W, ACCESS
116C  20F4     ADDWFC PRODH, W, ACCESS
116E  6EEA     MOVWF FSR0H, ACCESS
1170  50EF     MOVF INDF0, W, ACCESS
1172  6EDE     MOVWF POSTINC2, ACCESS
1174  6ADD     CLRF POSTDEC2, ACCESS
1006:          				
1007:          				//Получаем количество шагов приращения ШИМа
1008:          				if(!quantity_steps_accel)			//для исключения обработки деления на ноль
1176  0101     MOVLB 0x1
1178  510C     MOVF 0xC, W, BANKED
117A  E10E     BNZ 0x1198
1009:          					delta_t_accel = temp * 10;		//переводим в реальные единицы в мс
117C  0E0A     MOVLW 0xA
117E  6E26     MOVWF 0x26, ACCESS
1180  6A27     CLRF 0x27, ACCESS
1182  CFDE     MOVFF POSTINC2, 0x2B
1184  F02B     NOP
1186  CFDD     MOVFF POSTDEC2, 0x2C
1188  F02C     NOP
118A  EC1F     CALL 0x4C3E, 0
118C  F026     NOP
118E  C024     MOVFF 0x24, 0x10D
1190  F10D     NOP
1192  C025     MOVFF 0x25, 0x10E
1194  F10E     NOP
1010:          				else
1196  D020     BRA 0x11D8
1011:          					delta_t_accel = (temp * 10) / quantity_steps_accel;
1198  0101     MOVLB 0x1
119A  510C     MOVF 0xC, W, BANKED
119C  6E34     MOVWF 0x34, ACCESS
119E  6A35     CLRF 0x35, ACCESS
11A0  CFDE     MOVFF POSTINC2, __tmp_0
11A2  F032     NOP
11A4  CFDD     MOVFF POSTDEC2, 0x33
11A6  F033     NOP
11A8  0E0A     MOVLW 0xA
11AA  0233     MULWF 0x33, ACCESS
11AC  CFF3     MOVFF PROD, 0x33
11AE  F033     NOP
11B0  0E0A     MOVLW 0xA
11B2  0232     MULWF __tmp_0, ACCESS
11B4  CFF3     MOVFF PROD, __tmp_0
11B6  F032     NOP
11B8  50F4     MOVF PRODH, W, ACCESS
11BA  2633     ADDWF 0x33, F, ACCESS
11BC  C032     MOVFF __tmp_0, 0x26
11BE  F026     NOP
11C0  C033     MOVFF 0x33, 0x27
11C2  F027     NOP
11C4  C034     MOVFF 0x34, 0x2B
11C6  F02B     NOP
11C8  C035     MOVFF 0x35, 0x2C
11CA  F02C     NOP
11CC  ECA2     CALL 0x4D44, 0
11CE  F026     NOP
11D0  C026     MOVFF 0x26, 0x10D
11D2  F10D     NOP
11D4  C027     MOVFF 0x27, 0x10E
11D6  F10E     NOP
1012:          				accel_state++; 	//переход к разгону 
11D8  0100     MOVLB 0x0
11DA  2B61     INCF accel_state, F, BANKED
1013:          				saved_cnt_duty = cnt_duty;
11DC  C060     MOVFF cnt_duty, saved_cnt_duty
11DE  F062     NOP
1014:          				M_Motor_Timer2_change(TIMER2_INIT_VALUE, ENABLE_TMR2_INTR);
11E0  0E02     MOVLW 0x2
11E2  6EE6     MOVWF POSTINC1, ACCESS
11E4  0E0D     MOVLW 0xD
11E6  6EE6     MOVWF POSTINC1, ACCESS
11E8  DF4F     RCALL M_Motor_Timer2_change
11EA  52E5     MOVF POSTDEC1, F, ACCESS
11EC  52E5     MOVF POSTDEC1, F, ACCESS
1015:          			}
1016:          			break;
11EE  D024     BRA 0x1238
1017:          		case ACCELERATION:	//реализация плавного разгона
1018:          			if(quantity_steps_accel  > 0U)
11F0  0101     MOVLB 0x1
11F2  510C     MOVF 0xC, W, BANKED
11F4  0800     SUBLW 0x0
11F6  E218     BC 0x1228
1019:          			{
1020:          				//Отсчёт времени приращения 
1021:          				if(time_M_Motor.time_step_accel++ < delta_t_accel)
11F8  0100     MOVLB 0x0
11FA  C07B     MOVFF time_M_Motor, __tmp_0
11FC  F032     NOP
11FE  C07C     MOVFF 0x7C, 0x33
1200  F033     NOP
1202  2B7B     INCF time_M_Motor, F, BANKED
1204  0E00     MOVLW 0x0
1206  237C     ADDWFC 0x7C, F, BANKED
1208  0101     MOVLB 0x1
120A  510D     MOVF 0xD, W, BANKED
120C  5C32     SUBWF __tmp_0, W, ACCESS
120E  510E     MOVF 0xE, W, BANKED
1210  5833     SUBWFB 0x33, W, ACCESS
1212  E202     BC 0x1218
1022:          					break;		
1214  D011     BRA 0x1238
1023:          				else //если интервал отсчёта времени приращения окончен, установить следующий уровень ШИМа 
1216  D007     BRA 0x1226
1024:          				{
1025:          					time_M_Motor.time_step_accel = 0;
1218  0100     MOVLB 0x0
121A  6B7B     CLRF time_M_Motor, BANKED
121C  6B7C     CLRF 0x7C, BANKED
1026:          					quantity_steps_accel--;
121E  0101     MOVLB 0x1
1220  070C     DECF 0xC, F, BANKED
1027:          					cnt_duty++;
1222  0100     MOVLB 0x0
1224  2B60     INCF cnt_duty, F, BANKED
1028:          				}
1029:          			}
1030:          			else //переход к следующему состоянию автомата состояний
1226  D007     BRA 0x1236
1031:          			{
1032:          				M_Motor_Timer2_change(TIMER2_OFF_VALUE, DISABLE_TMR2_INTR); //по окончании разгона отключить таймер 2
1228  6AE6     CLRF POSTINC1, ACCESS
122A  6AE6     CLRF POSTINC1, ACCESS
122C  DF2D     RCALL M_Motor_Timer2_change
122E  52E5     MOVF POSTDEC1, F, ACCESS
1230  52E5     MOVF POSTDEC1, F, ACCESS
1033:          				accel_state++;   //MOTOR_IS_ACCELERATED
1232  0100     MOVLB 0x0
1234  2B61     INCF accel_state, F, BANKED
1034:          			}
1035:          			break;
1236  D000     BRA 0x1238
1036:          			
1037:          	}
1038:          }
1238  0E02     MOVLW 0x2
123A  5CE1     SUBWF FSR1, W, ACCESS
123C  E202     BC 0x1242
123E  6AE1     CLRF FSR1, ACCESS
1240  52E5     MOVF POSTDEC1, F, ACCESS
1242  6EE1     MOVWF FSR1, ACCESS
1244  52E5     MOVF POSTDEC1, F, ACCESS
1246  CFE7     MOVFF INDF1, FSR2
1248  FFD9     NOP
124A  0012     RETURN 0
1039:          
1040:          /* Реализация в прерывании от т/с2 программного ШИМ частотой примерно 500 Гц */
1041:          void M_Motor_software_PWM_interrrupt(const rom IOport_motor* motor_pins)
124C  CFD9     MOVFF FSR2, POSTINC1
124E  FFE6     NOP
1250  CFE1     MOVFF FSR1, FSR2
1252  FFD9     NOP
1042:          {
1043:          	if(M_LI_Get_Limit_Switches()->ls_hopper_cover_state)
1254  ECBD     CALL 0x3B7A, 0
1256  F01D     NOP
1258  CFF3     MOVFF PROD, FSR0
125A  FFE9     NOP
125C  CFF4     MOVFF PRODH, FSR0H
125E  FFEA     NOP
1260  0E06     MOVLW 0x6
1262  26E9     ADDWF FSR0, F, ACCESS
1264  0E00     MOVLW 0x0
1266  22EA     ADDWFC FSR0H, F, ACCESS
1268  50EF     MOVF INDF0, W, ACCESS
126A  E101     BNZ 0x126E
126C  D081     BRA 0x1370
1044:          	{
1045:          		*motor_pins->portReg_sec_half_bridge |= 1 <<( motor_pins->pin_num_sec_half_bridge); 	//включить нижний ключ. который не "ШИМит" (в диагонали моста)
126E  0EFD     MOVLW 0xFD
1270  CFDB     MOVFF PLUSW2, TBLPTR
1272  FFF6     NOP
1274  0EFE     MOVLW 0xFE
1276  CFDB     MOVFF PLUSW2, TBLPTRH
1278  FFF7     NOP
127A  0E05     MOVLW 0x5
127C  26F6     ADDWF TBLPTR, F, ACCESS
127E  0E00     MOVLW 0x0
1280  22F7     ADDWFC TBLPTRH, F, ACCESS
1282  0008     TBLRD*
1284  50F5     MOVF TABLAT, W, ACCESS
1286  6E33     MOVWF 0x33, ACCESS
1288  0E01     MOVLW 0x1
128A  5233     MOVF 0x33, F, ACCESS
128C  E004     BZ 0x1296
128E  46E8     RLNCF WREG, F, ACCESS
1290  0BFE     ANDLW 0xFE
1292  0633     DECF 0x33, F, ACCESS
1294  E1FC     BNZ 0x128E
1296  6E32     MOVWF __tmp_0, ACCESS
1298  0EFD     MOVLW 0xFD
129A  CFDB     MOVFF PLUSW2, TBLPTR
129C  FFF6     NOP
129E  0EFE     MOVLW 0xFE
12A0  CFDB     MOVFF PLUSW2, TBLPTRH
12A2  FFF7     NOP
12A4  0E03     MOVLW 0x3
12A6  26F6     ADDWF TBLPTR, F, ACCESS
12A8  0E00     MOVLW 0x0
12AA  22F7     ADDWFC TBLPTRH, F, ACCESS
12AC  0009     TBLRD*+
12AE  CFF5     MOVFF TABLAT, FSR0
12B0  FFE9     NOP
12B2  0008     TBLRD*
12B4  CFF5     MOVFF TABLAT, FSR0H
12B6  FFEA     NOP
12B8  5032     MOVF __tmp_0, W, ACCESS
12BA  12EF     IORWF INDF0, F, ACCESS
1046:          		if(M_Motor_PWM_period++ < PWM_PERIOD) //если период ШИМа ещё не прошёл
12BC  0100     MOVLB 0x0
12BE  5163     MOVF M_Motor_PWM_period, W, BANKED
12C0  2B63     INCF M_Motor_PWM_period, F, BANKED
12C2  6E32     MOVWF __tmp_0, ACCESS
12C4  0E19     MOVLW 0x19
12C6  5C32     SUBWF __tmp_0, W, ACCESS
12C8  E24E     BC 0x1366
1047:          		{
1048:          			if(!saved_cnt_duty) //выключить ШИМ, если длительность окончена
12CA  0100     MOVLB 0x0
12CC  5162     MOVF saved_cnt_duty, W, BANKED
12CE  E125     BNZ 0x131A
1049:          				*motor_pins->portReg_prim_half_bridge &= ~(1 << (motor_pins->pin_num_prim_half_bridge));
12D0  0EFD     MOVLW 0xFD
12D2  CFDB     MOVFF PLUSW2, TBLPTR
12D4  FFF6     NOP
12D6  0EFE     MOVLW 0xFE
12D8  CFDB     MOVFF PLUSW2, TBLPTRH
12DA  FFF7     NOP
12DC  0E02     MOVLW 0x2
12DE  26F6     ADDWF TBLPTR, F, ACCESS
12E0  0E00     MOVLW 0x0
12E2  22F7     ADDWFC TBLPTRH, F, ACCESS
12E4  0008     TBLRD*
12E6  50F5     MOVF TABLAT, W, ACCESS
12E8  6E33     MOVWF 0x33, ACCESS
12EA  0E01     MOVLW 0x1
12EC  5233     MOVF 0x33, F, ACCESS
12EE  E004     BZ 0x12F8
12F0  46E8     RLNCF WREG, F, ACCESS
12F2  0BFE     ANDLW 0xFE
12F4  0633     DECF 0x33, F, ACCESS
12F6  E1FC     BNZ 0x12F0
12F8  1CE8     COMF WREG, W, ACCESS
12FA  6E32     MOVWF __tmp_0, ACCESS
12FC  0EFD     MOVLW 0xFD
12FE  CFDB     MOVFF PLUSW2, TBLPTR
1300  FFF6     NOP
1302  0EFE     MOVLW 0xFE
1304  CFDB     MOVFF PLUSW2, TBLPTRH
1306  FFF7     NOP
1308  0009     TBLRD*+
130A  CFF5     MOVFF TABLAT, FSR0
130C  FFE9     NOP
130E  0008     TBLRD*
1310  CFF5     MOVFF TABLAT, FSR0H
1312  FFEA     NOP
1314  5032     MOVF __tmp_0, W, ACCESS
1316  16EF     ANDWF INDF0, F, ACCESS
1050:          			else				//включить ШИМ и декрементировать значение длительности
1318  D025     BRA 0x1364
1051:          			{
1052:          				saved_cnt_duty--; 
131A  0100     MOVLB 0x0
131C  0762     DECF saved_cnt_duty, F, BANKED
1053:          				*motor_pins->portReg_prim_half_bridge |= 1 << (motor_pins->pin_num_prim_half_bridge);
131E  0EFD     MOVLW 0xFD
1320  CFDB     MOVFF PLUSW2, TBLPTR
1322  FFF6     NOP
1324  0EFE     MOVLW 0xFE
1326  CFDB     MOVFF PLUSW2, TBLPTRH
1328  FFF7     NOP
132A  0E02     MOVLW 0x2
132C  26F6     ADDWF TBLPTR, F, ACCESS
132E  0E00     MOVLW 0x0
1330  22F7     ADDWFC TBLPTRH, F, ACCESS
1332  0008     TBLRD*
1334  50F5     MOVF TABLAT, W, ACCESS
1336  6E33     MOVWF 0x33, ACCESS
1338  0E01     MOVLW 0x1
133A  5233     MOVF 0x33, F, ACCESS
133C  E004     BZ 0x1346
133E  46E8     RLNCF WREG, F, ACCESS
1340  0BFE     ANDLW 0xFE
1342  0633     DECF 0x33, F, ACCESS
1344  E1FC     BNZ 0x133E
1346  6E32     MOVWF __tmp_0, ACCESS
1348  0EFD     MOVLW 0xFD
134A  CFDB     MOVFF PLUSW2, TBLPTR
134C  FFF6     NOP
134E  0EFE     MOVLW 0xFE
1350  CFDB     MOVFF PLUSW2, TBLPTRH
1352  FFF7     NOP
1354  0009     TBLRD*+
1356  CFF5     MOVFF TABLAT, FSR0
1358  FFE9     NOP
135A  0008     TBLRD*
135C  CFF5     MOVFF TABLAT, FSR0H
135E  FFEA     NOP
1360  5032     MOVF __tmp_0, W, ACCESS
1362  12EF     IORWF INDF0, F, ACCESS
1054:          			}
1055:          		}	
1056:          		else //период ШИМа окончен, перезаписать значение длительности и обнулить счётчик времени периода
1364  D004     BRA 0x136E
1057:          		{
1058:          			saved_cnt_duty = cnt_duty;  
1366  C060     MOVFF cnt_duty, saved_cnt_duty
1368  F062     NOP
1059:          			M_Motor_PWM_period = 0;
136A  0100     MOVLB 0x0
136C  6B63     CLRF M_Motor_PWM_period, BANKED
1060:          		}
1061:          	}	
1062:          	else
136E  D04C     BRA 0x1408
1063:          	{
1064:          		*motor_pins->portReg_prim_half_bridge &= ~(1 << (motor_pins->pin_num_prim_half_bridge));	
1370  0EFD     MOVLW 0xFD
1372  CFDB     MOVFF PLUSW2, TBLPTR
1374  FFF6     NOP
1376  0EFE     MOVLW 0xFE
1378  CFDB     MOVFF PLUSW2, TBLPTRH
137A  FFF7     NOP
137C  0E02     MOVLW 0x2
137E  26F6     ADDWF TBLPTR, F, ACCESS
1380  0E00     MOVLW 0x0
1382  22F7     ADDWFC TBLPTRH, F, ACCESS
1384  0008     TBLRD*
1386  50F5     MOVF TABLAT, W, ACCESS
1388  6E33     MOVWF 0x33, ACCESS
138A  0E01     MOVLW 0x1
138C  5233     MOVF 0x33, F, ACCESS
138E  E004     BZ 0x1398
1390  46E8     RLNCF WREG, F, ACCESS
1392  0BFE     ANDLW 0xFE
1394  0633     DECF 0x33, F, ACCESS
1396  E1FC     BNZ 0x1390
1398  1CE8     COMF WREG, W, ACCESS
139A  6E32     MOVWF __tmp_0, ACCESS
139C  0EFD     MOVLW 0xFD
139E  CFDB     MOVFF PLUSW2, TBLPTR
13A0  FFF6     NOP
13A2  0EFE     MOVLW 0xFE
13A4  CFDB     MOVFF PLUSW2, TBLPTRH
13A6  FFF7     NOP
13A8  0009     TBLRD*+
13AA  CFF5     MOVFF TABLAT, FSR0
13AC  FFE9     NOP
13AE  0008     TBLRD*
13B0  CFF5     MOVFF TABLAT, FSR0H
13B2  FFEA     NOP
13B4  5032     MOVF __tmp_0, W, ACCESS
13B6  16EF     ANDWF INDF0, F, ACCESS
1065:          		*motor_pins->portReg_sec_half_bridge &= ~(1 << (motor_pins->pin_num_sec_half_bridge));
13B8  0EFD     MOVLW 0xFD
13BA  CFDB     MOVFF PLUSW2, TBLPTR
13BC  FFF6     NOP
13BE  0EFE     MOVLW 0xFE
13C0  CFDB     MOVFF PLUSW2, TBLPTRH
13C2  FFF7     NOP
13C4  0E05     MOVLW 0x5
13C6  26F6     ADDWF TBLPTR, F, ACCESS
13C8  0E00     MOVLW 0x0
13CA  22F7     ADDWFC TBLPTRH, F, ACCESS
13CC  0008     TBLRD*
13CE  50F5     MOVF TABLAT, W, ACCESS
13D0  6E33     MOVWF 0x33, ACCESS
13D2  0E01     MOVLW 0x1
13D4  5233     MOVF 0x33, F, ACCESS
13D6  E004     BZ 0x13E0
13D8  46E8     RLNCF WREG, F, ACCESS
13DA  0BFE     ANDLW 0xFE
13DC  0633     DECF 0x33, F, ACCESS
13DE  E1FC     BNZ 0x13D8
13E0  1CE8     COMF WREG, W, ACCESS
13E2  6E32     MOVWF __tmp_0, ACCESS
13E4  0EFD     MOVLW 0xFD
13E6  CFDB     MOVFF PLUSW2, TBLPTR
13E8  FFF6     NOP
13EA  0EFE     MOVLW 0xFE
13EC  CFDB     MOVFF PLUSW2, TBLPTRH
13EE  FFF7     NOP
13F0  0E03     MOVLW 0x3
13F2  26F6     ADDWF TBLPTR, F, ACCESS
13F4  0E00     MOVLW 0x0
13F6  22F7     ADDWFC TBLPTRH, F, ACCESS
13F8  0009     TBLRD*+
13FA  CFF5     MOVFF TABLAT, FSR0
13FC  FFE9     NOP
13FE  0008     TBLRD*
1400  CFF5     MOVFF TABLAT, FSR0H
1402  FFEA     NOP
1404  5032     MOVF __tmp_0, W, ACCESS
1406  16EF     ANDWF INDF0, F, ACCESS
1066:          	}
1067:          
1068:          }
1408  52E5     MOVF POSTDEC1, F, ACCESS
140A  CFE7     MOVFF INDF1, FSR2
140C  FFD9     NOP
140E  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_management/module_management.c  -----------
1:             #include "stdint.h"
2:             #include "module_management.h"
3:             #include "module_analog_inputs.h"
4:             #include "module_indication.h"
5:             #include "module_logic_inputs.h"
6:             #include "module_motor.h"
7:             #include "module_fan.h"
8:             #include "menu.h"
9:             #include <p18cxxx.h>
10:            #include "main.h"
11:            #include "eeprom.h"
12:            
13:            #define TIMEOUT_TASK_MANAGEMENT	100
14:            
15:            
16:            uint8_t M_Mngm_State = 0;
17:            uint8_t M_Mngm_Code_Failure = 0;
18:            uint8_t M_Mngm_Previous_State = 0;
19:            uint8_t burning_state =  CALC_PARAMS_PERIOD;
20:            uint16_t timeout_supply_fuel = 0;
21:            uint16_t timeout_check_gas_sensor = 0;
22:            uint8_t saved_temperature_water;
23:            uint16_t timeout_change_temperature_water = 0;
24:            ParametersBuffer M_Mngm_parameters_buffer;
25:            BOOL M_Mngm_state_draught = IS_DRAUGHT;
26:            uint16_t period_load_fuel;
27:            uint16_t timeout;
28:            uint8_t state_accel_fan = CALCULATE;
29:            BOOL phase_cycle = PAUSE_IN_CYCLE;
30:            uint8_t fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_INCREASE;
31:            uint8_t* pFanLevel = 0;
32:            uint8_t level;
33:            
34:            uint8_t M_Mngm_get_fanParamOffset(void)
35:            {
36:            	return fan_param_offset;
1410  0100     MOVLB 0x0
1412  51D8     MOVF fan_param_offset, W, BANKED
1414  D000     BRA 0x1416
37:            } 
1416  0012     RETURN 0
38:            
39:            uint8_t* M_Mngm_get_pFanLevel(void)
40:            {
41:            	return pFanLevel;
1418  C0D9     MOVFF pFanLevel, PROD
141A  FFF3     NOP
141C  C0DA     MOVFF 0xDA, PRODH
141E  FFF4     NOP
1420  D000     BRA 0x1422
42:            }
1422  0012     RETURN 0
43:            
44:            
45:            BOOL M_Mngm_get_phase_cycle(void)
46:            {
47:            	return phase_cycle;
1424  0100     MOVLB 0x0
1426  51D7     MOVF phase_cycle, W, BANKED
1428  D000     BRA 0x142A
48:            }
142A  0012     RETURN 0
49:            
50:            
51:            /*
52:            Проверка изменения температуры воды по истечении заданного таймаута  TIMEOUT_CHECK_CHANGE_TEMPERATURE_WATER (пока 10 минут)
53:            если температура уменьшилась - переход в состояние ожидания. Далее пользователь либо подкидывает топливо в бункер, либо уменьшает 
54:            в меню период загрузок топлива
55:            Возвращает 
56:            1 - если температура уменьшилась
57:            0 - если не уменьшилась и ли увеличилась
58:            */
59:            BOOL M_Mngm_check_change_temperature_water(void)
60:            {
61:            	if(burning_state == INCREASE_TEMPERATURE || burning_state == MAINTENANCE_TEMPERATURE_INCR)
142C  0E02     MOVLW 0x2
142E  0100     MOVLB 0x0
1430  5DCE     SUBWF burning_state, W, BANKED
1432  E004     BZ 0x143C
1434  0E05     MOVLW 0x5
1436  0100     MOVLB 0x0
1438  5DCE     SUBWF burning_state, W, BANKED
143A  E142     BNZ 0x14C0
62:            	{
63:            		if(M_Motor_get_state() == STATE_MODULE_MOTOR_WAITING)	//при работе алгоритма засыпки timeout_change_temperature_water считается после окончания засыпки	
143C  EC1E     CALL 0x23C, 0
143E  F001     NOP
1440  0801     SUBLW 0x1
1442  E13B     BNZ 0x14BA
64:            		{
65:            			if(timeout_change_temperature_water++ >= TIMEOUT_CHECK_CHANGE_TEMPERATURE_WATER )
1444  0100     MOVLB 0x0
1446  C0D3     MOVFF timeout_change_temperature_water, __tmp_0
1448  F032     NOP
144A  C0D4     MOVFF 0xD4, 0x33
144C  F033     NOP
144E  2BD3     INCF timeout_change_temperature_water, F, BANKED
1450  0E00     MOVLW 0x0
1452  23D4     ADDWFC 0xD4, F, BANKED
1454  0E50     MOVLW 0x50
1456  5C32     SUBWF __tmp_0, W, ACCESS
1458  0E46     MOVLW 0x46
145A  5833     SUBWFB 0x33, W, ACCESS
145C  E32B     BNC 0x14B4
66:            			{
67:            				timeout_change_temperature_water = 0;	
145E  0100     MOVLB 0x0
1460  6BD3     CLRF timeout_change_temperature_water, BANKED
1462  6BD4     CLRF 0xD4, BANKED
68:            				if(M_AI_Get_ADC_Data(CHN_T_WATER)->param < saved_temperature_water)  //если температура уменьшилась
1464  0E01     MOVLW 0x1
1466  6EE6     MOVWF POSTINC1, ACCESS
1468  EC3C     CALL 0x3478, 0
146A  F01A     NOP
146C  52E5     MOVF POSTDEC1, F, ACCESS
146E  CFF3     MOVFF PROD, FSR0
1470  FFE9     NOP
1472  CFF4     MOVFF PRODH, FSR0H
1474  FFEA     NOP
1476  0E05     MOVLW 0x5
1478  26E9     ADDWF FSR0, F, ACCESS
147A  0E00     MOVLW 0x0
147C  22EA     ADDWFC FSR0H, F, ACCESS
147E  CFEF     MOVFF INDF0, __tmp_0
1480  F032     NOP
1482  010F     MOVLB 0xF
1484  5100     MOVF _OS_BestTask, W, BANKED
1486  5C32     SUBWF __tmp_0, W, ACCESS
1488  E203     BC 0x1490
69:            				{
70:            					return TEMPERATURE_DECREASED;
148A  0E01     MOVLW 0x1
148C  D01E     BRA 0x14CA
71:            				}
72:            				else
148E  D011     BRA 0x14B2
73:            				{
74:            					 //если температура выросла или не изменилась, перезаписать её новое значение
75:            					saved_temperature_water = M_AI_Get_ADC_Data(CHN_T_WATER)->param; 
1490  0E01     MOVLW 0x1
1492  6EE6     MOVWF POSTINC1, ACCESS
1494  EC3C     CALL 0x3478, 0
1496  F01A     NOP
1498  52E5     MOVF POSTDEC1, F, ACCESS
149A  CFF3     MOVFF PROD, FSR0
149C  FFE9     NOP
149E  CFF4     MOVFF PRODH, FSR0H
14A0  FFEA     NOP
14A2  0E05     MOVLW 0x5
14A4  26E9     ADDWF FSR0, F, ACCESS
14A6  0E00     MOVLW 0x0
14A8  22EA     ADDWFC FSR0H, F, ACCESS
14AA  CFEF     MOVFF INDF0, saved_temperature_water
14AC  FF00     NOP
76:            					return TEMPERATURE_INCREASED_OR_EQUAL;
14AE  0E00     MOVLW 0x0
14B0  D00C     BRA 0x14CA
77:            				}
78:            			}
79:            			else
14B2  D002     BRA 0x14B8
80:            			{
81:            				return TEMPERATURE_INCREASED_OR_EQUAL;
14B4  0E00     MOVLW 0x0
14B6  D009     BRA 0x14CA
82:            			}
83:            		}
84:            		else
14B8  D002     BRA 0x14BE
85:            		{
86:            			return TEMPERATURE_INCREASED_OR_EQUAL;	
14BA  0E00     MOVLW 0x0
14BC  D006     BRA 0x14CA
87:            		}
88:            	}
89:            	else
14BE  D005     BRA 0x14CA
90:            	{
91:            		timeout_change_temperature_water = 0;
14C0  0100     MOVLB 0x0
14C2  6BD3     CLRF timeout_change_temperature_water, BANKED
14C4  6BD4     CLRF 0xD4, BANKED
92:            		return TEMPERATURE_INCREASED_OR_EQUAL;
14C6  0E00     MOVLW 0x0
14C8  D000     BRA 0x14CA
93:            	}
94:            }
14CA  0012     RETURN 0
95:            
96:            void M_Mngm_set_saved_temperature_water(uint8_t value)
14CC  CFD9     MOVFF FSR2, POSTINC1
14CE  FFE6     NOP
14D0  CFE1     MOVFF FSR1, FSR2
14D2  FFD9     NOP
97:            {
98:            	saved_temperature_water = value;	
14D4  0EFE     MOVLW 0xFE
14D6  CFDB     MOVFF PLUSW2, saved_temperature_water
14D8  FF00     NOP
99:            }
14DA  52E5     MOVF POSTDEC1, F, ACCESS
14DC  CFE7     MOVFF INDF1, FSR2
14DE  FFD9     NOP
14E0  0012     RETURN 0
100:           
101:           
102:           void M_Mngm_clear_timeouts(void)
103:           {
104:           	timeout_supply_fuel = timeout_check_gas_sensor = /*burning_state = */timeout_change_temperature_water = timeout = 0;
14E2  0E00     MOVLW 0x0
14E4  010F     MOVLB 0xF
14E6  6F38     MOVWF 0x38, BANKED
14E8  6B39     CLRF 0x39, BANKED
14EA  0100     MOVLB 0x0
14EC  6FD3     MOVWF timeout_change_temperature_water, BANKED
14EE  6BD4     CLRF 0xD4, BANKED
14F0  0100     MOVLB 0x0
14F2  6FD1     MOVWF timeout_check_gas_sensor, BANKED
14F4  6BD2     CLRF 0xD2, BANKED
14F6  0100     MOVLB 0x0
14F8  6FCF     MOVWF timeout_supply_fuel, BANKED
14FA  6BD0     CLRF 0xD0, BANKED
105:           }
14FC  0012     RETURN 0
106:           
107:           uint8_t M_Mngm_get_burning_state(void)
108:           {
109:           	return burning_state;
14FE  0100     MOVLB 0x0
1500  51CE     MOVF burning_state, W, BANKED
1502  D000     BRA 0x1504
110:           }
1504  0012     RETURN 0
111:           
112:           void M_Mngm_set_burning_state(uint8_t value)
1506  CFD9     MOVFF FSR2, POSTINC1
1508  FFE6     NOP
150A  CFE1     MOVFF FSR1, FSR2
150C  FFD9     NOP
113:           {
114:           	burning_state = value;
150E  0EFE     MOVLW 0xFE
1510  CFDB     MOVFF PLUSW2, burning_state
1512  F0CE     NOP
115:           }
1514  52E5     MOVF POSTDEC1, F, ACCESS
1516  CFE7     MOVFF INDF1, FSR2
1518  FFD9     NOP
151A  0012     RETURN 0
116:           
117:           
118:           ParametersBuffer* M_Mngm_Get_parameters_buffer(void)
119:           {
120:           	return &M_Mngm_parameters_buffer;
151C  0E01     MOVLW 0x1
151E  6E32     MOVWF __tmp_0, ACCESS
1520  0E0F     MOVLW 0xF
1522  6E33     MOVWF 0x33, ACCESS
1524  C032     MOVFF __tmp_0, PROD
1526  FFF3     NOP
1528  C033     MOVFF 0x33, PRODH
152A  FFF4     NOP
152C  D000     BRA 0x152E
121:           }
152E  0012     RETURN 0
122:           
123:           void M_Mngm_Set_state(uint8_t value)
1530  CFD9     MOVFF FSR2, POSTINC1
1532  FFE6     NOP
1534  CFE1     MOVFF FSR1, FSR2
1536  FFD9     NOP
124:           {
125:           	M_Mngm_State = value;
1538  0EFE     MOVLW 0xFE
153A  CFDB     MOVFF PLUSW2, M_Mngm_State
153C  F0CB     NOP
126:           }
153E  52E5     MOVF POSTDEC1, F, ACCESS
1540  CFE7     MOVFF INDF1, FSR2
1542  FFD9     NOP
1544  0012     RETURN 0
127:           
128:           uint8_t M_Mngm_Get_previous_state(void)
129:           {
130:           	return M_Mngm_Previous_State;
1546  0100     MOVLB 0x0
1548  51CD     MOVF M_Mngm_Previous_State, W, BANKED
154A  D000     BRA 0x154C
131:           }
154C  0012     RETURN 0
132:           
133:           uint8_t M_Mngm_Get_state(void)
134:           {
135:           	return M_Mngm_State;
154E  0100     MOVLB 0x0
1550  51CB     MOVF M_Mngm_State, W, BANKED
1552  D000     BRA 0x1554
136:           }
1554  0012     RETURN 0
137:           
138:           uint8_t M_Mngm_Get_Code_Failure(void)
139:           {
140:           	return M_Mngm_Code_Failure;
1556  0100     MOVLB 0x0
1558  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
155A  D000     BRA 0x155C
141:           }
155C  0012     RETURN 0
142:           
143:           void M_Mngm_Set_Code_Failure(uint8_t value)
155E  CFD9     MOVFF FSR2, POSTINC1
1560  FFE6     NOP
1562  CFE1     MOVFF FSR1, FSR2
1564  FFD9     NOP
144:           {
145:           	M_Mngm_Code_Failure = value;	
1566  0EFE     MOVLW 0xFE
1568  CFDB     MOVFF PLUSW2, M_Mngm_Code_Failure
156A  F0CC     NOP
146:           }
156C  52E5     MOVF POSTDEC1, F, ACCESS
156E  CFE7     MOVFF INDF1, FSR2
1570  FFD9     NOP
1572  0012     RETURN 0
147:           
148:           void M_Mngm_Set_state_draught(BOOL value)
1574  CFD9     MOVFF FSR2, POSTINC1
1576  FFE6     NOP
1578  CFE1     MOVFF FSR1, FSR2
157A  FFD9     NOP
149:           {
150:           	M_Mngm_state_draught = value;
157C  0EFE     MOVLW 0xFE
157E  CFDB     MOVFF PLUSW2, M_Mngm_state_draught
1580  F0D5     NOP
151:           }
1582  52E5     MOVF POSTDEC1, F, ACCESS
1584  CFE7     MOVFF INDF1, FSR2
1586  FFD9     NOP
1588  0012     RETURN 0
152:           
153:           
154:           /* 
155:           Функция проверки аварии тяги (по критерию: через 10 минут после начала процесса горения 
156:           температура исходящего газа менее 60 градусов) 
157:           */
158:           void  M_Mngm_check_draught_failure(void)
159:           {
160:           	 if(M_Motor_get_state() == STATE_MODULE_MOTOR_WAITING)
158A  EC1E     CALL 0x23C, 0
158C  F001     NOP
158E  0801     SUBLW 0x1
1590  E128     BNZ 0x15E2
161:           	{
162:           		if(timeout_check_gas_sensor++ == TIMEOUT_CHECK_FAILURE_DRAUGHT)
1592  0100     MOVLB 0x0
1594  C0D1     MOVFF timeout_check_gas_sensor, __tmp_0
1596  F032     NOP
1598  C0D2     MOVFF 0xD2, 0x33
159A  F033     NOP
159C  2BD1     INCF timeout_check_gas_sensor, F, BANKED
159E  0E00     MOVLW 0x0
15A0  23D2     ADDWFC 0xD2, F, BANKED
15A2  0E70     MOVLW 0x70
15A4  1832     XORWF __tmp_0, W, ACCESS
15A6  E102     BNZ 0x15AC
15A8  0E17     MOVLW 0x17
15AA  1833     XORWF 0x33, W, ACCESS
15AC  E11A     BNZ 0x15E2
163:           		{
164:           			timeout_check_gas_sensor = 0;	
15AE  0100     MOVLB 0x0
15B0  6BD1     CLRF timeout_check_gas_sensor, BANKED
15B2  6BD2     CLRF 0xD2, BANKED
165:           			if(M_AI_Get_ADC_Data(CHN_T_GAS)->param < LOW_THRESHOLD_IN_BURNING_TEMPER_GAS)
15B4  6AE6     CLRF POSTINC1, ACCESS
15B6  EC3C     CALL 0x3478, 0
15B8  F01A     NOP
15BA  52E5     MOVF POSTDEC1, F, ACCESS
15BC  CFF3     MOVFF PROD, FSR0
15BE  FFE9     NOP
15C0  CFF4     MOVFF PRODH, FSR0H
15C2  FFEA     NOP
15C4  0E05     MOVLW 0x5
15C6  26E9     ADDWF FSR0, F, ACCESS
15C8  0E00     MOVLW 0x0
15CA  22EA     ADDWFC FSR0H, F, ACCESS
15CC  CFEF     MOVFF INDF0, __tmp_0
15CE  F032     NOP
15D0  0E06     MOVLW 0x6
15D2  5C32     SUBWF __tmp_0, W, ACCESS
15D4  E206     BC 0x15E2
166:           			{
167:           				M_Mngm_state_draught = NO_DRAUGHT;
15D6  0100     MOVLB 0x0
15D8  6BD5     CLRF M_Mngm_state_draught, BANKED
168:           				M_fan_set_ctrl_fan(OFF);
15DA  6AE6     CLRF POSTINC1, ACCESS
15DC  ECE0     CALL 0x41C0, 0
15DE  F020     NOP
15E0  52E5     MOVF POSTDEC1, F, ACCESS
169:           			}
170:           		}
171:           	}
172:           }
15E2  0012     RETURN 0
173:           
174:           
175:           /*
176:           Функция проверки аварии
177:           Возвращает код аварии (0 - её отсутствие)
178:           */
179:           
180:           uint8_t M_Mngm_Check_Failure(void)
181:           {
182:           	if(M_Mngm_parameters_buffer.menu_parameters.code_failure == NO_FAILURE)
15E4  010F     MOVLB 0xF
15E6  5133     MOVF 0x33, W, BANKED
15E8  E001     BZ 0x15EC
15EA  D116     BRA 0x1818
183:           	{
184:           		
185:           		if(M_Mngm_state_draught == NO_DRAUGHT)		//авария тяги в дымоход
15EC  0100     MOVLB 0x0
15EE  51D5     MOVF M_Mngm_state_draught, W, BANKED
15F0  E102     BNZ 0x15F6
186:           		{	
187:           			return CODE_FAILURE_DRAUGHT; 	
15F2  0E10     MOVLW 0x10
15F4  D114     BRA 0x181E
188:           		}
189:           		if((M_AI_Get_ADC_Data(CHN_T_GAS)->param) == BREAK_SENSOR_VALUE) 				//обрыв датчика температуры газа
15F6  6AE6     CLRF POSTINC1, ACCESS
15F8  EC3C     CALL 0x3478, 0
15FA  F01A     NOP
15FC  52E5     MOVF POSTDEC1, F, ACCESS
15FE  CFF3     MOVFF PROD, FSR0
1600  FFE9     NOP
1602  CFF4     MOVFF PRODH, FSR0H
1604  FFEA     NOP
1606  0E05     MOVLW 0x5
1608  26E9     ADDWF FSR0, F, ACCESS
160A  0E00     MOVLW 0x0
160C  22EA     ADDWFC FSR0H, F, ACCESS
160E  50EF     MOVF INDF0, W, ACCESS
1610  08FA     SUBLW 0xFA
1612  E102     BNZ 0x1618
190:           		{
191:           			return CODE_FAILURE_BREAK_T_GAS_SENSOR;		
1614  0E01     MOVLW 0x1
1616  D103     BRA 0x181E
192:           		}	
193:           		 if((M_AI_Get_ADC_Data(CHN_T_GAS)->param) == SHORT_CIRCUIT_SENSOR_VALUE) 	//КЗ датчика температуры газа
1618  6AE6     CLRF POSTINC1, ACCESS
161A  EC3C     CALL 0x3478, 0
161C  F01A     NOP
161E  52E5     MOVF POSTDEC1, F, ACCESS
1620  CFF3     MOVFF PROD, FSR0
1622  FFE9     NOP
1624  CFF4     MOVFF PRODH, FSR0H
1626  FFEA     NOP
1628  0E05     MOVLW 0x5
162A  26E9     ADDWF FSR0, F, ACCESS
162C  0E00     MOVLW 0x0
162E  22EA     ADDWFC FSR0H, F, ACCESS
1630  50EF     MOVF INDF0, W, ACCESS
1632  08FB     SUBLW 0xFB
1634  E102     BNZ 0x163A
194:           		{
195:           			return  CODE_FAILURE_SHORT_CIRCUIT_T_GAS_SENSOR;	
1636  0E02     MOVLW 0x2
1638  D0F2     BRA 0x181E
196:           		}
197:           		if((M_AI_Get_ADC_Data(CHN_T_WATER)->param) == BREAK_SENSOR_VALUE) 			//обрыв датчика температуры воды
163A  0E01     MOVLW 0x1
163C  6EE6     MOVWF POSTINC1, ACCESS
163E  EC3C     CALL 0x3478, 0
1640  F01A     NOP
1642  52E5     MOVF POSTDEC1, F, ACCESS
1644  CFF3     MOVFF PROD, FSR0
1646  FFE9     NOP
1648  CFF4     MOVFF PRODH, FSR0H
164A  FFEA     NOP
164C  0E05     MOVLW 0x5
164E  26E9     ADDWF FSR0, F, ACCESS
1650  0E00     MOVLW 0x0
1652  22EA     ADDWFC FSR0H, F, ACCESS
1654  50EF     MOVF INDF0, W, ACCESS
1656  08FA     SUBLW 0xFA
1658  E102     BNZ 0x165E
198:           		{
199:           			return CODE_FAILURE_BREAK_T_WATER_SENSOR;		
165A  0E03     MOVLW 0x3
165C  D0E0     BRA 0x181E
200:           		}	
201:           		if((M_AI_Get_ADC_Data(CHN_T_WATER)->param) == SHORT_CIRCUIT_SENSOR_VALUE) 	//КЗ датчика температуры воды
165E  0E01     MOVLW 0x1
1660  6EE6     MOVWF POSTINC1, ACCESS
1662  EC3C     CALL 0x3478, 0
1664  F01A     NOP
1666  52E5     MOVF POSTDEC1, F, ACCESS
1668  CFF3     MOVFF PROD, FSR0
166A  FFE9     NOP
166C  CFF4     MOVFF PRODH, FSR0H
166E  FFEA     NOP
1670  0E05     MOVLW 0x5
1672  26E9     ADDWF FSR0, F, ACCESS
1674  0E00     MOVLW 0x0
1676  22EA     ADDWFC FSR0H, F, ACCESS
1678  50EF     MOVF INDF0, W, ACCESS
167A  08FB     SUBLW 0xFB
167C  E102     BNZ 0x1682
202:           		{
203:           			return CODE_FAILURE_SHORT_CIRCUIT_T_WATER_SENSOR;
167E  0E04     MOVLW 0x4
1680  D0CE     BRA 0x181E
204:           		} 
205:           		if(M_Motor_get_state_failure(INDEX_OF_AGITATOR)->is_failure)									//авария датчика ворошителя
1682  0E01     MOVLW 0x1
1684  6EE6     MOVWF POSTINC1, ACCESS
1686  EC31     CALL 0x262, 0
1688  F001     NOP
168A  52E5     MOVF POSTDEC1, F, ACCESS
168C  CFF3     MOVFF PROD, FSR0
168E  FFE9     NOP
1690  CFF4     MOVFF PRODH, FSR0H
1692  FFEA     NOP
1694  50EF     MOVF INDF0, W, ACCESS
1696  E00F     BZ 0x16B6
206:           		{
207:           			if(M_Motor_get_state_failure(INDEX_OF_AGITATOR)->type_ls == AGITATOR_LS)	
1698  0E01     MOVLW 0x1
169A  6EE6     MOVWF POSTINC1, ACCESS
169C  EC31     CALL 0x262, 0
169E  F001     NOP
16A0  52E5     MOVF POSTDEC1, F, ACCESS
16A2  CFF3     MOVFF PROD, FSR0
16A4  FFE9     NOP
16A6  CFF4     MOVFF PRODH, FSR0H
16A8  FFEA     NOP
16AA  52EE     MOVF POSTINC0, F, ACCESS
16AC  50EF     MOVF INDF0, W, ACCESS
16AE  0804     SUBLW 0x4
16B0  E102     BNZ 0x16B6
208:           				return CODE_FAILURE_MOTOR_LS_AGITATOR;
16B2  0E0F     MOVLW 0xF
16B4  D0B4     BRA 0x181E
209:           		}
210:           		if(M_Motor_get_state_failure(INDEX_OF_DISPENSER)->is_failure)
16B6  6AE6     CLRF POSTINC1, ACCESS
16B8  EC31     CALL 0x262, 0
16BA  F001     NOP
16BC  52E5     MOVF POSTDEC1, F, ACCESS
16BE  CFF3     MOVFF PROD, FSR0
16C0  FFE9     NOP
16C2  CFF4     MOVFF PRODH, FSR0H
16C4  FFEA     NOP
16C6  50EF     MOVF INDF0, W, ACCESS
16C8  E01B     BZ 0x1700
211:           		{
212:           			if(M_Motor_get_state_failure(INDEX_OF_DISPENSER)->type_ls == START_LS)				//авария стартового концевика дозатора	
16CA  6AE6     CLRF POSTINC1, ACCESS
16CC  EC31     CALL 0x262, 0
16CE  F001     NOP
16D0  52E5     MOVF POSTDEC1, F, ACCESS
16D2  CFF3     MOVFF PROD, FSR0
16D4  FFE9     NOP
16D6  CFF4     MOVFF PRODH, FSR0H
16D8  FFEA     NOP
16DA  52EE     MOVF POSTINC0, F, ACCESS
16DC  04EF     DECF INDF0, W, ACCESS
16DE  E102     BNZ 0x16E4
213:           				return CODE_FAILURE_MOTOR_LS_DISPENSER_START;
16E0  0E05     MOVLW 0x5
16E2  D09D     BRA 0x181E
214:           			if( M_Motor_get_state_failure( INDEX_OF_DISPENSER )->type_ls == FINISH_LS )				//авария финишного концевика дозатора
16E4  6AE6     CLRF POSTINC1, ACCESS
16E6  EC31     CALL 0x262, 0
16E8  F001     NOP
16EA  52E5     MOVF POSTDEC1, F, ACCESS
16EC  CFF3     MOVFF PROD, FSR0
16EE  FFE9     NOP
16F0  CFF4     MOVFF PRODH, FSR0H
16F2  FFEA     NOP
16F4  52EE     MOVF POSTINC0, F, ACCESS
16F6  50EF     MOVF INDF0, W, ACCESS
16F8  0802     SUBLW 0x2
16FA  E102     BNZ 0x1700
215:           				return CODE_FAILURE_MOTOR_LS_DISPENSER_FINISH;	
16FC  0E06     MOVLW 0x6
16FE  D08F     BRA 0x181E
216:           		}
217:           		if(M_Motor_get_state_failure( INDEX_OF_SHATTER )->is_failure)
1700  0E02     MOVLW 0x2
1702  6EE6     MOVWF POSTINC1, ACCESS
1704  EC31     CALL 0x262, 0
1706  F001     NOP
1708  52E5     MOVF POSTDEC1, F, ACCESS
170A  CFF3     MOVFF PROD, FSR0
170C  FFE9     NOP
170E  CFF4     MOVFF PRODH, FSR0H
1710  FFEA     NOP
1712  50EF     MOVF INDF0, W, ACCESS
1714  E02C     BZ 0x176E
218:           		{
219:           			if( M_Motor_get_state_failure(INDEX_OF_SHATTER)->type_ls == START_LS )				//авария стартового концевика заслонки
1716  0E02     MOVLW 0x2
1718  6EE6     MOVWF POSTINC1, ACCESS
171A  EC31     CALL 0x262, 0
171C  F001     NOP
171E  52E5     MOVF POSTDEC1, F, ACCESS
1720  CFF3     MOVFF PROD, FSR0
1722  FFE9     NOP
1724  CFF4     MOVFF PRODH, FSR0H
1726  FFEA     NOP
1728  52EE     MOVF POSTINC0, F, ACCESS
172A  04EF     DECF INDF0, W, ACCESS
172C  E102     BNZ 0x1732
220:           				return CODE_FAILURE_MOTOR_LS_SHATTER_START;
172E  0E07     MOVLW 0x7
1730  D076     BRA 0x181E
221:           			 if( M_Motor_get_state_failure(INDEX_OF_SHATTER)->type_ls == FINISH_LS )			//авария финишного концевика заслонки		
1732  0E02     MOVLW 0x2
1734  6EE6     MOVWF POSTINC1, ACCESS
1736  EC31     CALL 0x262, 0
1738  F001     NOP
173A  52E5     MOVF POSTDEC1, F, ACCESS
173C  CFF3     MOVFF PROD, FSR0
173E  FFE9     NOP
1740  CFF4     MOVFF PRODH, FSR0H
1742  FFEA     NOP
1744  52EE     MOVF POSTINC0, F, ACCESS
1746  50EF     MOVF INDF0, W, ACCESS
1748  0802     SUBLW 0x2
174A  E102     BNZ 0x1750
222:           				return CODE_FAILURE_MOTOR_LS_SHATTER_FINISH;	
174C  0E08     MOVLW 0x8
174E  D067     BRA 0x181E
223:           			 if( M_Motor_get_state_failure(INDEX_OF_SHATTER)->type_ls == AFTER_FINISH_LS ) 	//авария "после"финишного концевика заслонки
1750  0E02     MOVLW 0x2
1752  6EE6     MOVWF POSTINC1, ACCESS
1754  EC31     CALL 0x262, 0
1756  F001     NOP
1758  52E5     MOVF POSTDEC1, F, ACCESS
175A  CFF3     MOVFF PROD, FSR0
175C  FFE9     NOP
175E  CFF4     MOVFF PRODH, FSR0H
1760  FFEA     NOP
1762  52EE     MOVF POSTINC0, F, ACCESS
1764  50EF     MOVF INDF0, W, ACCESS
1766  0803     SUBLW 0x3
1768  E102     BNZ 0x176E
224:           				return CODE_FAILURE_MOTOR_LS_AFTER_SHATTER_FINISH;	
176A  0E09     MOVLW 0x9
176C  D058     BRA 0x181E
225:           		}
226:           		if (*(M_Motor_get_false_state_LS() + INDEX_FALSE_STATE_LS_START_DISPENSER))		//авария "Ложное состояние стартового концевика дозатора"
176E  ECF6     CALL 0x1EC, 0
1770  F000     NOP
1772  CFF3     MOVFF PROD, FSR0
1774  FFE9     NOP
1776  CFF4     MOVFF PRODH, FSR0H
1778  FFEA     NOP
177A  50EF     MOVF INDF0, W, ACCESS
177C  E002     BZ 0x1782
227:           			return CODE_FAILURE_MOTOR_LS_DISPENSER_START_FALSE_ON;
177E  0E0A     MOVLW 0xA
1780  D04E     BRA 0x181E
228:           		if (*(M_Motor_get_false_state_LS() + INDEX_FALSE_STATE_LS_FINISH_DISPENSER))		//авария "Ложное состояние финишного концевика дозатора"
1782  ECF6     CALL 0x1EC, 0
1784  F000     NOP
1786  CFF3     MOVFF PROD, FSR0
1788  FFE9     NOP
178A  CFF4     MOVFF PRODH, FSR0H
178C  FFEA     NOP
178E  0E01     MOVLW 0x1
1790  26E9     ADDWF FSR0, F, ACCESS
1792  0E00     MOVLW 0x0
1794  22EA     ADDWFC FSR0H, F, ACCESS
1796  50EF     MOVF INDF0, W, ACCESS
1798  E002     BZ 0x179E
229:           			return CODE_FAILURE_MOTOR_LS_DISPENSER_FINISH_FALSE_ON;	
179A  0E0B     MOVLW 0xB
179C  D040     BRA 0x181E
230:           		if (*(M_Motor_get_false_state_LS() + INDEX_FALSE_STATE_LS_START_SHATTER))			//авария "Ложное состояние стартового концевика заслонки"	
179E  ECF6     CALL 0x1EC, 0
17A0  F000     NOP
17A2  CFF3     MOVFF PROD, FSR0
17A4  FFE9     NOP
17A6  CFF4     MOVFF PRODH, FSR0H
17A8  FFEA     NOP
17AA  0E02     MOVLW 0x2
17AC  26E9     ADDWF FSR0, F, ACCESS
17AE  0E00     MOVLW 0x0
17B0  22EA     ADDWFC FSR0H, F, ACCESS
17B2  50EF     MOVF INDF0, W, ACCESS
17B4  E002     BZ 0x17BA
231:           			return  CODE_FAILURE_MOTOR_LS_SHATTER_START_FALSE_ON;
17B6  0E0C     MOVLW 0xC
17B8  D032     BRA 0x181E
232:           		if (*(M_Motor_get_false_state_LS() +  INDEX_FALSE_STATE_LS_FINISH_SHATTER))			//авария "Ложное состояние финишного концевика заслонки"	
17BA  ECF6     CALL 0x1EC, 0
17BC  F000     NOP
17BE  CFF3     MOVFF PROD, FSR0
17C0  FFE9     NOP
17C2  CFF4     MOVFF PRODH, FSR0H
17C4  FFEA     NOP
17C6  0E03     MOVLW 0x3
17C8  26E9     ADDWF FSR0, F, ACCESS
17CA  0E00     MOVLW 0x0
17CC  22EA     ADDWFC FSR0H, F, ACCESS
17CE  50EF     MOVF INDF0, W, ACCESS
17D0  E002     BZ 0x17D6
233:           			return CODE_FAILURE_MOTOR_LS_SHATTER_FINISH_FALSE_ON;
17D2  0E0D     MOVLW 0xD
17D4  D024     BRA 0x181E
234:           		if (*(M_Motor_get_false_state_LS() + INDEX_FALSE_STATE_LS_AFTER_FINISH_SHATTER))	//авария "Ложное состояние послефинишного концевика заслонки"	
17D6  ECF6     CALL 0x1EC, 0
17D8  F000     NOP
17DA  CFF3     MOVFF PROD, FSR0
17DC  FFE9     NOP
17DE  CFF4     MOVFF PRODH, FSR0H
17E0  FFEA     NOP
17E2  0E04     MOVLW 0x4
17E4  26E9     ADDWF FSR0, F, ACCESS
17E6  0E00     MOVLW 0x0
17E8  22EA     ADDWFC FSR0H, F, ACCESS
17EA  50EF     MOVF INDF0, W, ACCESS
17EC  E002     BZ 0x17F2
235:           			return CODE_FAILURE_MOTOR_LS_AFTER_SHATTER_FINISH_FALSE_ON;
17EE  0E0E     MOVLW 0xE
17F0  D016     BRA 0x181E
236:           		#ifndef NO_220V_CONTROL  //если на плату заведено 220В
237:           			if(!M_fan_get_is_220V())																		//авария "Отсутствие 220В" (по синхроимпульсам)
238:           				return CODE_FAILURE_NO_220V;
239:           		#endif	
240:           		M_Menu_write_changed_param(INDEX_OF_CODE_FAILURE, DataEERead (INDEX_OF_CODE_FAILURE), NO_FAILURE);
17F2  6AE6     CLRF POSTINC1, ACCESS
17F4  0E2E     MOVLW 0x2E
17F6  6EE6     MOVWF POSTINC1, ACCESS
17F8  6AE6     CLRF POSTINC1, ACCESS
17FA  ECD5     CALL 0x3DAA, 0
17FC  F01E     NOP
17FE  52E5     MOVF POSTDEC1, F, ACCESS
1800  52E5     MOVF POSTDEC1, F, ACCESS
1802  6EE6     MOVWF POSTINC1, ACCESS
1804  0E2E     MOVLW 0x2E
1806  6EE6     MOVWF POSTINC1, ACCESS
1808  ECC3     CALL 0x2186, 0
180A  F010     NOP
180C  52E5     MOVF POSTDEC1, F, ACCESS
180E  52E5     MOVF POSTDEC1, F, ACCESS
1810  52E5     MOVF POSTDEC1, F, ACCESS
241:           			return NO_FAILURE; 
1812  0E00     MOVLW 0x0
1814  D004     BRA 0x181E
242:           	}
243:           	else
1816  D003     BRA 0x181E
244:           	{
245:           		return M_Mngm_parameters_buffer.menu_parameters.code_failure;
1818  010F     MOVLB 0xF
181A  5133     MOVF 0x33, W, BANKED
181C  D000     BRA 0x181E
246:           	}
247:           }
181E  0012     RETURN 0
248:           
249:           /* Автомат состояний модуля управленяи */
250:           void M_Mngm_Run (void)
251:           {
252:           	if(M_Ind_Get_state() == STATE_IND_INIT)
1820  ECA3     CALL 0x2B46, 0
1822  F015     NOP
1824  0900     IORLW 0x0
1826  E101     BNZ 0x182A
253:           		return;
1828  D02A     BRA 0x187E
254:           			
255:           	if(M_Mngm_State != STATE_PAUSE)  M_Mngm_Code_Failure = M_Mngm_Check_Failure();  //проверка аварий везде кроме режима "Пауза"
182A  0E03     MOVLW 0x3
182C  0100     MOVLB 0x0
182E  5DCB     SUBWF M_Mngm_State, W, BANKED
1830  E003     BZ 0x1838
1832  DED8     RCALL M_Mngm_Check_Failure
1834  0100     MOVLB 0x0
1836  6FCC     MOVWF M_Mngm_Code_Failure, BANKED
256:           
257:           		switch(M_Mngm_State)
1838  0100     MOVLB 0x0
183A  51CB     MOVF M_Mngm_State, W, BANKED
183C  0A05     XORLW 0x5
183E  E01D     BZ 0x187A
1840  0A01     XORLW 0x1
1842  E016     BZ 0x1870
1844  0A07     XORLW 0x7
1846  E012     BZ 0x186C
1848  0A01     XORLW 0x1
184A  E00B     BZ 0x1862
184C  0A03     XORLW 0x3
184E  E007     BZ 0x185E
1850  0A01     XORLW 0x1
1852  E001     BZ 0x1856
1854  D014     BRA 0x187E
258:           		{
259:           			case STATE_WAITING :				//ожидание
260:           				M_Mngm_Previous_State = STATE_WAITING;
1856  0100     MOVLB 0x0
1858  6BCD     CLRF M_Mngm_Previous_State, BANKED
261:           				M_Mngm_waiting();					
185A  D837     RCALL M_Mngm_waiting
262:           			break;
185C  D010     BRA 0x187E
263:           			case STATE_FUEL_SUPPLY :			//загрузка топлива
264:           				M_Mngm_fuel_supply();
185E  D853     RCALL M_Mngm_fuel_supply
265:           			break;
1860  D00E     BRA 0x187E
266:           			case STATE_BURNING :				//горение и поддержание температуры воды
267:           				M_Mngm_Previous_State = STATE_BURNING;
1862  0100     MOVLB 0x0
1864  0E02     MOVLW 0x2
1866  6FCD     MOVWF M_Mngm_Previous_State, BANKED
268:           				M_Mngm_burning();
1868  D883     RCALL M_Mngm_burning
269:           			break;
186A  D009     BRA 0x187E
270:           			case STATE_PAUSE :				//пауза
271:           				M_Mngm_pause();
186C  DA69     RCALL M_Mngm_pause
272:           			break;
186E  D007     BRA 0x187E
273:           			case STATE_CLEAN_CHIMNEY :		//очистка дымохода
274:           				M_Mngm_Previous_State = STATE_CLEAN_CHIMNEY;
1870  0100     MOVLB 0x0
1872  0E04     MOVLW 0x4
1874  6FCD     MOVWF M_Mngm_Previous_State, BANKED
275:           				M_Mngm_clean_chimney();
1876  DA8B     RCALL M_Mngm_clean_chimney
276:           			break;
1878  D002     BRA 0x187E
277:           			case STATE_FAILURE :				//авария
278:           				M_Mngm_failure();
187A  DAA0     RCALL M_Mngm_failure
279:           			break;
187C  D000     BRA 0x187E
280:           			
281:           			//default:
282:           		}
283:           }
187E  0012     RETURN 0
284:           
285:           /*
286:           Проверка необходимости перехода в режим "Пауза"
287:           Если концевик отпущен - перейти в "Паузу"
288:           */
289:           void M_Mngm_need_to_pause(const uint8_t prev_state)
1880  CFD9     MOVFF FSR2, POSTINC1
1882  FFE6     NOP
1884  CFE1     MOVFF FSR1, FSR2
1886  FFD9     NOP
290:           {
291:           	if(!(M_LI_Get_Limit_Switches()->ls_hopper_cover_state)) //если открыта дверь бункера, перейти в состояние паузы
1888  ECBD     CALL 0x3B7A, 0
188A  F01D     NOP
188C  CFF3     MOVFF PROD, FSR0
188E  FFE9     NOP
1890  CFF4     MOVFF PRODH, FSR0H
1892  FFEA     NOP
1894  0E06     MOVLW 0x6
1896  26E9     ADDWF FSR0, F, ACCESS
1898  0E00     MOVLW 0x0
189A  22EA     ADDWFC FSR0H, F, ACCESS
189C  50EF     MOVF INDF0, W, ACCESS
189E  E111     BNZ 0x18C2
292:           	{
293:           		M_Ind_Set_Previous_State(M_Ind_Get_state());
18A0  ECA3     CALL 0x2B46, 0
18A2  F015     NOP
18A4  6EE6     MOVWF POSTINC1, ACCESS
18A6  EC8D     CALL 0x2B1A, 0
18A8  F015     NOP
18AA  52E5     MOVF POSTDEC1, F, ACCESS
294:           		M_Ind_Set_state(STATE_VIEW_PAUSE);	
18AC  0E05     MOVLW 0x5
18AE  6EE6     MOVWF POSTINC1, ACCESS
18B0  EC98     CALL 0x2B30, 0
18B2  F015     NOP
18B4  52E5     MOVF POSTDEC1, F, ACCESS
295:           		M_Mngm_Previous_State = prev_state;
18B6  0EFE     MOVLW 0xFE
18B8  CFDB     MOVFF PLUSW2, M_Mngm_Previous_State
18BA  F0CD     NOP
296:           		M_Mngm_State = STATE_PAUSE; 
18BC  0100     MOVLB 0x0
18BE  0E03     MOVLW 0x3
18C0  6FCB     MOVWF M_Mngm_State, BANKED
297:           	}	
298:           	 
299:           }
18C2  52E5     MOVF POSTDEC1, F, ACCESS
18C4  CFE7     MOVFF INDF1, FSR2
18C6  FFD9     NOP
18C8  0012     RETURN 0
300:           
301:           void M_Mngm_waiting(void)
302:           {
303:           	pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.rotational_speed_fan;
18CA  0100     MOVLB 0x0
18CC  0E30     MOVLW 0x30
18CE  6FD9     MOVWF pFanLevel, BANKED
18D0  0E0F     MOVLW 0xF
18D2  6FDA     MOVWF 0xDA, BANKED
304:           	fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_INCREASE;
18D4  0100     MOVLB 0x0
18D6  0E5E     MOVLW 0x5E
18D8  6FD8     MOVWF fan_param_offset, BANKED
305:           	M_Mngm_need_to_pause(STATE_WAITING);	//Проверка необходимости перехода в режим "Пауза"
18DA  6AE6     CLRF POSTINC1, ACCESS
18DC  DFD1     RCALL M_Mngm_need_to_pause
18DE  52E5     MOVF POSTDEC1, F, ACCESS
306:           	if (M_Mngm_Code_Failure  != NO_FAILURE)
18E0  0100     MOVLB 0x0
18E2  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
18E4  E00F     BZ 0x1904
307:           	{	
308:           		M_Mngm_State = STATE_FAILURE;
18E6  0100     MOVLB 0x0
18E8  0E05     MOVLW 0x5
18EA  6FCB     MOVWF M_Mngm_State, BANKED
309:           		DataEEWrite (M_Mngm_Code_Failure, INDEX_OF_CODE_FAILURE );
18EC  0E2E     MOVLW 0x2E
18EE  6EE6     MOVWF POSTINC1, ACCESS
18F0  0100     MOVLB 0x0
18F2  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
18F4  6EE6     MOVWF POSTINC1, ACCESS
18F6  6AE6     CLRF POSTINC1, ACCESS
18F8  EC0E     CALL 0x3E1C, 0
18FA  F01F     NOP
18FC  52E5     MOVF POSTDEC1, F, ACCESS
18FE  52E5     MOVF POSTDEC1, F, ACCESS
1900  52E5     MOVF POSTDEC1, F, ACCESS
310:           	}
311:           	else
1902  D000     BRA 0x1904
312:           	{
313:           		//если нажата кнопка Start\Menu\Stop - переход в состояние Burning
314:           	}
315:           }
1904  0012     RETURN 0
316:           
317:           
318:           void M_Mngm_fuel_supply(void)
319:           {
320:           	M_Mngm_need_to_pause(STATE_FUEL_SUPPLY);	//Проверка необходимости перехода в режим "Пауза"
1906  0E01     MOVLW 0x1
1908  6EE6     MOVWF POSTINC1, ACCESS
190A  DFBA     RCALL M_Mngm_need_to_pause
190C  52E5     MOVF POSTDEC1, F, ACCESS
321:           	M_fan_set_ctrl_fan(OFF);
190E  6AE6     CLRF POSTINC1, ACCESS
1910  ECE0     CALL 0x41C0, 0
1912  F020     NOP
1914  52E5     MOVF POSTDEC1, F, ACCESS
322:           	if (M_Mngm_Code_Failure  != NO_FAILURE)
1916  0100     MOVLB 0x0
1918  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
191A  E012     BZ 0x1940
323:           	{
324:           		M_Mngm_Previous_State = STATE_FUEL_SUPPLY;
191C  0100     MOVLB 0x0
191E  0E01     MOVLW 0x1
1920  6FCD     MOVWF M_Mngm_Previous_State, BANKED
325:           		M_Mngm_State = STATE_FAILURE;
1922  0100     MOVLB 0x0
1924  0E05     MOVLW 0x5
1926  6FCB     MOVWF M_Mngm_State, BANKED
326:           		DataEEWrite (M_Mngm_Code_Failure, INDEX_OF_CODE_FAILURE );
1928  0E2E     MOVLW 0x2E
192A  6EE6     MOVWF POSTINC1, ACCESS
192C  0100     MOVLB 0x0
192E  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
1930  6EE6     MOVWF POSTINC1, ACCESS
1932  6AE6     CLRF POSTINC1, ACCESS
1934  EC0E     CALL 0x3E1C, 0
1936  F01F     NOP
1938  52E5     MOVF POSTDEC1, F, ACCESS
193A  52E5     MOVF POSTDEC1, F, ACCESS
193C  52E5     MOVF POSTDEC1, F, ACCESS
327:           		//M_fan_set_ctrl_fan(OFF);
328:           	}
329:           	else
193E  D017     BRA 0x196E
330:           	{
331:           		if(M_Motor_get_state() == STATE_MODULE_MOTOR_WAITING && (M_Mngm_Previous_State == STATE_BURNING || 
1940  EC1E     CALL 0x23C, 0
1942  F001     NOP
1944  0801     SUBLW 0x1
1948  0E02     MOVLW 0x2
194A  0100     MOVLB 0x0
194C  5DCD     SUBWF M_Mngm_Previous_State, W, BANKED
332:           			(M_Mngm_Previous_State == STATE_FUEL_SUPPLY && !Menu_get_manual_supply()))) //если отсутствует признак работы двигателя
1946  E113     BNZ 0x196E
194E  E007     BZ 0x195E
1950  0100     MOVLB 0x0
1952  05CD     DECF M_Mngm_Previous_State, W, BANKED
1954  E10C     BNZ 0x196E
1956  EC1C     CALL 0x2038, 0
1958  F010     NOP
195A  0900     IORLW 0x0
195C  E108     BNZ 0x196E
333:           		{
334:           			M_Mngm_State = STATE_BURNING;	
195E  0100     MOVLB 0x0
1960  0E02     MOVLW 0x2
1962  6FCB     MOVWF M_Mngm_State, BANKED
335:           			M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
1964  0E03     MOVLW 0x3
1966  6EE6     MOVWF POSTINC1, ACCESS
1968  EC98     CALL 0x2B30, 0
196A  F015     NOP
196C  52E5     MOVF POSTDEC1, F, ACCESS
336:           		}
337:           	}
338:           }
196E  0012     RETURN 0
339:           
340:           
341:           /* Реализация алгоритма горения с поддержианием температуры */
342:           void M_Mngm_burning(void)
1970  CFD9     MOVFF FSR2, POSTINC1
1972  FFE6     NOP
1974  CFE1     MOVFF FSR1, FSR2
1976  FFD9     NOP
1978  0E02     MOVLW 0x2
197A  26E1     ADDWF FSR1, F, ACCESS
343:           {
344:           	uint16_t temp;
345:           	
346:           	M_Mngm_need_to_pause(STATE_BURNING);	//Проверка необходимости перехода в режим "Пауза"
197C  0E02     MOVLW 0x2
197E  6EE6     MOVWF POSTINC1, ACCESS
1980  DF7F     RCALL M_Mngm_need_to_pause
1982  52E5     MOVF POSTDEC1, F, ACCESS
347:           	if (M_Mngm_Code_Failure  != NO_FAILURE)
1984  0100     MOVLB 0x0
1986  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
1988  E014     BZ 0x19B2
348:           	{
349:           		M_Mngm_clear_timeouts();
198A  DDAB     RCALL M_Mngm_clear_timeouts
350:           		M_Mngm_State = STATE_FAILURE;
198C  0100     MOVLB 0x0
198E  0E05     MOVLW 0x5
1990  6FCB     MOVWF M_Mngm_State, BANKED
351:           		DataEEWrite (M_Mngm_Code_Failure, INDEX_OF_CODE_FAILURE );
1992  0E2E     MOVLW 0x2E
1994  6EE6     MOVWF POSTINC1, ACCESS
1996  0100     MOVLB 0x0
1998  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
199A  6EE6     MOVWF POSTINC1, ACCESS
199C  6AE6     CLRF POSTINC1, ACCESS
199E  EC0E     CALL 0x3E1C, 0
19A0  F01F     NOP
19A2  52E5     MOVF POSTDEC1, F, ACCESS
19A4  52E5     MOVF POSTDEC1, F, ACCESS
19A6  52E5     MOVF POSTDEC1, F, ACCESS
352:           		M_fan_set_ctrl_fan(OFF);
19A8  6AE6     CLRF POSTINC1, ACCESS
19AA  ECE0     CALL 0x41C0, 0
19AC  F020     NOP
19AE  52E5     MOVF POSTDEC1, F, ACCESS
353:           	}
354:           	else
19B0  D1BD     BRA 0x1D2C
355:           	{
356:           		// проверка увеличения температуры воды по истечении заданного таймаута
357:           		if(M_Mngm_check_change_temperature_water())
19B2  DD3C     RCALL M_Mngm_check_change_temperature_water
19B4  0900     IORLW 0x0
19B6  E00A     BZ 0x19CC
358:           		{
359:           			M_fan_set_ctrl_fan(OFF);			//выключить алгоритм работы вентилятора
19B8  6AE6     CLRF POSTINC1, ACCESS
19BA  ECE0     CALL 0x41C0, 0
19BC  F020     NOP
19BE  52E5     MOVF POSTDEC1, F, ACCESS
360:           			M_Mngm_State = STATE_WAITING;	//перейти в режим ожидания при невозможности поддержания температуры
19C0  0100     MOVLB 0x0
19C2  6BCB     CLRF M_Mngm_State, BANKED
361:           			burning_state =  CALC_PARAMS_PERIOD;
19C4  0100     MOVLB 0x0
19C6  6BCE     CLRF burning_state, BANKED
362:           			M_Mngm_clear_timeouts();
19C8  DD8C     RCALL M_Mngm_clear_timeouts
363:           		}	
364:           		else
19CA  D1B0     BRA 0x1D2C
365:           		{
366:           			#ifdef NO_CONTROL_DRAUGHT
367:           				M_Mngm_state_draught = IS_DRAUGHT;
19CC  0100     MOVLB 0x0
19CE  0E01     MOVLW 0x1
19D0  6FD5     MOVWF M_Mngm_state_draught, BANKED
368:           			#else
369:           				M_Mngm_check_draught_failure(); 	//проверка тяги в дымоход, если отсутствует - переход в состояние аварии
370:           			#endif	
371:           			if(M_Mngm_state_draught == IS_DRAUGHT)
19D2  0100     MOVLB 0x0
19D4  05D5     DECF M_Mngm_state_draught, W, BANKED
19D6  E001     BZ 0x19DA
19D8  D1A9     BRA 0x1D2C
372:           			{	
373:           				switch(burning_state)
19DA  0100     MOVLB 0x0
19DC  51CE     MOVF burning_state, W, BANKED
19DE  0A05     XORLW 0x5
19E0  E101     BNZ 0x19E4
19E2  D152     BRA 0x1C88
19E4  0A01     XORLW 0x1
19E6  E101     BNZ 0x19EA
19E8  D139     BRA 0x1C5C
19EA  0A07     XORLW 0x7
19EC  E101     BNZ 0x19F0
19EE  D0DC     BRA 0x1BA8
19F0  0A01     XORLW 0x1
19F2  E101     BNZ 0x19F6
19F4  D079     BRA 0x1AE8
19F6  0A03     XORLW 0x3
19F8  E021     BZ 0x1A3C
19FA  0A01     XORLW 0x1
19FC  E001     BZ 0x1A00
19FE  D195     BRA 0x1D2A
374:           				{
375:           					case CALC_PARAMS_PERIOD:
376:           						period_load_fuel = (uint16_t)M_Mngm_parameters_buffer.menu_parameters.period_load_fuel_in_heat
377:           						[M_Mngm_parameters_buffer.menu_parameters.fuel_type] *1000; //вычисление периода загрузок топлива в горении
1A00  010F     MOVLB 0xF
1A02  5129     MOVF 0x29, W, BANKED
1A04  6AEA     CLRF FSR0H, ACCESS
1A06  0F2C     ADDLW 0x2C
1A08  6EE9     MOVWF FSR0, ACCESS
1A0A  0E0F     MOVLW 0xF
1A0C  22EA     ADDWFC FSR0H, F, ACCESS
1A0E  50EF     MOVF INDF0, W, ACCESS
1A10  010F     MOVLB 0xF
1A12  6F36     MOVWF 0x36, BANKED
1A14  6B37     CLRF 0x37, BANKED
1A16  010F     MOVLB 0xF
1A18  0EE8     MOVLW 0xE8
1A1A  0337     MULWF 0x37, BANKED
1A1C  CFF3     MOVFF PROD, 0xF37
1A1E  FF37     NOP
1A20  0E03     MOVLW 0x3
1A22  0336     MULWF 0x36, BANKED
1A24  50F3     MOVF PROD, W, ACCESS
1A26  2737     ADDWF 0x37, F, BANKED
1A28  0EE8     MOVLW 0xE8
1A2A  0336     MULWF 0x36, BANKED
1A2C  CFF3     MOVFF PROD, period_load_fuel
1A2E  FF36     NOP
1A30  50F4     MOVF PRODH, W, ACCESS
1A32  2737     ADDWF 0x37, F, BANKED
378:           						burning_state = START_BURNING; 
1A34  0100     MOVLB 0x0
1A36  0E01     MOVLW 0x1
1A38  6FCE     MOVWF burning_state, BANKED
379:           					break;  
1A3A  D177     BRA 0x1D2A
380:           					
381:           					case START_BURNING: 	//начальный этап горения (разгон вентилятора)
382:           						if(M_AI_Get_ADC_Data(CHN_T_WATER)->param < M_Mngm_parameters_buffer.menu_parameters.temper_setup - 
1A3C  0E01     MOVLW 0x1
1A3E  6EE6     MOVWF POSTINC1, ACCESS
1A40  EC3C     CALL 0x3478, 0
1A42  F01A     NOP
1A44  52E5     MOVF POSTDEC1, F, ACCESS
1A46  CFF3     MOVFF PROD, FSR0
1A48  FFE9     NOP
1A4A  CFF4     MOVFF PRODH, FSR0H
1A4C  FFEA     NOP
1A4E  0E05     MOVLW 0x5
1A50  26E9     ADDWF FSR0, F, ACCESS
1A52  0E00     MOVLW 0x0
1A54  22EA     ADDWFC FSR0H, F, ACCESS
1A56  CFEF     MOVFF INDF0, __tmp_0
1A58  F032     NOP
383:           							M_Mngm_parameters_buffer.menu_parameters.Fan.delta_temper_for_econom_mode[M_Mngm_parameters_buffer.menu_parameters.fuel_type])
1A5A  010F     MOVLB 0xF
1A5C  5129     MOVF 0x29, W, BANKED
1A5E  6AEA     CLRF FSR0H, ACCESS
1A60  0F1F     ADDLW 0x1F
1A62  6EE9     MOVWF FSR0, ACCESS
1A64  0E0F     MOVLW 0xF
1A66  22EA     ADDWFC FSR0H, F, ACCESS
1A68  50EF     MOVF INDF0, W, ACCESS
1A6A  010F     MOVLB 0xF
1A6C  5D28     SUBWF 0x28, W, BANKED
1A6E  5C32     SUBWF __tmp_0, W, ACCESS
1A70  E217     BC 0x1AA0
384:           						{
385:           							if(M_Mngm_accel_fan()) //если вентилятор разогнан
1A72  D9B7     RCALL M_Mngm_accel_fan
1A74  0900     IORLW 0x0
1A76  E013     BZ 0x1A9E
386:           							{
387:           								burning_state = INCREASE_TEMPERATURE;
1A78  0100     MOVLB 0x0
1A7A  0E02     MOVLW 0x2
1A7C  6FCE     MOVWF burning_state, BANKED
388:           								saved_temperature_water = M_AI_Get_ADC_Data(CHN_T_WATER)->param;
1A7E  0E01     MOVLW 0x1
1A80  6EE6     MOVWF POSTINC1, ACCESS
1A82  EC3C     CALL 0x3478, 0
1A84  F01A     NOP
1A86  52E5     MOVF POSTDEC1, F, ACCESS
1A88  CFF3     MOVFF PROD, FSR0
1A8A  FFE9     NOP
1A8C  CFF4     MOVFF PRODH, FSR0H
1A8E  FFEA     NOP
1A90  0E05     MOVLW 0x5
1A92  26E9     ADDWF FSR0, F, ACCESS
1A94  0E00     MOVLW 0x0
1A96  22EA     ADDWFC FSR0H, F, ACCESS
1A98  CFEF     MOVFF INDF0, saved_temperature_water
1A9A  FF00     NOP
389:           								M_Mngm_clear_accel_fan();
1A9C  D996     RCALL M_Mngm_clear_accel_fan
390:           							}
391:           						}
392:           						else
1A9E  D023     BRA 0x1AE6
393:           						{
394:           							burning_state = ECONOM_MODE;	
1AA0  0100     MOVLB 0x0
1AA2  0E03     MOVLW 0x3
1AA4  6FCE     MOVWF burning_state, BANKED
395:           							M_Mngm_clear_accel_fan();
1AA6  D991     RCALL M_Mngm_clear_accel_fan
396:           							pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.level_fan_in_econom_mode[M_Mngm_parameters_buffer.menu_parameters.fuel_type];
1AA8  010F     MOVLB 0xF
1AAA  5129     MOVF 0x29, W, BANKED
1AAC  0100     MOVLB 0x0
1AAE  6FD9     MOVWF pFanLevel, BANKED
1AB0  6BDA     CLRF 0xDA, BANKED
1AB2  0E22     MOVLW 0x22
1AB4  0100     MOVLB 0x0
1AB6  27D9     ADDWF pFanLevel, F, BANKED
1AB8  0E0F     MOVLW 0xF
1ABA  0100     MOVLB 0x0
1ABC  23DA     ADDWFC 0xDA, F, BANKED
397:           							fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_ECONOM + M_Mngm_parameters_buffer.menu_parameters.fuel_type * 2;
1ABE  010F     MOVLB 0xF
1AC0  5129     MOVF 0x29, W, BANKED
1AC2  24E8     ADDWF WREG, W, ACCESS
1AC4  0F42     ADDLW 0x42
1AC6  0100     MOVLB 0x0
1AC8  6FD8     MOVWF fan_param_offset, BANKED
398:           							M_fan_set_level_fan(*pFanLevel);
1ACA  C0D9     MOVFF pFanLevel, FSR0
1ACC  FFE9     NOP
1ACE  C0DA     MOVFF 0xDA, FSR0H
1AD0  FFEA     NOP
1AD2  50EF     MOVF INDF0, W, ACCESS
1AD4  6EE6     MOVWF POSTINC1, ACCESS
1AD6  ECD5     CALL 0x41AA, 0
1AD8  F020     NOP
1ADA  52E5     MOVF POSTDEC1, F, ACCESS
399:           							M_fan_set_ctrl_fan(ON);			//включить алгоритм работы вентилятора
1ADC  0E01     MOVLW 0x1
1ADE  6EE6     MOVWF POSTINC1, ACCESS
1AE0  ECE0     CALL 0x41C0, 0
1AE2  F020     NOP
1AE4  52E5     MOVF POSTDEC1, F, ACCESS
400:           						}
401:           					break;
1AE6  D121     BRA 0x1D2A
402:           					
403:           					case INCREASE_TEMPERATURE:  //работа на максимальных оборотах вентилятора до перехода в эконом режим, периодическая загрузка топлива
404:           						if(M_AI_Get_ADC_Data(CHN_T_WATER)->param < M_Mngm_parameters_buffer.menu_parameters.temper_setup - 
1AE8  0E01     MOVLW 0x1
1AEA  6EE6     MOVWF POSTINC1, ACCESS
1AEC  EC3C     CALL 0x3478, 0
1AEE  F01A     NOP
1AF0  52E5     MOVF POSTDEC1, F, ACCESS
1AF2  CFF3     MOVFF PROD, FSR0
1AF4  FFE9     NOP
1AF6  CFF4     MOVFF PRODH, FSR0H
1AF8  FFEA     NOP
1AFA  0E05     MOVLW 0x5
1AFC  26E9     ADDWF FSR0, F, ACCESS
1AFE  0E00     MOVLW 0x0
1B00  22EA     ADDWFC FSR0H, F, ACCESS
1B02  CFEF     MOVFF INDF0, __tmp_0
1B04  F032     NOP
405:           							M_Mngm_parameters_buffer.menu_parameters.Fan.delta_temper_for_econom_mode[M_Mngm_parameters_buffer.menu_parameters.fuel_type])
1B06  010F     MOVLB 0xF
1B08  5129     MOVF 0x29, W, BANKED
1B0A  6AEA     CLRF FSR0H, ACCESS
1B0C  0F1F     ADDLW 0x1F
1B0E  6EE9     MOVWF FSR0, ACCESS
1B10  0E0F     MOVLW 0xF
1B12  22EA     ADDWFC FSR0H, F, ACCESS
1B14  50EF     MOVF INDF0, W, ACCESS
1B16  010F     MOVLB 0xF
1B18  5D28     SUBWF 0x28, W, BANKED
1B1A  5C32     SUBWF __tmp_0, W, ACCESS
1B1C  E21F     BC 0x1B5C
406:           						{
407:           							M_fan_set_ctrl_fan(ON);			//включить алгоритм работы вентилятора
1B1E  0E01     MOVLW 0x1
1B20  6EE6     MOVWF POSTINC1, ACCESS
1B22  ECE0     CALL 0x41C0, 0
1B24  F020     NOP
1B26  52E5     MOVF POSTDEC1, F, ACCESS
408:           							if(timeout_supply_fuel++ >= period_load_fuel)			
1B28  0100     MOVLB 0x0
1B2A  C0CF     MOVFF timeout_supply_fuel, __tmp_0
1B2C  F032     NOP
1B2E  C0D0     MOVFF 0xD0, 0x33
1B30  F033     NOP
1B32  2BCF     INCF timeout_supply_fuel, F, BANKED
1B34  0E00     MOVLW 0x0
1B36  23D0     ADDWFC 0xD0, F, BANKED
1B38  010F     MOVLB 0xF
1B3A  5136     MOVF 0x36, W, BANKED
1B3C  5C32     SUBWF __tmp_0, W, ACCESS
1B3E  5137     MOVF 0x37, W, BANKED
1B40  5833     SUBWFB 0x33, W, ACCESS
1B42  E30B     BNC 0x1B5A
409:           							{
410:           								timeout_supply_fuel = 0;
1B44  0100     MOVLB 0x0
1B46  6BCF     CLRF timeout_supply_fuel, BANKED
1B48  6BD0     CLRF 0xD0, BANKED
411:           								M_Mngm_State = STATE_FUEL_SUPPLY;
1B4A  0100     MOVLB 0x0
1B4C  0E01     MOVLW 0x1
1B4E  6FCB     MOVWF M_Mngm_State, BANKED
412:           								M_Motor_set_work(ON); 		//включить алгоритм засыпки топлива
1B50  0E01     MOVLW 0x1
1B52  6EE6     MOVWF POSTINC1, ACCESS
1B54  EC0F     CALL 0x21E, 0
1B56  F001     NOP
1B58  52E5     MOVF POSTDEC1, F, ACCESS
413:           							}
414:           						}
415:           						else
1B5A  D025     BRA 0x1BA6
416:           						{
417:           							burning_state = ECONOM_MODE;
1B5C  0100     MOVLB 0x0
1B5E  0E03     MOVLW 0x3
1B60  6FCE     MOVWF burning_state, BANKED
418:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
1B62  0E03     MOVLW 0x3
1B64  6EE6     MOVWF POSTINC1, ACCESS
1B66  EC98     CALL 0x2B30, 0
1B68  F015     NOP
1B6A  52E5     MOVF POSTDEC1, F, ACCESS
419:           							timeout_supply_fuel = 0;
1B6C  0100     MOVLB 0x0
1B6E  6BCF     CLRF timeout_supply_fuel, BANKED
1B70  6BD0     CLRF 0xD0, BANKED
420:           							pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.level_fan_in_econom_mode[M_Mngm_parameters_buffer.menu_parameters.fuel_type]; 
1B72  010F     MOVLB 0xF
1B74  5129     MOVF 0x29, W, BANKED
1B76  0100     MOVLB 0x0
1B78  6FD9     MOVWF pFanLevel, BANKED
1B7A  6BDA     CLRF 0xDA, BANKED
1B7C  0E22     MOVLW 0x22
1B7E  0100     MOVLB 0x0
1B80  27D9     ADDWF pFanLevel, F, BANKED
1B82  0E0F     MOVLW 0xF
1B84  0100     MOVLB 0x0
1B86  23DA     ADDWFC 0xDA, F, BANKED
421:           							fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_ECONOM + M_Mngm_parameters_buffer.menu_parameters.fuel_type * 2;
1B88  010F     MOVLB 0xF
1B8A  5129     MOVF 0x29, W, BANKED
1B8C  24E8     ADDWF WREG, W, ACCESS
1B8E  0F42     ADDLW 0x42
1B90  0100     MOVLB 0x0
1B92  6FD8     MOVWF fan_param_offset, BANKED
422:           							M_fan_set_level_fan(*pFanLevel);
1B94  C0D9     MOVFF pFanLevel, FSR0
1B96  FFE9     NOP
1B98  C0DA     MOVFF 0xDA, FSR0H
1B9A  FFEA     NOP
1B9C  50EF     MOVF INDF0, W, ACCESS
1B9E  6EE6     MOVWF POSTINC1, ACCESS
1BA0  ECD5     CALL 0x41AA, 0
1BA2  F020     NOP
1BA4  52E5     MOVF POSTDEC1, F, ACCESS
423:           						}
424:           					break;
1BA6  D0C1     BRA 0x1D2A
425:           					case ECONOM_MODE:
426:           						if(M_AI_Get_ADC_Data(CHN_T_WATER)->param >= M_Mngm_parameters_buffer.menu_parameters.temper_setup)
1BA8  0E01     MOVLW 0x1
1BAA  6EE6     MOVWF POSTINC1, ACCESS
1BAC  EC3C     CALL 0x3478, 0
1BAE  F01A     NOP
1BB0  52E5     MOVF POSTDEC1, F, ACCESS
1BB2  CFF3     MOVFF PROD, FSR0
1BB4  FFE9     NOP
1BB6  CFF4     MOVFF PRODH, FSR0H
1BB8  FFEA     NOP
1BBA  0E05     MOVLW 0x5
1BBC  26E9     ADDWF FSR0, F, ACCESS
1BBE  0E00     MOVLW 0x0
1BC0  22EA     ADDWFC FSR0H, F, ACCESS
1BC2  CFEF     MOVFF INDF0, __tmp_0
1BC4  F032     NOP
1BC6  010F     MOVLB 0xF
1BC8  5128     MOVF 0x28, W, BANKED
1BCA  5C32     SUBWF __tmp_0, W, ACCESS
1BCC  E313     BNC 0x1BF4
427:           						{
428:           							burning_state = MAINTENANCE_TEMPERATURE_CYCLE;	
1BCE  0100     MOVLB 0x0
1BD0  0E04     MOVLW 0x4
1BD2  6FCE     MOVWF burning_state, BANKED
429:           							pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.level_fan_in_smoldering[M_Mngm_parameters_buffer.menu_parameters.fuel_type];
1BD4  010F     MOVLB 0xF
1BD6  5129     MOVF 0x29, W, BANKED
1BD8  0100     MOVLB 0x0
1BDA  6FD9     MOVWF pFanLevel, BANKED
1BDC  6BDA     CLRF 0xDA, BANKED
1BDE  0E25     MOVLW 0x25
1BE0  0100     MOVLB 0x0
1BE2  27D9     ADDWF pFanLevel, F, BANKED
1BE4  0E0F     MOVLW 0xF
1BE6  0100     MOVLB 0x0
1BE8  23DA     ADDWFC 0xDA, F, BANKED
430:           							M_fan_set_ctrl_fan(OFF);
1BEA  6AE6     CLRF POSTINC1, ACCESS
1BEC  ECE0     CALL 0x41C0, 0
1BEE  F020     NOP
1BF0  52E5     MOVF POSTDEC1, F, ACCESS
431:           						}
432:           						else if(M_AI_Get_ADC_Data(CHN_T_WATER)->param < M_Mngm_parameters_buffer.menu_parameters.temper_setup - 
1BF2  D033     BRA 0x1C5A
1BF4  0E01     MOVLW 0x1
1BF6  6EE6     MOVWF POSTINC1, ACCESS
1BF8  EC3C     CALL 0x3478, 0
1BFA  F01A     NOP
1BFC  52E5     MOVF POSTDEC1, F, ACCESS
1BFE  CFF3     MOVFF PROD, FSR0
1C00  FFE9     NOP
1C02  CFF4     MOVFF PRODH, FSR0H
1C04  FFEA     NOP
1C06  0E05     MOVLW 0x5
1C08  26E9     ADDWF FSR0, F, ACCESS
1C0A  0E00     MOVLW 0x0
1C0C  22EA     ADDWFC FSR0H, F, ACCESS
1C0E  CFEF     MOVFF INDF0, __tmp_0
1C10  F032     NOP
433:           							M_Mngm_parameters_buffer.menu_parameters.Fan.delta_temper_for_econom_mode[M_Mngm_parameters_buffer.menu_parameters.fuel_type])
1C12  010F     MOVLB 0xF
1C14  5129     MOVF 0x29, W, BANKED
1C16  6AEA     CLRF FSR0H, ACCESS
1C18  0F1F     ADDLW 0x1F
1C1A  6EE9     MOVWF FSR0, ACCESS
1C1C  0E0F     MOVLW 0xF
1C1E  22EA     ADDWFC FSR0H, F, ACCESS
1C20  50EF     MOVF INDF0, W, ACCESS
1C22  010F     MOVLB 0xF
1C24  5D28     SUBWF 0x28, W, BANKED
1C26  5C32     SUBWF __tmp_0, W, ACCESS
1C28  E218     BC 0x1C5A
434:           						{
435:           							burning_state = INCREASE_TEMPERATURE;
1C2A  0100     MOVLB 0x0
1C2C  0E02     MOVLW 0x2
1C2E  6FCE     MOVWF burning_state, BANKED
436:           							timeout_supply_fuel = period_load_fuel;
1C30  CF36     MOVFF period_load_fuel, timeout_supply_fuel
1C32  F0CF     NOP
1C34  CF37     MOVFF 0xF37, 0xD0
1C36  F0D0     NOP
437:           							pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.rotational_speed_fan;
1C38  0100     MOVLB 0x0
1C3A  0E30     MOVLW 0x30
1C3C  6FD9     MOVWF pFanLevel, BANKED
1C3E  0E0F     MOVLW 0xF
1C40  6FDA     MOVWF 0xDA, BANKED
438:           							fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_INCREASE;
1C42  0100     MOVLB 0x0
1C44  0E5E     MOVLW 0x5E
1C46  6FD8     MOVWF fan_param_offset, BANKED
439:           							M_fan_set_level_fan(*pFanLevel);
1C48  C0D9     MOVFF pFanLevel, FSR0
1C4A  FFE9     NOP
1C4C  C0DA     MOVFF 0xDA, FSR0H
1C4E  FFEA     NOP
1C50  50EF     MOVF INDF0, W, ACCESS
1C52  6EE6     MOVWF POSTINC1, ACCESS
1C54  ECD5     CALL 0x41AA, 0
1C56  F020     NOP
1C58  52E5     MOVF POSTDEC1, F, ACCESS
440:           						}	
441:           						
442:           					break;
1C5A  D067     BRA 0x1D2A
443:           					case MAINTENANCE_TEMPERATURE_CYCLE:		//продувка топлива
444:           						if(M_Mngm_cyclic_mode())
1C5C  D94A     RCALL M_Mngm_cyclic_mode
1C5E  0900     IORLW 0x0
1C60  E012     BZ 0x1C86
445:           						{	
446:           							burning_state = MAINTENANCE_TEMPERATURE_INCR;
1C62  0100     MOVLB 0x0
1C64  0E05     MOVLW 0x5
1C66  6FCE     MOVWF burning_state, BANKED
447:           							saved_temperature_water = M_AI_Get_ADC_Data(CHN_T_WATER)->param;
1C68  0E01     MOVLW 0x1
1C6A  6EE6     MOVWF POSTINC1, ACCESS
1C6C  EC3C     CALL 0x3478, 0
1C6E  F01A     NOP
1C70  52E5     MOVF POSTDEC1, F, ACCESS
1C72  CFF3     MOVFF PROD, FSR0
1C74  FFE9     NOP
1C76  CFF4     MOVFF PRODH, FSR0H
1C78  FFEA     NOP
1C7A  0E05     MOVLW 0x5
1C7C  26E9     ADDWF FSR0, F, ACCESS
1C7E  0E00     MOVLW 0x0
1C80  22EA     ADDWFC FSR0H, F, ACCESS
1C82  CFEF     MOVFF INDF0, saved_temperature_water
1C84  FF00     NOP
448:           						}
449:           					break;
1C86  D051     BRA 0x1D2A
450:           					
451:           					case MAINTENANCE_TEMPERATURE_INCR:  	//добор температуры после продувки
452:           						if(M_AI_Get_ADC_Data(CHN_T_WATER)->param >= M_Mngm_parameters_buffer.menu_parameters.temper_setup)
1C88  0E01     MOVLW 0x1
1C8A  6EE6     MOVWF POSTINC1, ACCESS
1C8C  EC3C     CALL 0x3478, 0
1C8E  F01A     NOP
1C90  52E5     MOVF POSTDEC1, F, ACCESS
1C92  CFF3     MOVFF PROD, FSR0
1C94  FFE9     NOP
1C96  CFF4     MOVFF PRODH, FSR0H
1C98  FFEA     NOP
1C9A  0E05     MOVLW 0x5
1C9C  26E9     ADDWF FSR0, F, ACCESS
1C9E  0E00     MOVLW 0x0
1CA0  22EA     ADDWFC FSR0H, F, ACCESS
1CA2  CFEF     MOVFF INDF0, __tmp_0
1CA4  F032     NOP
1CA6  010F     MOVLB 0xF
1CA8  5128     MOVF 0x28, W, BANKED
1CAA  5C32     SUBWF __tmp_0, W, ACCESS
1CAC  E30B     BNC 0x1CC4
453:           						{
454:           							burning_state = MAINTENANCE_TEMPERATURE_CYCLE;
1CAE  0100     MOVLB 0x0
1CB0  0E04     MOVLW 0x4
1CB2  6FCE     MOVWF burning_state, BANKED
455:           							timeout_supply_fuel = 0;
1CB4  0100     MOVLB 0x0
1CB6  6BCF     CLRF timeout_supply_fuel, BANKED
1CB8  6BD0     CLRF 0xD0, BANKED
456:           							M_fan_set_ctrl_fan(OFF);
1CBA  6AE6     CLRF POSTINC1, ACCESS
1CBC  ECE0     CALL 0x41C0, 0
1CBE  F020     NOP
1CC0  52E5     MOVF POSTDEC1, F, ACCESS
457:           						}
458:           						else
1CC2  D032     BRA 0x1D28
459:           						{
460:           							M_fan_set_ctrl_fan(ON);			//включить алгоритм работы вентилятора
1CC4  0E01     MOVLW 0x1
1CC6  6EE6     MOVWF POSTINC1, ACCESS
1CC8  ECE0     CALL 0x41C0, 0
1CCA  F020     NOP
1CCC  52E5     MOVF POSTDEC1, F, ACCESS
461:           							pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.level_fan_in_smoldering[M_Mngm_parameters_buffer.menu_parameters.fuel_type];
1CCE  010F     MOVLB 0xF
1CD0  5129     MOVF 0x29, W, BANKED
1CD2  0100     MOVLB 0x0
1CD4  6FD9     MOVWF pFanLevel, BANKED
1CD6  6BDA     CLRF 0xDA, BANKED
1CD8  0E25     MOVLW 0x25
1CDA  0100     MOVLB 0x0
1CDC  27D9     ADDWF pFanLevel, F, BANKED
1CDE  0E0F     MOVLW 0xF
1CE0  0100     MOVLB 0x0
1CE2  23DA     ADDWFC 0xDA, F, BANKED
462:           							M_fan_set_level_fan(*pFanLevel);
1CE4  C0D9     MOVFF pFanLevel, FSR0
1CE6  FFE9     NOP
1CE8  C0DA     MOVFF 0xDA, FSR0H
1CEA  FFEA     NOP
1CEC  50EF     MOVF INDF0, W, ACCESS
1CEE  6EE6     MOVWF POSTINC1, ACCESS
1CF0  ECD5     CALL 0x41AA, 0
1CF2  F020     NOP
1CF4  52E5     MOVF POSTDEC1, F, ACCESS
463:           							if(timeout_supply_fuel++ >= period_load_fuel)			
1CF6  0100     MOVLB 0x0
1CF8  C0CF     MOVFF timeout_supply_fuel, __tmp_0
1CFA  F032     NOP
1CFC  C0D0     MOVFF 0xD0, 0x33
1CFE  F033     NOP
1D00  2BCF     INCF timeout_supply_fuel, F, BANKED
1D02  0E00     MOVLW 0x0
1D04  23D0     ADDWFC 0xD0, F, BANKED
1D06  010F     MOVLB 0xF
1D08  5136     MOVF 0x36, W, BANKED
1D0A  5C32     SUBWF __tmp_0, W, ACCESS
1D0C  5137     MOVF 0x37, W, BANKED
1D0E  5833     SUBWFB 0x33, W, ACCESS
1D10  E30B     BNC 0x1D28
464:           							{
465:           								timeout_supply_fuel = 0;
1D12  0100     MOVLB 0x0
1D14  6BCF     CLRF timeout_supply_fuel, BANKED
1D16  6BD0     CLRF 0xD0, BANKED
466:           								M_Mngm_State = STATE_FUEL_SUPPLY;
1D18  0100     MOVLB 0x0
1D1A  0E01     MOVLW 0x1
1D1C  6FCB     MOVWF M_Mngm_State, BANKED
467:           								M_Motor_set_work(ON); 		//включить алгоритм засыпки топлива
1D1E  0E01     MOVLW 0x1
1D20  6EE6     MOVWF POSTINC1, ACCESS
1D22  EC0F     CALL 0x21E, 0
1D24  F001     NOP
1D26  52E5     MOVF POSTDEC1, F, ACCESS
468:           							}
469:           						}
470:           					break;
1D28  D000     BRA 0x1D2A
471:           				}
472:           			}
473:           			else
1D2A  D000     BRA 0x1D2C
474:           			{
475:           				
476:           			}
477:           		}
478:           	}
479:           }
1D2C  0E02     MOVLW 0x2
1D2E  5CE1     SUBWF FSR1, W, ACCESS
1D30  E202     BC 0x1D36
1D32  6AE1     CLRF FSR1, ACCESS
1D34  52E5     MOVF POSTDEC1, F, ACCESS
1D36  6EE1     MOVWF FSR1, ACCESS
1D38  52E5     MOVF POSTDEC1, F, ACCESS
1D3A  CFE7     MOVFF INDF1, FSR2
1D3C  FFD9     NOP
1D3E  0012     RETURN 0
480:           
481:           /* Режим "Пауза" */
482:           void M_Mngm_pause(void)
483:           {
484:           	if(M_LI_Get_Limit_Switches()->ls_hopper_cover_state) //если закрыта дверь бункера, выйти из состояния паузы
1D40  ECBD     CALL 0x3B7A, 0
1D42  F01D     NOP
1D44  CFF3     MOVFF PROD, FSR0
1D46  FFE9     NOP
1D48  CFF4     MOVFF PRODH, FSR0H
1D4A  FFEA     NOP
1D4C  0E06     MOVLW 0x6
1D4E  26E9     ADDWF FSR0, F, ACCESS
1D50  0E00     MOVLW 0x0
1D52  22EA     ADDWFC FSR0H, F, ACCESS
1D54  50EF     MOVF INDF0, W, ACCESS
1D56  E008     BZ 0x1D68
485:           	{
486:           		M_Mngm_State = M_Mngm_Previous_State;
1D58  C0CD     MOVFF M_Mngm_Previous_State, M_Mngm_State
1D5A  F0CB     NOP
487:           		M_Ind_Set_state(M_Ind_Get_Previous_State());	
1D5C  EC89     CALL 0x2B12, 0
1D5E  F015     NOP
1D60  6EE6     MOVWF POSTINC1, ACCESS
1D62  EC98     CALL 0x2B30, 0
1D64  F015     NOP
1D66  52E5     MOVF POSTDEC1, F, ACCESS
488:           	}		
489:           	if (M_Mngm_Code_Failure  != NO_FAILURE)
1D68  0100     MOVLB 0x0
1D6A  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
1D6C  E00F     BZ 0x1D8C
490:           	{
491:           		M_Mngm_State = STATE_FAILURE;
1D6E  0100     MOVLB 0x0
1D70  0E05     MOVLW 0x5
1D72  6FCB     MOVWF M_Mngm_State, BANKED
492:           		DataEEWrite (M_Mngm_Code_Failure, INDEX_OF_CODE_FAILURE );
1D74  0E2E     MOVLW 0x2E
1D76  6EE6     MOVWF POSTINC1, ACCESS
1D78  0100     MOVLB 0x0
1D7A  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
1D7C  6EE6     MOVWF POSTINC1, ACCESS
1D7E  6AE6     CLRF POSTINC1, ACCESS
1D80  EC0E     CALL 0x3E1C, 0
1D82  F01F     NOP
1D84  52E5     MOVF POSTDEC1, F, ACCESS
1D86  52E5     MOVF POSTDEC1, F, ACCESS
1D88  52E5     MOVF POSTDEC1, F, ACCESS
493:           	}
494:           	else
1D8A  D000     BRA 0x1D8C
495:           	{
496:           	
497:           	}
498:           }
1D8C  0012     RETURN 0
499:           
500:           /*Режим "Очистка дымохода" */
501:           void M_Mngm_clean_chimney(void)
502:           {
503:           	M_Mngm_need_to_pause(STATE_CLEAN_CHIMNEY);	//Проверка необходимости перехода в режим "Пауза"
1D8E  0E04     MOVLW 0x4
1D90  6EE6     MOVWF POSTINC1, ACCESS
1D92  DD76     RCALL M_Mngm_need_to_pause
1D94  52E5     MOVF POSTDEC1, F, ACCESS
504:           	if (M_Mngm_Code_Failure  != NO_FAILURE)
1D96  0100     MOVLB 0x0
1D98  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
1D9A  E00F     BZ 0x1DBA
505:           	{
506:           		M_Mngm_State = STATE_FAILURE;
1D9C  0100     MOVLB 0x0
1D9E  0E05     MOVLW 0x5
1DA0  6FCB     MOVWF M_Mngm_State, BANKED
507:           		DataEEWrite (M_Mngm_Code_Failure, INDEX_OF_CODE_FAILURE );
1DA2  0E2E     MOVLW 0x2E
1DA4  6EE6     MOVWF POSTINC1, ACCESS
1DA6  0100     MOVLB 0x0
1DA8  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
1DAA  6EE6     MOVWF POSTINC1, ACCESS
1DAC  6AE6     CLRF POSTINC1, ACCESS
1DAE  EC0E     CALL 0x3E1C, 0
1DB0  F01F     NOP
1DB2  52E5     MOVF POSTDEC1, F, ACCESS
1DB4  52E5     MOVF POSTDEC1, F, ACCESS
1DB6  52E5     MOVF POSTDEC1, F, ACCESS
508:           	}
509:           	else
1DB8  D000     BRA 0x1DBA
510:           	{
511:           	
512:           	}
513:           }
1DBA  0012     RETURN 0
514:           
515:           
516:           void M_Mngm_failure(void)
517:           {
518:           	if (M_Mngm_Code_Failure  == NO_FAILURE)
1DBC  0100     MOVLB 0x0
1DBE  51CC     MOVF M_Mngm_Code_Failure, W, BANKED
1DC0  E103     BNZ 0x1DC8
519:           	{
520:           		M_Mngm_State = M_Mngm_Previous_State;
1DC2  C0CD     MOVFF M_Mngm_Previous_State, M_Mngm_State
1DC4  F0CB     NOP
521:           	}
522:           	else
1DC6  D000     BRA 0x1DC8
523:           	{
524:           		
525:           	}
526:           }
1DC8  0012     RETURN 0
527:           
528:           /*
529:           Cброс переменных разгона вентилятора
530:           */
531:           void M_Mngm_clear_accel_fan(void)
532:           {
533:           	state_accel_fan = CALCULATE;
1DCA  0100     MOVLB 0x0
1DCC  6BD6     CLRF state_accel_fan, BANKED
534:           	timeout = 0;
1DCE  010F     MOVLB 0xF
1DD0  6B38     CLRF 0x38, BANKED
1DD2  6B39     CLRF 0x39, BANKED
535:           }
1DD4  0012     RETURN 0
536:           
537:           /*
538:           Cброс переменных циклического режима
539:           */
540:           void M_Mngm_clear_cyclic_mode(void)
541:           {
542:           	phase_cycle = PAUSE_IN_CYCLE;;
1DD6  0100     MOVLB 0x0
1DD8  6BD7     CLRF phase_cycle, BANKED
543:           	timeout = 0;
1DDA  010F     MOVLB 0xF
1DDC  6B38     CLRF 0x38, BANKED
1DDE  6B39     CLRF 0x39, BANKED
544:           }
1DE0  0012     RETURN 0
545:           
546:           
547:           /* 
548:           Функция разгона вентилятора от миимального до максимального уровня при начальном разгорании котла
549:           */
550:           BOOL M_Mngm_accel_fan(void)
1DE2  CFD9     MOVFF FSR2, POSTINC1
1DE4  FFE6     NOP
1DE6  CFE1     MOVFF FSR1, FSR2
1DE8  FFD9     NOP
1DEA  52E6     MOVF POSTINC1, F, ACCESS
551:           {
552:           	uint8_t  num_steps;
553:           	static uint16_t time_step; 
554:           	//static uint8_t level;
555:           		
556:           	switch (state_accel_fan)
1DEC  0100     MOVLB 0x0
1DEE  51D6     MOVF state_accel_fan, W, BANKED
1DF0  0A01     XORLW 0x1
1DF2  E03F     BZ 0x1E72
1DF4  0A01     XORLW 0x1
1DF6  E001     BZ 0x1DFA
1DF8  D075     BRA 0x1EE4
557:           	{
558:           		case CALCULATE:		//состояние вычисления параметров
559:           			num_steps = (M_Mngm_parameters_buffer.menu_parameters.Fan.max_turn_percent - 
560:           						M_Mngm_parameters_buffer.menu_parameters.Fan.min_turn_percent) + 1; 	//получаем количество шагов разгона
1DFA  010F     MOVLB 0xF
1DFC  5111     MOVF 0x11, W, BANKED
1DFE  010F     MOVLB 0xF
1E00  5D12     SUBWF 0x12, W, BANKED
1E02  0F01     ADDLW 0x1
1E04  6EDF     MOVWF INDF2, ACCESS
561:           			//получаем шаг времени для одного уровня вращения вентилятора
562:           			time_step = (uint16_t)M_Mngm_parameters_buffer.menu_parameters.Fan.time_accel_fan
563:           						[M_Mngm_parameters_buffer.menu_parameters.fuel_type] * 100 / num_steps; 	
1E06  50DF     MOVF INDF2, W, ACCESS
1E08  6E34     MOVWF 0x34, ACCESS
1E0A  6A35     CLRF 0x35, ACCESS
1E0C  010F     MOVLB 0xF
1E0E  5129     MOVF 0x29, W, BANKED
1E10  6AEA     CLRF FSR0H, ACCESS
1E12  0F1C     ADDLW 0x1C
1E14  6EE9     MOVWF FSR0, ACCESS
1E16  0E0F     MOVLW 0xF
1E18  22EA     ADDWFC FSR0H, F, ACCESS
1E1A  50EF     MOVF INDF0, W, ACCESS
1E1C  0D64     MULLW 0x64
1E1E  CFF3     MOVFF PROD, __tmp_0
1E20  F032     NOP
1E22  CFF4     MOVFF PRODH, 0x33
1E24  F033     NOP
1E26  C032     MOVFF __tmp_0, 0x26
1E28  F026     NOP
1E2A  C033     MOVFF 0x33, 0x27
1E2C  F027     NOP
1E2E  C034     MOVFF 0x34, 0x2B
1E30  F02B     NOP
1E32  C035     MOVFF 0x35, 0x2C
1E34  F02C     NOP
1E36  ECA2     CALL 0x4D44, 0
1E38  F026     NOP
1E3A  C026     MOVFF 0x26, 0xF3B
1E3C  FF3B     NOP
1E3E  C027     MOVFF 0x27, 0xF3C
1E40  FF3C     NOP
564:           			pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.min_turn_percent;
1E42  0100     MOVLB 0x0
1E44  0E11     MOVLW 0x11
1E46  6FD9     MOVWF pFanLevel, BANKED
1E48  0E0F     MOVLW 0xF
1E4A  6FDA     MOVWF 0xDA, BANKED
565:           			level = *pFanLevel;
1E4C  C0D9     MOVFF pFanLevel, FSR0
1E4E  FFE9     NOP
1E50  C0DA     MOVFF 0xDA, FSR0H
1E52  FFEA     NOP
1E54  CFEF     MOVFF INDF0, level
1E56  FF3A     NOP
566:           			M_fan_set_level_fan(level);				
1E58  CF3A     MOVFF level, POSTINC1
1E5A  FFE6     NOP
1E5C  ECD5     CALL 0x41AA, 0
1E5E  F020     NOP
1E60  52E5     MOVF POSTDEC1, F, ACCESS
567:           			M_fan_set_ctrl_fan(ON);
1E62  0E01     MOVLW 0x1
1E64  6EE6     MOVWF POSTINC1, ACCESS
1E66  ECE0     CALL 0x41C0, 0
1E68  F020     NOP
1E6A  52E5     MOVF POSTDEC1, F, ACCESS
568:           			state_accel_fan++;	//переход к следующему состоянию автомата
1E6C  0100     MOVLB 0x0
1E6E  2BD6     INCF state_accel_fan, F, BANKED
569:           			break;
1E70  D039     BRA 0x1EE4
570:           		case ROTATE:  //состояние вращения при разгоне
571:           			if(timeout++ == time_step)
1E72  010F     MOVLB 0xF
1E74  CF38     MOVFF timeout, __tmp_0
1E76  F032     NOP
1E78  CF39     MOVFF 0xF39, 0x33
1E7A  F033     NOP
1E7C  2B38     INCF 0x38, F, BANKED
1E7E  0E00     MOVLW 0x0
1E80  2339     ADDWFC 0x39, F, BANKED
1E82  010F     MOVLB 0xF
1E84  513B     MOVF _OS_Temp, W, BANKED
1E86  1832     XORWF __tmp_0, W, ACCESS
1E88  E102     BNZ 0x1E8E
1E8A  513C     MOVF _OS_TempH, W, BANKED
1E8C  1833     XORWF 0x33, W, ACCESS
1E8E  E129     BNZ 0x1EE2
572:           			{
573:           				timeout = 0;	
1E90  010F     MOVLB 0xF
1E92  6B38     CLRF 0x38, BANKED
1E94  6B39     CLRF 0x39, BANKED
574:           				if(level++ == M_Mngm_parameters_buffer.menu_parameters.Fan.max_turn_percent)
1E96  010F     MOVLB 0xF
1E98  513A     MOVF _OS_Flags, W, BANKED
1E9A  2B3A     INCF _OS_Flags, F, BANKED
1E9C  010F     MOVLB 0xF
1E9E  5D12     SUBWF 0x12, W, BANKED
1EA0  E116     BNZ 0x1ECE
575:           				{	
576:           					state_accel_fan = CALCULATE;
1EA2  0100     MOVLB 0x0
1EA4  6BD6     CLRF state_accel_fan, BANKED
577:           					pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.rotational_speed_fan;
1EA6  0100     MOVLB 0x0
1EA8  0E30     MOVLW 0x30
1EAA  6FD9     MOVWF pFanLevel, BANKED
1EAC  0E0F     MOVLW 0xF
1EAE  6FDA     MOVWF 0xDA, BANKED
578:           					M_fan_set_level_fan(*pFanLevel);	
1EB0  C0D9     MOVFF pFanLevel, FSR0
1EB2  FFE9     NOP
1EB4  C0DA     MOVFF 0xDA, FSR0H
1EB6  FFEA     NOP
1EB8  50EF     MOVF INDF0, W, ACCESS
1EBA  6EE6     MOVWF POSTINC1, ACCESS
1EBC  ECD5     CALL 0x41AA, 0
1EBE  F020     NOP
1EC0  52E5     MOVF POSTDEC1, F, ACCESS
579:           					fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_INCREASE;
1EC2  0100     MOVLB 0x0
1EC4  0E5E     MOVLW 0x5E
1EC6  6FD8     MOVWF fan_param_offset, BANKED
580:           					return  FAN_IS_ACCEL; 
1EC8  0E01     MOVLW 0x1
1ECA  D00E     BRA 0x1EE8
581:           				}
582:           				else
1ECC  D00A     BRA 0x1EE2
583:           				{
584:           					pFanLevel = &level;
1ECE  0100     MOVLB 0x0
1ED0  0E3A     MOVLW 0x3A
1ED2  6FD9     MOVWF pFanLevel, BANKED
1ED4  0E0F     MOVLW 0xF
1ED6  6FDA     MOVWF 0xDA, BANKED
585:           					M_fan_set_level_fan(level);	
1ED8  CF3A     MOVFF level, POSTINC1
1EDA  FFE6     NOP
1EDC  ECD5     CALL 0x41AA, 0
1EDE  F020     NOP
1EE0  52E5     MOVF POSTDEC1, F, ACCESS
586:           				}
587:           			}	
588:           			break;
1EE2  D000     BRA 0x1EE4
589:           	}
590:           	return FAN_NOT_ACCEL;
1EE4  0E00     MOVLW 0x0
1EE6  D000     BRA 0x1EE8
591:           }
1EE8  52E5     MOVF POSTDEC1, F, ACCESS
1EEA  52E5     MOVF POSTDEC1, F, ACCESS
1EEC  CFE7     MOVFF INDF1, FSR2
1EEE  FFD9     NOP
1EF0  0012     RETURN 0
592:           
593:           
594:           
595:           /*
596:           Функция работы вентилятора в циклическом режиме работа-пауза в режиме тления топлива алгоритма горения
597:           Возвращает 1 - если температура упала и нужно возвращаться в режим загрузки топлива для увеличения температуры
598:           0 - продолжаем оставаться в этом режиме
599:           */
600:           BOOL M_Mngm_cyclic_mode(void)
601:           {
602:           	if(M_AI_Get_ADC_Data(CHN_T_WATER)->param <= M_Mngm_parameters_buffer.menu_parameters.temper_setup - 
1EF2  0E01     MOVLW 0x1
1EF4  6EE6     MOVWF POSTINC1, ACCESS
1EF6  EC3C     CALL 0x3478, 0
1EF8  F01A     NOP
1EFA  52E5     MOVF POSTDEC1, F, ACCESS
1EFC  CFF3     MOVFF PROD, FSR0
1EFE  FFE9     NOP
1F00  CFF4     MOVFF PRODH, FSR0H
1F02  FFEA     NOP
1F04  0E05     MOVLW 0x5
1F06  26E9     ADDWF FSR0, F, ACCESS
1F08  0E00     MOVLW 0x0
1F0A  22EA     ADDWFC FSR0H, F, ACCESS
1F0C  CFEF     MOVFF INDF0, __tmp_0
1F0E  F032     NOP
603:           	M_Mngm_parameters_buffer.menu_parameters.Fan.delta_from_cycle_to_heat[M_Mngm_parameters_buffer.menu_parameters.fuel_type])
1F10  010F     MOVLB 0xF
1F12  5129     MOVF 0x29, W, BANKED
1F14  6AEA     CLRF FSR0H, ACCESS
1F16  0F19     ADDLW 0x19
1F18  6EE9     MOVWF FSR0, ACCESS
1F1A  0E0F     MOVLW 0xF
1F1C  22EA     ADDWFC FSR0H, F, ACCESS
1F1E  50EF     MOVF INDF0, W, ACCESS
1F20  010F     MOVLB 0xF
1F22  5D28     SUBWF 0x28, W, BANKED
1F24  80D8     BSF STATUS, 0, ACCESS
1F26  5432     SUBFWB __tmp_0, W, ACCESS
1F28  E30C     BNC 0x1F42
604:           	{
605:           		phase_cycle = PAUSE_IN_CYCLE;
1F2A  0100     MOVLB 0x0
1F2C  6BD7     CLRF phase_cycle, BANKED
606:           		timeout_supply_fuel = period_load_fuel; //переход в другой режим начнётся с подкидывания топлива
1F2E  CF36     MOVFF period_load_fuel, timeout_supply_fuel
1F30  F0CF     NOP
1F32  CF37     MOVFF 0xF37, 0xD0
1F34  F0D0     NOP
607:           		timeout = 0;
1F36  010F     MOVLB 0xF
1F38  6B38     CLRF 0x38, BANKED
1F3A  6B39     CLRF 0x39, BANKED
608:           		return TRUE; //температура упала до значения не более установленной минус 2oC 
1F3C  0E01     MOVLW 0x1
1F3E  D07B     BRA 0x2036
609:           	}
610:           	else
1F40  D07A     BRA 0x2036
611:           	{
612:           		switch (phase_cycle)
1F42  0100     MOVLB 0x0
1F44  51D7     MOVF phase_cycle, W, BANKED
1F46  0A01     XORLW 0x1
1F48  E04F     BZ 0x1FE8
1F4A  0A01     XORLW 0x1
1F4C  E001     BZ 0x1F50
1F4E  D071     BRA 0x2032
613:           		{
614:           			case PAUSE_IN_CYCLE: //отсчёт времени паузы вентилятора в подрежиме тления топлива	
615:           				if( timeout++ == ( uint16_t ) M_Mngm_parameters_buffer.menu_parameters.Fan.time_pause_in_cycle
1F50  010F     MOVLB 0xF
1F52  CF38     MOVFF timeout, __tmp_0
1F54  F032     NOP
1F56  CF39     MOVFF 0xF39, 0x33
1F58  F033     NOP
1F5A  2B38     INCF 0x38, F, BANKED
1F5C  0E00     MOVLW 0x0
1F5E  2339     ADDWFC 0x39, F, BANKED
616:           										[ M_Mngm_parameters_buffer.menu_parameters.fuel_type ]*1000)
1F60  010F     MOVLB 0xF
1F62  5129     MOVF 0x29, W, BANKED
1F64  6AEA     CLRF FSR0H, ACCESS
1F66  0F16     ADDLW 0x16
1F68  6EE9     MOVWF FSR0, ACCESS
1F6A  0E0F     MOVLW 0xF
1F6C  22EA     ADDWFC FSR0H, F, ACCESS
1F6E  50EF     MOVF INDF0, W, ACCESS
1F70  6E34     MOVWF 0x34, ACCESS
1F72  6A35     CLRF 0x35, ACCESS
1F74  0EE8     MOVLW 0xE8
1F76  0235     MULWF 0x35, ACCESS
1F78  CFF3     MOVFF PROD, 0x35
1F7A  F035     NOP
1F7C  0E03     MOVLW 0x3
1F7E  0234     MULWF 0x34, ACCESS
1F80  50F3     MOVF PROD, W, ACCESS
1F82  2635     ADDWF 0x35, F, ACCESS
1F84  0EE8     MOVLW 0xE8
1F86  0234     MULWF 0x34, ACCESS
1F88  CFF3     MOVFF PROD, 0x34
1F8A  F034     NOP
1F8C  50F4     MOVF PRODH, W, ACCESS
1F8E  2635     ADDWF 0x35, F, ACCESS
1F90  5034     MOVF 0x34, W, ACCESS
1F92  1832     XORWF __tmp_0, W, ACCESS
1F94  E102     BNZ 0x1F9A
1F96  5035     MOVF 0x35, W, ACCESS
1F98  1833     XORWF 0x33, W, ACCESS
1F9A  E125     BNZ 0x1FE6
617:           				{
618:           					timeout = 0;
1F9C  010F     MOVLB 0xF
1F9E  6B38     CLRF 0x38, BANKED
1FA0  6B39     CLRF 0x39, BANKED
619:           					phase_cycle = WORK_IN_CYCLE;
1FA2  0100     MOVLB 0x0
1FA4  0E01     MOVLW 0x1
1FA6  6FD7     MOVWF phase_cycle, BANKED
620:           					M_fan_set_ctrl_fan(ON);
1FA8  0E01     MOVLW 0x1
1FAA  6EE6     MOVWF POSTINC1, ACCESS
1FAC  ECE0     CALL 0x41C0, 0
1FAE  F020     NOP
1FB0  52E5     MOVF POSTDEC1, F, ACCESS
621:           					pFanLevel = &M_Mngm_parameters_buffer.menu_parameters.Fan.level_fan_in_smoldering
622:           										[M_Mngm_parameters_buffer.menu_parameters.fuel_type];
1FB2  010F     MOVLB 0xF
1FB4  5129     MOVF 0x29, W, BANKED
1FB6  0100     MOVLB 0x0
1FB8  6FD9     MOVWF pFanLevel, BANKED
1FBA  6BDA     CLRF 0xDA, BANKED
1FBC  0E25     MOVLW 0x25
1FBE  0100     MOVLB 0x0
1FC0  27D9     ADDWF pFanLevel, F, BANKED
1FC2  0E0F     MOVLW 0xF
1FC4  0100     MOVLB 0x0
1FC6  23DA     ADDWFC 0xDA, F, BANKED
623:           					M_fan_set_level_fan(*pFanLevel);
1FC8  C0D9     MOVFF pFanLevel, FSR0
1FCA  FFE9     NOP
1FCC  C0DA     MOVFF 0xDA, FSR0H
1FCE  FFEA     NOP
1FD0  50EF     MOVF INDF0, W, ACCESS
1FD2  6EE6     MOVWF POSTINC1, ACCESS
1FD4  ECD5     CALL 0x41AA, 0
1FD6  F020     NOP
1FD8  52E5     MOVF POSTDEC1, F, ACCESS
624:           					fan_param_offset = INDEX_ROTATIONAL_SPEED_FAN_MIN_SMOLDERING + M_Mngm_parameters_buffer.menu_parameters.fuel_type * 2;
1FDA  010F     MOVLB 0xF
1FDC  5129     MOVF 0x29, W, BANKED
1FDE  24E8     ADDWF WREG, W, ACCESS
1FE0  0F48     ADDLW 0x48
1FE2  0100     MOVLB 0x0
1FE4  6FD8     MOVWF fan_param_offset, BANKED
625:           				}
626:           			break;
1FE6  D025     BRA 0x2032
627:           			case WORK_IN_CYCLE:	//отсчёт времени работы вентилятора в подрежиме тления топлива
628:           				if( timeout++ == ( uint16_t ) M_Mngm_parameters_buffer.menu_parameters.Fan.time_work_in_cycle
1FE8  010F     MOVLB 0xF
1FEA  CF38     MOVFF timeout, __tmp_0
1FEC  F032     NOP
1FEE  CF39     MOVFF 0xF39, 0x33
1FF0  F033     NOP
1FF2  2B38     INCF 0x38, F, BANKED
1FF4  0E00     MOVLW 0x0
1FF6  2339     ADDWFC 0x39, F, BANKED
629:           										[ M_Mngm_parameters_buffer.menu_parameters.fuel_type ]*10 )
1FF8  010F     MOVLB 0xF
1FFA  5129     MOVF 0x29, W, BANKED
1FFC  6AEA     CLRF FSR0H, ACCESS
1FFE  0F13     ADDLW 0x13
2000  6EE9     MOVWF FSR0, ACCESS
2002  0E0F     MOVLW 0xF
2004  22EA     ADDWFC FSR0H, F, ACCESS
2006  50EF     MOVF INDF0, W, ACCESS
2008  0D0A     MULLW 0xA
200A  CFF3     MOVFF PROD, 0x34
200C  F034     NOP
200E  CFF4     MOVFF PRODH, 0x35
2010  F035     NOP
2012  5034     MOVF 0x34, W, ACCESS
2014  1832     XORWF __tmp_0, W, ACCESS
2016  E102     BNZ 0x201C
2018  5035     MOVF 0x35, W, ACCESS
201A  1833     XORWF 0x33, W, ACCESS
201C  E109     BNZ 0x2030
630:           				{
631:           					timeout = 0;
201E  010F     MOVLB 0xF
2020  6B38     CLRF 0x38, BANKED
2022  6B39     CLRF 0x39, BANKED
632:           					phase_cycle = PAUSE_IN_CYCLE;
2024  0100     MOVLB 0x0
2026  6BD7     CLRF phase_cycle, BANKED
633:           					M_fan_set_ctrl_fan(OFF);
2028  6AE6     CLRF POSTINC1, ACCESS
202A  ECE0     CALL 0x41C0, 0
202C  F020     NOP
202E  52E5     MOVF POSTDEC1, F, ACCESS
634:           				}	
635:           			break;
2030  D000     BRA 0x2032
636:           		}
637:           		return FALSE;
2032  0E00     MOVLW 0x0
2034  D000     BRA 0x2036
638:           	}
639:           }
2036  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_logic_inputs/module_logic_inputs.c  -------
1:             #include "module_logic_inputs.h"
2:             #include "module_management.h"
3:             #include "module_sound.h"
4:             #include "menu.h"
5:             #include <p18cxxx.h>
6:             
7:             
8:             /*Определения*/
9:             //Ножки портов в/в концевиков(через указатели не выходит, делаем говнокодом)
10:            #define LS_DISPENSER_START_PIN 		 PORTBbits.RB5       //дозатор(стартовый)
11:            #define LS_DISPENSER_START_TRIS		 TRISBbits.TRISB5
12:            #define LS_DISPENSER_FINISH_PIN		 PORTJbits.RJ7       //дозатор(финишный)
13:            #define LS_DISPENSER_FINISH_TRIS     TRISJbits.TRISJ7
14:            #define LS_SHATTER_START_PIN		 PORTCbits.RC0       //заслонка(стартовый)
15:            #define LS_SHATTER_START_TRIS		 TRISCbits.TRISC0       
16:            #define LS_SHATTER_FINISH_PIN		 PORTJbits.RJ4       //заслонка(финишный)
17:            #define LS_SHATTER_FINISH_TRIS		 TRISJbits.TRISJ4
18:            #define LS_HOPPER_COVER_PIN			 PORTBbits.RB4       //крышка
19:            #define LS_HOPPER_COVER_TRIS		 TRISBbits.TRISB4
20:            #define LS_AGITATOR_PIN				 PORTBbits.RB1       //ворошитель
21:            #define LS_AGITATOR_TRIS			 TRISBbits.TRISB1 
22:            #define LS_SHATTER_AFTER_FINISH_PIN	 PORTJbits.RJ6       //заслонка(после финишного)
23:            #define LS_SHATTER_AFTER_FINISH_TRIS TRISJbits.TRISJ6
24:            
25:            #ifdef ENABLE_ASH_CLEANER_INDUCIVE_SENSORS
26:                #define LS_CLEAN_ASH_START_PIN       PORTCbits.RC1       //чистка золы (стартовый)
27:                #define LS_CLEAN_ASH_START_TRIS      TRISCbits.TRISC1   
28:                #define LS_CLEAN_ASH_FINISH_PIN      PORTCbits.RC2       //чистка золы (финишный)
29:                #define LS_CLEAN_ASH_FINISH_TRIS     TRISCbits.TRISC2
30:            #endif
31:            
32:            #define KEY_INC_TRIS                 TRISJbits.TRISJ3
33:            #define KEY_DEC_TRIS                 TRISBbits.TRISB0   
34:            #define KEY_MENU_TRIS                TRISJbits.TRISJ2
35:            #define KEY_ESC_TRIS                 TRISJbits.TRISJ1
36:            
37:            #define LS_IS_WORKED_TO_NC              1
38:            #define LS_IS_WORKED_TO_NO              0
39:            
40:            
41:            #define NO_KEY_PRESSED_ON_PORTJ         0b00001110U
42:            #define NO_KEY_PRESSED_ON_PORTB         0b00000001U
43:            #define THRESHOLD_LONG_PRESSED          5000U
44:            #define THRESHOLD_ACCUMULATION          10U
45:            
46:            
47:            //Разрешение внутренних подтягивающих резисторов на PORTB, PORTJ
48:            #define PULLUPS_ENABLE \
49:            {                       \
50:                INTCON2bits.RBPU = 0; \
51:            	PORTGbits.RJPU = 1; \
52:            }
53:            
54:            //Запрет внутренних подтягивающих резисторов на PORTB, PORTJ
55:            #define PULLUPS_DISABLE \
56:            {                       \
57:                INTCON2bits.RBPU = 1; \
58:            	PORTGbits.RJPU = 0; \
59:            }
60:            
61:            
62:            KeyState M_LI_Key_State = {0, 0, 0};
63:            
64:            LimitSwitch M_LI_Limit_Sw = {0};
65:            BOOL* ptr_to_ls = &(M_LI_Limit_Sw.ls_shatter_after_finish_state);
66:            
67:            //Функция инициализации модуля обработки логических входов
68:            void M_LI_ctor( void )
69:            {
70:            
71:                LS_DISPENSER_START_TRIS	     = IN;
3B3A  8A93     BSF TRISB, 5, ACCESS
72:                LS_DISPENSER_FINISH_TRIS     = IN;
3B3C  8E9A     BSF TRISJ, 7, ACCESS
73:                LS_SHATTER_START_TRIS		 = IN; 
3B3E  8094     BSF TRISC, 0, ACCESS
74:                LS_SHATTER_FINISH_TRIS		 = IN; 
3B40  889A     BSF TRISJ, 4, ACCESS
75:                LS_HOPPER_COVER_TRIS		 = IN; 
3B42  8893     BSF TRISB, 4, ACCESS
76:                LS_AGITATOR_TRIS			 = IN; 
3B44  8293     BSF TRISB, 1, ACCESS
77:                LS_SHATTER_AFTER_FINISH_TRIS = IN;
3B46  8C9A     BSF TRISJ, 6, ACCESS
78:                #ifdef ENABLE_ASH_CLEANER_INDUCIVE_SENSORS
79:                    LS_CLEAN_ASH_START_TRIS      = IN;
80:                    LS_CLEAN_ASH_FINISH_TRIS     = IN;
81:                #endif
82:                KEY_INC_TRIS  = IN;
3B48  869A     BSF TRISJ, 3, ACCESS
83:                KEY_DEC_TRIS  = IN;
3B4A  8093     BSF TRISB, 0, ACCESS
84:                KEY_MENU_TRIS = IN;
3B4C  849A     BSF TRISJ, 2, ACCESS
85:                KEY_ESC_TRIS  = IN;
3B4E  829A     BSF TRISJ, 1, ACCESS
86:            }
3B50  0012     RETURN 0
87:            
88:            BOOL* M_LI_get_ptr_to_ls(void)
89:            {
90:            	return ptr_to_ls;
3B52  C0E5     MOVFF ptr_to_ls, PROD
3B54  FFF3     NOP
3B56  C0E6     MOVFF 0xE6, PRODH
3B58  FFF4     NOP
3B5A  D000     BRA 0x3B5C
91:            }
3B5C  0012     RETURN 0
92:            
93:            void M_LI_set_ptr_to_ls(BOOL* ls)
3B5E  CFD9     MOVFF FSR2, POSTINC1
3B60  FFE6     NOP
3B62  CFE1     MOVFF FSR1, FSR2
3B64  FFD9     NOP
94:            {
95:            	ptr_to_ls = ls;
3B66  0EFD     MOVLW 0xFD
3B68  CFDB     MOVFF PLUSW2, ptr_to_ls
3B6A  F0E5     NOP
3B6C  0EFE     MOVLW 0xFE
3B6E  CFDB     MOVFF PLUSW2, 0xE6
3B70  F0E6     NOP
96:            }
3B72  52E5     MOVF POSTDEC1, F, ACCESS
3B74  CFE7     MOVFF INDF1, FSR2
3B76  FFD9     NOP
3B78  0012     RETURN 0
97:            
98:            LimitSwitch* M_LI_Get_Limit_Switches(void)
99:            {
100:           	return &M_LI_Limit_Sw;
3B7A  0EDE     MOVLW 0xDE
3B7C  6E32     MOVWF __tmp_0, ACCESS
3B7E  0E00     MOVLW 0x0
3B80  6E33     MOVWF 0x33, ACCESS
3B82  C032     MOVFF __tmp_0, PROD
3B84  FFF3     NOP
3B86  C033     MOVFF 0x33, PRODH
3B88  FFF4     NOP
3B8A  D000     BRA 0x3B8C
101:           }
3B8C  0012     RETURN 0
102:           
103:           KeyState* M_LI_Get_Key_State(void) 
104:           {
105:           	return &M_LI_Key_State;
3B8E  0EDB     MOVLW 0xDB
3B90  6E32     MOVWF __tmp_0, ACCESS
3B92  0E00     MOVLW 0x0
3B94  6E33     MOVWF 0x33, ACCESS
3B96  C032     MOVFF __tmp_0, PROD
3B98  FFF3     NOP
3B9A  C033     MOVFF 0x33, PRODH
3B9C  FFF4     NOP
3B9E  D000     BRA 0x3BA0
106:           }
3BA0  0012     RETURN 0
107:           
108:           
109:           BOOL M_LI_is_LS_worked(uint8_t ls_pin, BOOL ls_direction) 
3BA2  CFD9     MOVFF FSR2, POSTINC1
3BA4  FFE6     NOP
3BA6  CFE1     MOVFF FSR1, FSR2
3BA8  FFD9     NOP
3BAA  52E6     MOVF POSTINC1, F, ACCESS
110:           {
111:           	BOOL temp;
112:               #ifdef  ENABLE_PULLUPS_ON_PORTB_AND_PORTJ
113:                   PULLUPS_ENABLE;
3BAC  9EF1     BCF INTCON2, 7, ACCESS
3BAE  8A86     BSF PORTG, 5, ACCESS
114:               #endif
115:                   temp = ls_pin ^ ls_direction;
3BB0  0EFD     MOVLW 0xFD
3BB2  CFDB     MOVFF PLUSW2, POSTINC1
3BB4  FFE6     NOP
3BB6  0EFE     MOVLW 0xFE
3BB8  50DB     MOVF PLUSW2, W, ACCESS
3BBA  52E5     MOVF POSTDEC1, F, ACCESS
3BBC  18E7     XORWF INDF1, W, ACCESS
3BBE  6EDF     MOVWF INDF2, ACCESS
116:               #ifdef  ENABLE_PULLUPS_ON_PORTB_AND_PORTJ
117:                   PULLUPS_DISABLE;
3BC0  8EF1     BSF INTCON2, 7, ACCESS
3BC2  9A86     BCF PORTG, 5, ACCESS
118:               #endif
119:               return temp;
3BC4  50DF     MOVF INDF2, W, ACCESS
3BC6  D000     BRA 0x3BC8
120:           }
3BC8  52E5     MOVF POSTDEC1, F, ACCESS
3BCA  52E5     MOVF POSTDEC1, F, ACCESS
3BCC  CFE7     MOVFF INDF1, FSR2
3BCE  FFD9     NOP
3BD0  0012     RETURN 0
121:           
122:           //Опрос концевиков (или индуктивных датчиков)
123:           void M_LI_ls_question(void)
124:           {
125:           	M_LI_Limit_Sw.ls_dispenser_start_state =      M_LI_is_LS_worked(LS_DISPENSER_START_PIN, LS_IS_WORKED_TO_NC);  
3BD2  0E01     MOVLW 0x1
3BD4  6EE6     MOVWF POSTINC1, ACCESS
3BD6  5081     MOVF PORTB, W, ACCESS
3BD8  0B20     ANDLW 0x20
3BDA  E001     BZ 0x3BDE
3BDC  0E01     MOVLW 0x1
3BDE  6EE6     MOVWF POSTINC1, ACCESS
3BE0  DFE0     RCALL M_LI_is_LS_worked
3BE2  52E5     MOVF POSTDEC1, F, ACCESS
3BE4  52E5     MOVF POSTDEC1, F, ACCESS
3BE6  0100     MOVLB 0x0
3BE8  6FDE     MOVWF M_LI_Limit_Sw, BANKED
126:           	M_LI_Limit_Sw.ls_dispenser_finish_state =     M_LI_is_LS_worked(LS_DISPENSER_FINISH_PIN, LS_IS_WORKED_TO_NC);
3BEA  0E01     MOVLW 0x1
3BEC  6EE6     MOVWF POSTINC1, ACCESS
3BEE  5088     MOVF PORTJ, W, ACCESS
3BF0  0B80     ANDLW 0x80
3BF2  E001     BZ 0x3BF6
3BF4  0E01     MOVLW 0x1
3BF6  6EE6     MOVWF POSTINC1, ACCESS
3BF8  DFD4     RCALL M_LI_is_LS_worked
3BFA  52E5     MOVF POSTDEC1, F, ACCESS
3BFC  52E5     MOVF POSTDEC1, F, ACCESS
3BFE  0100     MOVLB 0x0
3C00  6FDF     MOVWF 0xDF, BANKED
127:           	M_LI_Limit_Sw.ls_shatter_start_state =        M_LI_is_LS_worked(LS_SHATTER_START_PIN, LS_IS_WORKED_TO_NC);  
3C02  0E01     MOVLW 0x1
3C04  6EE6     MOVWF POSTINC1, ACCESS
3C06  5082     MOVF PORTC, W, ACCESS
3C08  0B01     ANDLW 0x1
3C0A  6EE6     MOVWF POSTINC1, ACCESS
3C0C  DFCA     RCALL M_LI_is_LS_worked
3C0E  52E5     MOVF POSTDEC1, F, ACCESS
3C10  52E5     MOVF POSTDEC1, F, ACCESS
3C12  0100     MOVLB 0x0
3C14  6FE0     MOVWF 0xE0, BANKED
128:           	M_LI_Limit_Sw.ls_shatter_finish_state =       M_LI_is_LS_worked(LS_SHATTER_FINISH_PIN, LS_IS_WORKED_TO_NC);
3C16  0E01     MOVLW 0x1
3C18  6EE6     MOVWF POSTINC1, ACCESS
3C1A  5088     MOVF PORTJ, W, ACCESS
3C1C  0B10     ANDLW 0x10
3C1E  E001     BZ 0x3C22
3C20  0E01     MOVLW 0x1
3C22  6EE6     MOVWF POSTINC1, ACCESS
3C24  DFBE     RCALL M_LI_is_LS_worked
3C26  52E5     MOVF POSTDEC1, F, ACCESS
3C28  52E5     MOVF POSTDEC1, F, ACCESS
3C2A  0100     MOVLB 0x0
3C2C  6FE1     MOVWF 0xE1, BANKED
129:           	M_LI_Limit_Sw.ls_agitator_state =             M_LI_is_LS_worked(LS_AGITATOR_PIN, LS_IS_WORKED_TO_NC);  
3C2E  0E01     MOVLW 0x1
3C30  6EE6     MOVWF POSTINC1, ACCESS
3C32  5081     MOVF PORTB, W, ACCESS
3C34  0B02     ANDLW 0x2
3C36  E001     BZ 0x3C3A
3C38  0E01     MOVLW 0x1
3C3A  6EE6     MOVWF POSTINC1, ACCESS
3C3C  DFB2     RCALL M_LI_is_LS_worked
3C3E  52E5     MOVF POSTDEC1, F, ACCESS
3C40  52E5     MOVF POSTDEC1, F, ACCESS
3C42  0100     MOVLB 0x0
3C44  6FE3     MOVWF 0xE3, BANKED
130:           	M_LI_Limit_Sw.ls_hopper_cover_state =         M_LI_is_LS_worked(LS_HOPPER_COVER_PIN, LS_IS_WORKED_TO_NC);
3C46  0E01     MOVLW 0x1
3C48  6EE6     MOVWF POSTINC1, ACCESS
3C4A  5081     MOVF PORTB, W, ACCESS
3C4C  0B10     ANDLW 0x10
3C4E  E001     BZ 0x3C52
3C50  0E01     MOVLW 0x1
3C52  6EE6     MOVWF POSTINC1, ACCESS
3C54  DFA6     RCALL M_LI_is_LS_worked
3C56  52E5     MOVF POSTDEC1, F, ACCESS
3C58  52E5     MOVF POSTDEC1, F, ACCESS
3C5A  0100     MOVLB 0x0
3C5C  6FE4     MOVWF 0xE4, BANKED
131:           	M_LI_Limit_Sw.ls_shatter_after_finish_state = M_LI_is_LS_worked(LS_SHATTER_AFTER_FINISH_PIN, LS_IS_WORKED_TO_NC);
3C5E  0E01     MOVLW 0x1
3C60  6EE6     MOVWF POSTINC1, ACCESS
3C62  5088     MOVF PORTJ, W, ACCESS
3C64  0B40     ANDLW 0x40
3C66  E001     BZ 0x3C6A
3C68  0E01     MOVLW 0x1
3C6A  6EE6     MOVWF POSTINC1, ACCESS
3C6C  DF9A     RCALL M_LI_is_LS_worked
3C6E  52E5     MOVF POSTDEC1, F, ACCESS
3C70  52E5     MOVF POSTDEC1, F, ACCESS
3C72  0100     MOVLB 0x0
3C74  6FE2     MOVWF 0xE2, BANKED
132:               #ifdef ENABLE_ASH_CLEANER_INDUCIVE_SENSORS
133:                   M_LI_Limit_Sw.ls_clean_ash_start_state =      M_LI_is_LS_worked(LS_CLEAN_ASH_START_PIN, LS_IS_WORKED_TO_NC);
134:                   M_LI_Limit_Sw.ls_clean_ash_finish_state =     M_LI_is_LS_worked(LS_CLEAN_ASH_FINISH_PIN, LS_IS_WORKED_TO_NC);
135:               #endif     
136:           }
3C76  0012     RETURN 0
137:           
138:           //Опров кнопок
139:           void M_LI_Key_Question(void)
3C78  CFD9     MOVFF FSR2, POSTINC1
3C7A  FFE6     NOP
3C7C  CFE1     MOVFF FSR1, FSR2
3C7E  FFD9     NOP
3C80  0E03     MOVLW 0x3
3C82  26E1     ADDWF FSR1, F, ACCESS
140:           {
141:           	uint8_t temp_PORTB, temp_PORTJ, i;
142:           	static uint16_t M_LI_accum_pressed = 0;
143:           	
144:           	#ifdef  ENABLE_PULLUPS_ON_PORTB_AND_PORTJ
145:                   PULLUPS_ENABLE;
3C84  9EF1     BCF INTCON2, 7, ACCESS
3C86  8A86     BSF PORTG, 5, ACCESS
146:               #endif
147:           	temp_PORTB = PORTB & NO_KEY_PRESSED_ON_PORTB;
3C88  0E01     MOVLW 0x1
3C8A  1481     ANDWF PORTB, W, ACCESS
3C8C  6EDF     MOVWF INDF2, ACCESS
148:           	temp_PORTJ = PORTJ & NO_KEY_PRESSED_ON_PORTJ;
3C8E  0E0E     MOVLW 0xE
3C90  1488     ANDWF PORTJ, W, ACCESS
3C92  6EE7     MOVWF INDF1, ACCESS
3C94  0E01     MOVLW 0x1
3C96  CFE7     MOVFF INDF1, PLUSW2
3C98  FFDB     NOP
149:           	#ifdef  ENABLE_PULLUPS_ON_PORTB_AND_PORTJ
150:                   PULLUPS_DISABLE;
3C9A  8EF1     BSF INTCON2, 7, ACCESS
3C9C  9A86     BCF PORTG, 5, ACCESS
151:               #endif
152:               temp_PORTB += temp_PORTJ; 	//упаковка в temp_PORTB прочитанных кнопок (биты 3,2,1,0)
3C9E  0E01     MOVLW 0x1
3CA0  50DB     MOVF PLUSW2, W, ACCESS
3CA2  26DF     ADDWF INDF2, F, ACCESS
153:           	
154:           	if(!M_LI_Key_State.Any_Key_pressed) //если никакая кнопка не была нажата ранее
3CA4  0100     MOVLB 0x0
3CA6  51DB     MOVF M_LI_Key_State, W, BANKED
3CA8  E121     BNZ 0x3CEC
155:           	{
156:           		if (temp_PORTB != NO_KEY_PRESSED)   //какая-либо кнопка нажата
3CAA  0E0F     MOVLW 0xF
3CAC  5CDF     SUBWF INDF2, W, ACCESS
3CAE  E01D     BZ 0x3CEA
157:           		{
158:           			if(M_LI_accum_pressed++ == THRESHOLD_ACCUMULATION) //накоплен порог нажатия на кнопку
3CB0  0100     MOVLB 0x0
3CB2  C0E7     MOVFF 0xE7, __tmp_0
3CB4  F032     NOP
3CB6  C0E8     MOVFF 0xE8, 0x33
3CB8  F033     NOP
3CBA  2BE7     INCF 0xE7, F, BANKED
3CBC  0E00     MOVLW 0x0
3CBE  23E8     ADDWFC 0xE8, F, BANKED
3CC0  0E0A     MOVLW 0xA
3CC2  1832     XORWF __tmp_0, W, ACCESS
3CC4  E101     BNZ 0x3CC8
3CC6  5033     MOVF 0x33, W, ACCESS
3CC8  E110     BNZ 0x3CEA
159:           			{
160:           				
161:           				M_LI_Key_State.M_LI_Code_Key = temp_PORTB; 
3CCA  CFDF     MOVFF INDF2, 0xDD
3CCC  F0DD     NOP
162:           				M_LI_Key_State.Any_Key_pressed = ON;	
3CCE  0100     MOVLB 0x0
3CD0  0E01     MOVLW 0x1
3CD2  6FDB     MOVWF M_LI_Key_State, BANKED
163:           				M_LI_Key_State.Long_pressed = ON; //установить флаг длительного нажатия
3CD4  0100     MOVLB 0x0
3CD6  0E01     MOVLW 0x1
3CD8  6FDC     MOVWF 0xDC, BANKED
164:           				M_LI_accum_pressed = 0; 
3CDA  0100     MOVLB 0x0
3CDC  6BE7     CLRF 0xE7, BANKED
3CDE  6BE8     CLRF 0xE8, BANKED
165:           				M_Sound_set_button_submergence (ON);  //установить флаг подзвучки кнопки
3CE0  0E01     MOVLW 0x1
3CE2  6EE6     MOVWF POSTINC1, ACCESS
3CE4  ECD2     CALL 0x47A4, 0
3CE6  F023     NOP
3CE8  52E5     MOVF POSTDEC1, F, ACCESS
166:           			}
167:           		}
168:           	}
169:           	else 
3CEA  D036     BRA 0x3D58
170:           	{
171:           			if (temp_PORTB == NO_KEY_PRESSED) //кнопка нажата и отпущена (короткое нажатие)
3CEC  0E0F     MOVLW 0xF
3CEE  5CDF     SUBWF INDF2, W, ACCESS
3CF0  E111     BNZ 0x3D14
172:           			{
173:           				if(M_LI_Key_State.Long_pressed)
3CF2  0100     MOVLB 0x0
3CF4  51DC     MOVF 0xDC, W, BANKED
3CF6  E006     BZ 0x3D04
174:           				{	
175:           					M_LI_Key_State.M_LI_Code_Key &= 0x7E;
3CF8  0E7E     MOVLW 0x7E
3CFA  0100     MOVLB 0x0
3CFC  17DD     ANDWF 0xDD, F, BANKED
176:           					M_LI_Key_State.M_LI_Code_Key += 0x80;  //маркер того, что кнопка нажата и отпущена
3CFE  0E80     MOVLW 0x80
3D00  0100     MOVLB 0x0
3D02  27DD     ADDWF 0xDD, F, BANKED
177:           				}
178:           				M_LI_Key_State.Any_Key_pressed = FALSE;	
3D04  0100     MOVLB 0x0
3D06  6BDB     CLRF M_LI_Key_State, BANKED
179:           				M_LI_accum_pressed = 0;
3D08  0100     MOVLB 0x0
3D0A  6BE7     CLRF 0xE7, BANKED
3D0C  6BE8     CLRF 0xE8, BANKED
180:           				M_LI_Key_State.Long_pressed = FALSE;
3D0E  0100     MOVLB 0x0
3D10  6BDC     CLRF 0xDC, BANKED
181:           			}
182:           			else //если кнопка нажата и не была отпущена при коротком нажатии/отпускании 
3D12  D022     BRA 0x3D58
183:           			{
184:           				if(M_LI_Key_State.Long_pressed)
3D14  0100     MOVLB 0x0
3D16  51DC     MOVF 0xDC, W, BANKED
3D18  E01F     BZ 0x3D58
185:           				{
186:           					if(M_LI_accum_pressed++ >= THRESHOLD_LONG_PRESSED) // прошло время длительного нажатия CountLongPressed 
3D1A  0100     MOVLB 0x0
3D1C  C0E7     MOVFF 0xE7, __tmp_0
3D1E  F032     NOP
3D20  C0E8     MOVFF 0xE8, 0x33
3D22  F033     NOP
3D24  2BE7     INCF 0xE7, F, BANKED
3D26  0E00     MOVLW 0x0
3D28  23E8     ADDWFC 0xE8, F, BANKED
3D2A  0E88     MOVLW 0x88
3D2C  5C32     SUBWF __tmp_0, W, ACCESS
3D2E  0E13     MOVLW 0x13
3D30  5833     SUBWFB 0x33, W, ACCESS
3D32  E312     BNC 0x3D58
187:           					{
188:           						M_LI_accum_pressed = 0;
3D34  0100     MOVLB 0x0
3D36  6BE7     CLRF 0xE7, BANKED
3D38  6BE8     CLRF 0xE8, BANKED
189:           						M_LI_Key_State.Long_pressed = FALSE;
3D3A  0100     MOVLB 0x0
3D3C  6BDC     CLRF 0xDC, BANKED
190:           						M_LI_Key_State.M_LI_Code_Key &= 0x7E;
3D3E  0E7E     MOVLW 0x7E
3D40  0100     MOVLB 0x0
3D42  17DD     ANDWF 0xDD, F, BANKED
191:           						M_LI_Key_State.M_LI_Code_Key += 0x01;
3D44  0100     MOVLB 0x0
3D46  2BDD     INCF 0xDD, F, BANKED
192:           						M_LI_Key_State.Any_Key_pressed = TRUE;	
3D48  0100     MOVLB 0x0
3D4A  0E01     MOVLW 0x1
3D4C  6FDB     MOVWF M_LI_Key_State, BANKED
193:           						M_Sound_set_button_submergence (ON);  //установить флаг подзвучки кнопки
3D4E  0E01     MOVLW 0x1
3D50  6EE6     MOVWF POSTINC1, ACCESS
3D52  ECD2     CALL 0x47A4, 0
3D54  F023     NOP
3D56  52E5     MOVF POSTDEC1, F, ACCESS
194:           					}
195:           				}
196:           			}
197:           	}
198:           }
3D58  0E03     MOVLW 0x3
3D5A  5CE1     SUBWF FSR1, W, ACCESS
3D5C  E202     BC 0x3D62
3D5E  6AE1     CLRF FSR1, ACCESS
3D60  52E5     MOVF POSTDEC1, F, ACCESS
3D62  6EE1     MOVWF FSR1, ACCESS
3D64  52E5     MOVF POSTDEC1, F, ACCESS
3D66  CFE7     MOVFF INDF1, FSR2
3D68  FFD9     NOP
3D6A  0012     RETURN 0
199:           
200:           
201:           void M_LI_Run(void)
202:           {
203:           		
204:           	//Опрос кнопок (не опрашивать в режиме "Пауза")
205:           	if(M_Mngm_Get_state() != STATE_PAUSE)
3D6C  ECA7     CALL 0x154E, 0
3D6E  F00A     NOP
3D70  0803     SUBLW 0x3
3D72  E009     BZ 0x3D86
206:           	{
207:           		//Опрос кнопок
208:                   M_LI_Key_Question();
3D74  DF81     RCALL M_LI_Key_Question
209:           		
210:           		//Отработка кнопок
211:           		Menu_Key_handler(&M_LI_Key_State);	
3D76  0EDB     MOVLW 0xDB
3D78  6EE6     MOVWF POSTINC1, ACCESS
3D7A  0E00     MOVLW 0x0
3D7C  6EE6     MOVWF POSTINC1, ACCESS
3D7E  EC4E     CALL 0x229C, 0
3D80  F011     NOP
3D82  52E5     MOVF POSTDEC1, F, ACCESS
3D84  52E5     MOVF POSTDEC1, F, ACCESS
212:           	}	
213:           		/*Опрос концевиков и заполнение структуры состояний концевиков 
214:                   (сделано говнокодом, так как при работе с портами через 
215:           		указатели лажа) */
216:           		M_LI_ls_question();
3D86  DF25     RCALL M_LI_ls_question
217:           	
218:           }
3D88  0012     RETURN 0
219:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_indication/module_indication.c  -----------
1:             #include "module_indication.h"
2:             #include "module_management.h"
3:             #include "module_analog_inputs.h"
4:             #include "menu.h"
5:             #include "module_motor.h"
6:             #include "module_logic_inputs.h"
7:             #include "main.h"
8:             #include <p18cxxx.h>
9:             #include "osa.h"
10:            #include "spi.h"
11:            #include "logicAnalyzer.h"
12:            
13:            
14:            #define INDEX_OF_BLANK_SYMBOL	(sizeof (M_Ind_Portraits) / sizeof (M_Ind_Portraits[0])) - 1 
15:            #define IT_IS_A_TEXT_SYM_AREA 	(sizeof (M_Ind_Portraits) / sizeof (M_Ind_Portraits[0])) - 14
16:            #define INDEX_OF_AREA_FUEL_TYPE (sizeof (M_Ind_Portraits) / sizeof (M_Ind_Portraits[0])) - 7
17:            
18:            #define ANODE_FIRST_PORT			  LATE
19:            #define ANODE_SECOND_PORT			  LATD
20:            #define ANODES_ARE_OFF_ON_FIRST_PORT  0b11000000
21:            #define ANODES_ARE_OFF_ON_SECOND_PORT 0b00001111
22:            #define ANODE_1_PIN                   LATEbits.LATE6
23:            #define ANODE_1_TRIS                  TRISEbits.TRISE6
24:            #define ANODE_2_PIN                   LATEbits.LATE7
25:            #define ANODE_2_TRIS                  TRISEbits.TRISE7
26:            #define ANODE_3_PIN                   LATDbits.LATD0
27:            #define ANODE_3_TRIS                  TRISDbits.TRISD0
28:            #define ANODE_4_PIN                   LATDbits.LATD1
29:            #define ANODE_4_TRIS                  TRISDbits.TRISD1
30:            #define ANODE_5_PIN                   LATDbits.LATD2
31:            #define ANODE_5_TRIS                  TRISDbits.TRISD2
32:            #define ANODE_6_PIN                   LATDbits.LATD3
33:            #define ANODE_6_TRIS                  TRISDbits.TRISD3
34:            
35:            #define ANODE_IS_OFF                  1
36:            #define ANODE_IS_ON                   0
37:            
38:            #define QUANTITY_OF_FAMILIARITY 	  3U //6U
39:            
40:            #define LEFT_INDICATOR				  0
41:            #define MIDDLE_INDICATOR			  1
42:            #define RIGHT_INDICATOR				  2
43:            
44:            
45:            #define QUANTITY_OF_LEDS		 	  3U
46:            #define LED_BICOLOR_GREEN_PIN		  LATEbits.LATE5
47:            #define LED_BICOLOR_RED_PIN           LATEbits.LATE4
48:            #define LED_FAN_PIN					  LATEbits.LATE3
49:            #define LED_PUMP_PIN                  LATEbits.LATE2
50:            
51:            #define NO_BLINKING					  0U
52:            #define BLINKING_RED				  1
53:            #define BLINKING_GREEN				  2
54:            #define BLINKING_YELLOW				  3
55:            #define BLINKING_FAN_PIN			  4
56:            #define BLINKING_PUMP_PIN             5
57:            #define INDEX_OF_BICOLOR_LED		  0
58:            #define INDEX_OF_FAN_LED			  1
59:            #define INDEX_OF_PUMP_LED			  2
60:            
61:            
62:            //****** КОНСТАНТЫ***********************************
63:            
64:            /*Таблица портретов для семисегментного индикатора с общим катодом
65:               _ A _
66:              |     |
67:              F     B
68:              |_ G _|
69:              |     |
70:              E     C
71:              |_ D _|.H 
72:              
73:              |Символ   | Сегменты   |
74:                 0	 	 	ABCDEF	 		
75:                 1	   		BC	
76:                 2	   		ABDEG	
77:                 3  		ABCDG
78:                 4     		BCFG
79:                 5  		ACDFG
80:                 6     		ACDEFG
81:                 7  		ABC
82:                 8  		ABCDEFG
83:                 9     		ABCDFG
84:                 А  		ABCEFG
85:                 P 		 	ABEFG
86:                 U 			BCDEF
87:                 Е   		ADEFG
88:                 C    		ADEF
89:                 L    		DEF     
90:                 У	    	BCDFG	
91:                 Б	    	ACDEFG
92:                 П	    	ABCEF
93:                 t	    	DEFG
94:              	 F			AEFG
95:              	 d			BCDEG
96:              	 
97:              |Бит|		| Сегмент |
98:                7     		B
99:                6   		E	
100:               5	  		F
101:               4	  		A
102:               3	  		D
103:               2	  		H
104:               1	  		C
105:               0	  		G
106:            */
107:             
108:             const rom uint8_t M_Ind_Portraits[] =
109:             {
110:               0b00000101,		//0 ABCDEF !
111:               0b01111101,		//1 BC	
112:               0b00100110, 	//2 ABDEG !
113:               0b01100100,		//3 ABCDG !
114:               0b01011100,		//4 BCFG
115:               0b11000100,		//5 ACDFG
116:               0b10000100,		//6 ACDEFG
117:               0b01101101,		//7 ABC
118:               0b00000100,		//8	ABCDEFG
119:               0b01000100,		//9 ABCDFG
120:               0b00001100,		//A ABCEFG
121:               0b00001110,		//P ABEFG
122:               0b00010101,		//U BCDEF
123:               0b10000110,		//E ADEFG !
124:               0b10000111,		//C ADEF
125:               0b10010111,		//L DEF
126:               0b11000100,		//S (как 5) ACDFG
127:               0b01010100,		//У BCDFG
128:               0b10000100,		//Б (как 6) ACDEFG
129:               0b00001101,		//П ABCEF
130:               0b10010110,		//типа t DEFG
131:               0b10001110, 	//символ F AEFG
132:               0b00110100,		//символ d BCDEG
133:               0b11111111  	//пустой символ
134:             }; 
135:           
136:           const rom uint8_t decimals[/*QUANTITY_OF_FAMILIARITY*/] = {100,10,1,0 /*, 100, 10, 1*/};
137:           
138:           //Константа времён для отсчёта временных интервалов, использующихся в модуле индикации
139:           const rom uint16_t M_Ind_time_const[] = 
140:           {
141:           	5,  //5 секунд для отсчёта времени отображения версии ПО
142:           	500  //500 мс для отсчёта времени мигания (как семисегментного индикатора, так и светодиодов)
143:           };
144:           
145:           
146:           #define NO_DOT								0b11111111
147:           #define IS_DOT								0b11111011
148:           #define INDEX_IS_DOT						0
149:           #define INDEX_NO_DOT						1
150:           #define OFFSET_TO_SYMBOL_A                  0
151:           #define OFFSET_TO_SYMBOL_P                  1
152:           #define OFFSET_TO_SYMBOL_U                  2
153:           #define OFFSET_TO_SYMBOL_E					3
154:           #define OFFSET_TO_SYMBOL_C                  4
155:           #define OFFSET_TO_SYMBOL_L					5
156:           #define OFFSET_TO_SYMBOL_S                  6
157:           #define OFFSET_TO_SYMBOL_t					10
158:           #define OFFSET_TO_SYMBOL_F					11
159:           #define OFFSET_TO_SYMBOL_d					12
160:           #define LEFT_SYMBOL_WITH_DOT				1
161:           #define LEFT_SYMBOL_NO_DOT                  0
162:           
163:           
164:           typedef struct 
165:           {
166:           	uint16_t time_init;
167:           	uint16_t time_blink;
168:           	uint16_t time_auto_exit;
169:           	uint16_t time_blink_LED;
170:           }TIME_M_Ind;
171:           
172:           typedef struct 
173:           {
174:           	BOOL Flag_Blink_seven_segm;                                     //флаг мигания 7-сегментного индикатора
175:           	BOOL Flag_Blink_led[QUANTITY_OF_LEDS];                          //флаг мигания светодиодов 	
176:           	uint8_t index_of_text_sym[QUANTITY_OF_FAMILIARITY];             //смещение до поля текстовых символов A,P,U,E,C,L
177:           	uint8_t data[QUANTITY_OF_FAMILIARITY];                          //выводимые данные
178:           	uint8_t	dot[QUANTITY_OF_FAMILIARITY];                           //для вывода точки	
179:           	const rom uint8_t const_dot[2];
180:           }Ind;
181:           
182:           //*******ПЕРЕЧИСЛЕНИЯ*********
183:           
184:           typedef enum {
185:           	e_Time_Init = 0,
186:           	e_Time_Blink 
187:           } eIndexConst_Mod_Ind;
188:           
189:           
190:           //Функции модуля индикации
191:           
192:           static void		M_Ind_bin2dec (uint16_t value); 
193:           static void		M_Ind_7_Segment_Out(void);  
194:           static void 	M_Ind_View_SW_version(void);  
195:           static void 	M_Ind_temperature_real(void);   
196:           static void		M_Ind_view_num_page_menu(void); 
197:           static void		M_Ind_view_parameter_menu(void);    
198:           static void	 	M_Ind_blinking_7segm(BOOL state_left_symbol_dot, BOOL need_blink); 
199:           static void		M_Ind_view_temperature_or_fan_level_setup(const uint8_t offset_to_symb, uint8_t parameter);
200:           static void		M_Ind_view_failure(void); 
201:           static void		M_Ind_view_text(const uint8_t left_ind_offset_to_symb, const uint8_t middle_ind_offset_to_symb, 
202:                                           const uint8_t right_ind_offset_to_symb, BOOL need_blink);
203:           static void		M_Ind_LED_blinking(uint8_t action, const uint8_t index);
204:           static void		M_Ind_TimerAutoExit( void );
205:           
206:           
207:           //*********СТРУКТУРЫ******************************************
208:           
209:           Ind M_Ind_data = { 0, {0,0,0}, {0,0,0/*,0,0,0*/}, {0,0,0/*,0,0,0*/}, {0,0,0/*,0,0,0*/}, {IS_DOT, NO_DOT} };
210:           
211:           TIME_M_Ind time_M_Ind = {0};
212:           
213:           
214:           //***********ПЕРЕМЕННЫЕ****************************************
215:           uint8_t M_Ind_State = 0;
216:           uint8_t M_Ind_Previous_State = 0;
217:           BOOL blink_mode = OFF;
218:           
219:           
220:           void M_Ind_ctor(void)
221:           {
222:               ANODE_1_PIN  = ANODE_IS_OFF;  
2AE2  8C8D     BSF LATE, 6, ACCESS
223:               ANODE_1_TRIS = OUT;
2AE4  9C96     BCF TRISE, 6, ACCESS
224:               ANODE_2_PIN  = ANODE_IS_OFF; 
2AE6  8E8D     BSF LATE, 7, ACCESS
225:               ANODE_2_TRIS = OUT; 
2AE8  9E96     BCF TRISE, 7, ACCESS
226:               ANODE_3_PIN  = ANODE_IS_OFF; 
2AEA  808C     BSF LATD, 0, ACCESS
227:               ANODE_3_TRIS = OUT; 
2AEC  9095     BCF TRISD, 0, ACCESS
228:               ANODE_4_PIN  = ANODE_IS_OFF; 
2AEE  828C     BSF LATD, 1, ACCESS
229:               ANODE_4_TRIS = OUT; 
2AF0  9295     BCF TRISD, 1, ACCESS
230:               ANODE_5_PIN  = ANODE_IS_OFF; 
2AF2  848C     BSF LATD, 2, ACCESS
231:               ANODE_5_TRIS = OUT; 
2AF4  9495     BCF TRISD, 2, ACCESS
232:               ANODE_6_PIN  = ANODE_IS_OFF; 
2AF6  868C     BSF LATD, 3, ACCESS
233:               ANODE_6_TRIS = OUT; 
2AF8  9695     BCF TRISD, 3, ACCESS
234:           }
2AFA  0012     RETURN 0
235:           
236:           void  M_Ind_Set_blink_mode(BOOL value)
2AFC  CFD9     MOVFF FSR2, POSTINC1
2AFE  FFE6     NOP
2B00  CFE1     MOVFF FSR1, FSR2
2B02  FFD9     NOP
237:           {
238:           	blink_mode = value;
2B04  0EFE     MOVLW 0xFE
2B06  CFDB     MOVFF PLUSW2, blink_mode
2B08  F0B2     NOP
239:           }
2B0A  52E5     MOVF POSTDEC1, F, ACCESS
2B0C  CFE7     MOVFF INDF1, FSR2
2B0E  FFD9     NOP
2B10  0012     RETURN 0
240:           
241:           //**************ФУНКЦИИ**********************************
242:           
243:           uint8_t M_Ind_Get_Previous_State(void)
244:           {
245:           	return M_Ind_Previous_State;
2B12  0100     MOVLB 0x0
2B14  51B1     MOVF M_Ind_Previous_State, W, BANKED
2B16  D000     BRA 0x2B18
246:           }
2B18  0012     RETURN 0
247:           
248:           void M_Ind_Set_Previous_State(uint8_t state) 
2B1A  CFD9     MOVFF FSR2, POSTINC1
2B1C  FFE6     NOP
2B1E  CFE1     MOVFF FSR1, FSR2
2B20  FFD9     NOP
249:           {
250:           	M_Ind_Previous_State = state;
2B22  0EFE     MOVLW 0xFE
2B24  CFDB     MOVFF PLUSW2, M_Ind_Previous_State
2B26  F0B1     NOP
251:           }
2B28  52E5     MOVF POSTDEC1, F, ACCESS
2B2A  CFE7     MOVFF INDF1, FSR2
2B2C  FFD9     NOP
2B2E  0012     RETURN 0
252:           
253:           void M_Ind_Set_state(uint8_t value)
2B30  CFD9     MOVFF FSR2, POSTINC1
2B32  FFE6     NOP
2B34  CFE1     MOVFF FSR1, FSR2
2B36  FFD9     NOP
254:           {
255:           	M_Ind_State = value;
2B38  0EFE     MOVLW 0xFE
2B3A  CFDB     MOVFF PLUSW2, M_Ind_State
2B3C  F0B0     NOP
256:           }
2B3E  52E5     MOVF POSTDEC1, F, ACCESS
2B40  CFE7     MOVFF INDF1, FSR2
2B42  FFD9     NOP
2B44  0012     RETURN 0
257:           
258:           uint8_t M_Ind_Get_state(void)
259:           {
260:           	return M_Ind_State;
2B46  0100     MOVLB 0x0
2B48  51B0     MOVF M_Ind_State, W, BANKED
2B4A  D000     BRA 0x2B4C
261:           }
2B4C  0012     RETURN 0
262:           
263:           /* Вывод на семисегментный индикатор */
264:           static void M_Ind_7_Segment_Out (void)
265:           {
266:           	static uint8_t count_s = 0;
267:                   //Сброс пинов с общими анодами и установка нужного
268:           		ANODE_FIRST_PORT |= ANODES_ARE_OFF_ON_FIRST_PORT;
2B4E  0EC0     MOVLW 0xC0
2B50  128D     IORWF LATE, F, ACCESS
269:                   ANODE_SECOND_PORT |= ANODES_ARE_OFF_ON_SECOND_PORT;
2B52  0E0F     MOVLW 0xF
2B54  128C     IORWF LATD, F, ACCESS
270:           		
271:                   //Загружаем данные в сдвиговый регистр
272:           		SW_SPI_writeByte(M_Ind_Portraits[M_Ind_data.data[count_s]] & M_Ind_data.dot[count_s]);
2B56  0100     MOVLB 0x0
2B58  51B3     MOVF 0xB3, W, BANKED
2B5A  6AEA     CLRF FSR0H, ACCESS
2B5C  0FA3     ADDLW 0xA3
2B5E  6EE9     MOVWF FSR0, ACCESS
2B60  0E00     MOVLW 0x0
2B62  22EA     ADDWFC FSR0H, F, ACCESS
2B64  CFEF     MOVFF INDF0, __tmp_0
2B66  F032     NOP
2B68  0100     MOVLB 0x0
2B6A  51B3     MOVF 0xB3, W, BANKED
2B6C  6AEA     CLRF FSR0H, ACCESS
2B6E  0FA0     ADDLW 0xA0
2B70  6EE9     MOVWF FSR0, ACCESS
2B72  0E00     MOVLW 0x0
2B74  22EA     ADDWFC FSR0H, F, ACCESS
2B76  50EF     MOVF INDF0, W, ACCESS
2B78  6AF7     CLRF TBLPTRH, ACCESS
2B7A  0FB2     ADDLW 0xB2
2B7C  6EF6     MOVWF TBLPTR, ACCESS
2B7E  0E4D     MOVLW 0x4D
2B80  22F7     ADDWFC TBLPTRH, F, ACCESS
2B82  0008     TBLRD*
2B84  50F5     MOVF TABLAT, W, ACCESS
2B86  1432     ANDWF __tmp_0, W, ACCESS
2B88  6EE6     MOVWF POSTINC1, ACCESS
2B8A  EC4F     CALL 0x4A9E, 0
2B8C  F025     NOP
2B8E  52E5     MOVF POSTDEC1, F, ACCESS
273:           		switch(count_s)
2B90  0100     MOVLB 0x0
2B92  51B3     MOVF 0xB3, W, BANKED
2B94  0A05     XORLW 0x5
2B96  E015     BZ 0x2BC2
2B98  0A01     XORLW 0x1
2B9A  E011     BZ 0x2BBE
2B9C  0A07     XORLW 0x7
2B9E  E00D     BZ 0x2BBA
2BA0  0A01     XORLW 0x1
2BA2  E009     BZ 0x2BB6
2BA4  0A03     XORLW 0x3
2BA6  E005     BZ 0x2BB2
2BA8  0A01     XORLW 0x1
2BAA  E001     BZ 0x2BAE
2BAC  D00B     BRA 0x2BC4
274:                   {
275:                       case 0:
276:                           ANODE_1_PIN  = ANODE_IS_ON;
2BAE  9C8D     BCF LATE, 6, ACCESS
277:                           break;
2BB0  D009     BRA 0x2BC4
278:                       case 1:
279:                           ANODE_2_PIN  = ANODE_IS_ON;
2BB2  9E8D     BCF LATE, 7, ACCESS
280:                           break;
2BB4  D007     BRA 0x2BC4
281:                       case 2:
282:                           ANODE_3_PIN  = ANODE_IS_ON;
2BB6  908C     BCF LATD, 0, ACCESS
283:                           break;    
2BB8  D005     BRA 0x2BC4
284:                       case 3:
285:                           ANODE_4_PIN  = ANODE_IS_ON;
2BBA  928C     BCF LATD, 1, ACCESS
286:                           break;
2BBC  D003     BRA 0x2BC4
287:                       case 4:
288:                           ANODE_5_PIN  = ANODE_IS_ON;
2BBE  948C     BCF LATD, 2, ACCESS
289:                           break;
2BC0  D001     BRA 0x2BC4
290:                       case 5:
291:                           ANODE_6_PIN  = ANODE_IS_ON;
2BC2  968C     BCF LATD, 3, ACCESS
292:                   }
293:                   if(++count_s == 3U /*QUANTITY_OF_FAMILIARITY */ ) 
2BC4  0100     MOVLB 0x0
2BC6  2BB3     INCF 0xB3, F, BANKED
2BC8  0E03     MOVLW 0x3
2BCA  0100     MOVLB 0x0
2BCC  5DB3     SUBWF 0xB3, W, BANKED
2BCE  E102     BNZ 0x2BD4
294:                       count_s = 0;
2BD0  0100     MOVLB 0x0
2BD2  6BB3     CLRF 0xB3, BANKED
295:           }
2BD4  0012     RETURN 0
296:           
297:           /* 
298:           Функция преобразования int числа value  из двоичного в двоично-десятичный формат с заполнением массива data
299:           - гасит незначащие нули в искомом числе
300:           - отрабатывает режим мигания
301:           - определяет число или текстовый символ нужно выводить
302:           Входные параметры:
303:           unsigned  int value - искомое число
304:           */
305:           
306:           static void M_Ind_bin2dec (uint16_t value)
2BD6  CFD9     MOVFF FSR2, POSTINC1
2BD8  FFE6     NOP
2BDA  CFE1     MOVFF FSR1, FSR2
2BDC  FFD9     NOP
2BDE  0E02     MOVLW 0x2
2BE0  26E1     ADDWF FSR1, F, ACCESS
307:           {
308:            	uint8_t count = 0;
2BE2  6ADF     CLRF INDF2, ACCESS
309:            	uint8_t decimals_temp = decimals[0];
2BE4  0ECA     MOVLW 0xCA
2BE6  6EF6     MOVWF TBLPTR, ACCESS
2BE8  0E4D     MOVLW 0x4D
2BEA  6EF7     MOVWF TBLPTRH, ACCESS
2BEC  0008     TBLRD*
2BEE  0E01     MOVLW 0x1
2BF0  CFF5     MOVFF TABLAT, PLUSW2
2BF2  FFDB     NOP
310:            	
311:            	if (M_Ind_data.Flag_Blink_seven_segm)		 //если нужно мигать, то выводим пустые символы
2BF4  0100     MOVLB 0x0
2BF6  5199     MOVF M_Ind_data, W, BANKED
2BF8  E008     BZ 0x2C0A
312:           		M_Ind_data.data[LEFT_INDICATOR] = M_Ind_data.data[MIDDLE_INDICATOR] = M_Ind_data.data[RIGHT_INDICATOR] 
313:           		= INDEX_OF_BLANK_SYMBOL;		
2BFA  0100     MOVLB 0x0
2BFC  0E17     MOVLW 0x17
2BFE  6FA2     MOVWF 0xA2, BANKED
2C00  C0A2     MOVFF 0xA2, 0xA1
2C02  F0A1     NOP
2C04  C0A2     MOVFF 0xA2, 0xA0
2C06  F0A0     NOP
314:           	else
2C08  D066     BRA 0x2CD6
315:           	{
316:           		M_Ind_data.data[LEFT_INDICATOR] = M_Ind_data.data[MIDDLE_INDICATOR] 
317:           		= M_Ind_data.data[RIGHT_INDICATOR] = 0;
2C0A  0100     MOVLB 0x0
2C0C  6BA2     CLRF 0xA2, BANKED
2C0E  C0A2     MOVFF 0xA2, 0xA1
2C10  F0A1     NOP
2C12  C0A2     MOVFF 0xA2, 0xA0
2C14  F0A0     NOP
318:           		while(count < QUANTITY_OF_FAMILIARITY) 		// цикл по всем цифрам
2C16  0E03     MOVLW 0x3
2C18  5CDF     SUBWF INDF2, W, ACCESS
2C1A  E251     BC 0x2CBE
2CBC  D7AC     BRA 0x2C16
319:           		{
320:           				if (M_Ind_data.index_of_text_sym[count] >= IT_IS_A_TEXT_SYM_AREA) //если нужно выводить не цифру, а текстовый символ
2C1C  50DF     MOVF INDF2, W, ACCESS
2C1E  6AEA     CLRF FSR0H, ACCESS
2C20  0F9D     ADDLW 0x9D
2C22  6EE9     MOVWF FSR0, ACCESS
2C24  0E00     MOVLW 0x0
2C26  22EA     ADDWFC FSR0H, F, ACCESS
2C28  50EF     MOVF INDF0, W, ACCESS
2C2A  6E32     MOVWF __tmp_0, ACCESS
2C2C  6A33     CLRF 0x33, ACCESS
2C2E  0E0A     MOVLW 0xA
2C30  5C32     SUBWF __tmp_0, W, ACCESS
2C32  0E00     MOVLW 0x0
2C34  5833     SUBWFB 0x33, W, ACCESS
2C36  E312     BNC 0x2C5C
321:           					M_Ind_data.data[count] = M_Ind_data.index_of_text_sym[count];
2C38  50DF     MOVF INDF2, W, ACCESS
2C3A  6AEA     CLRF FSR0H, ACCESS
2C3C  0F9D     ADDLW 0x9D
2C3E  6EE9     MOVWF FSR0, ACCESS
2C40  0E00     MOVLW 0x0
2C42  22EA     ADDWFC FSR0H, F, ACCESS
2C44  50EF     MOVF INDF0, W, ACCESS
2C46  6EE6     MOVWF POSTINC1, ACCESS
2C48  50DF     MOVF INDF2, W, ACCESS
2C4A  6AEA     CLRF FSR0H, ACCESS
2C4C  0FA0     ADDLW 0xA0
2C4E  6EE9     MOVWF FSR0, ACCESS
2C50  0E00     MOVLW 0x0
2C52  22EA     ADDWFC FSR0H, F, ACCESS
2C54  52E5     MOVF POSTDEC1, F, ACCESS
2C56  50E7     MOVF INDF1, W, ACCESS
2C58  6EEF     MOVWF INDF0, ACCESS
322:           			else
2C5A  D025     BRA 0x2CA6
323:           			{
324:           				while(value >= decimals_temp) 
2C5C  0EFD     MOVLW 0xFD
2C5E  CFDB     MOVFF PLUSW2, __tmp_0
2C60  F032     NOP
2C62  0EFE     MOVLW 0xFE
2C64  CFDB     MOVFF PLUSW2, 0x33
2C66  F033     NOP
2C68  0E01     MOVLW 0x1
2C6A  50DB     MOVF PLUSW2, W, ACCESS
2C6C  6E34     MOVWF 0x34, ACCESS
2C6E  6A35     CLRF 0x35, ACCESS
2C70  5034     MOVF 0x34, W, ACCESS
2C72  5C32     SUBWF __tmp_0, W, ACCESS
2C74  5035     MOVF 0x35, W, ACCESS
2C76  5833     SUBWFB 0x33, W, ACCESS
2C78  E316     BNC 0x2CA6
2CA4  D7DB     BRA 0x2C5C
325:           				{ 
326:           		  			value -= decimals_temp;  
2C7A  0E01     MOVLW 0x1
2C7C  50DB     MOVF PLUSW2, W, ACCESS
2C7E  6E32     MOVWF __tmp_0, ACCESS
2C80  6A33     CLRF 0x33, ACCESS
2C82  50D9     MOVF FSR2, W, ACCESS
2C84  0FFD     ADDLW 0xFD
2C86  6EE9     MOVWF FSR0, ACCESS
2C88  0EFF     MOVLW 0xFF
2C8A  20DA     ADDWFC FSR2H, W, ACCESS
2C8C  6EEA     MOVWF FSR0H, ACCESS
2C8E  5032     MOVF __tmp_0, W, ACCESS
2C90  5EEE     SUBWF POSTINC0, F, ACCESS
2C92  5033     MOVF 0x33, W, ACCESS
2C94  5AED     SUBWFB POSTDEC0, F, ACCESS
327:           		  			M_Ind_data.data[count]++;
2C96  50DF     MOVF INDF2, W, ACCESS
2C98  6AEA     CLRF FSR0H, ACCESS
2C9A  0FA0     ADDLW 0xA0
2C9C  6EE9     MOVWF FSR0, ACCESS
2C9E  0E00     MOVLW 0x0
2CA0  22EA     ADDWFC FSR0H, F, ACCESS
2CA2  2AEF     INCF INDF0, F, ACCESS
328:           		  		}			
329:           			}
330:           			count++;
2CA6  2ADF     INCF INDF2, F, ACCESS
331:           			decimals_temp = decimals[count];	
2CA8  50DF     MOVF INDF2, W, ACCESS
2CAA  6AF7     CLRF TBLPTRH, ACCESS
2CAC  0FCA     ADDLW 0xCA
2CAE  6EF6     MOVWF TBLPTR, ACCESS
2CB0  0E4D     MOVLW 0x4D
2CB2  22F7     ADDWFC TBLPTRH, F, ACCESS
2CB4  0008     TBLRD*
2CB6  0E01     MOVLW 0x1
2CB8  CFF5     MOVFF TABLAT, PLUSW2
2CBA  FFDB     NOP
332:           		}
333:           		if(M_Ind_data.data[LEFT_INDICATOR] == 0U) //формирование гашения незначащих нулей
2CBE  0100     MOVLB 0x0
2CC0  51A0     MOVF 0xA0, W, BANKED
2CC2  E109     BNZ 0x2CD6
334:           		{		
335:           			M_Ind_data.data[LEFT_INDICATOR] = INDEX_OF_BLANK_SYMBOL;
2CC4  0100     MOVLB 0x0
2CC6  0E17     MOVLW 0x17
2CC8  6FA0     MOVWF 0xA0, BANKED
336:           			if(M_Ind_data.data[MIDDLE_INDICATOR] == 0U)
2CCA  0100     MOVLB 0x0
2CCC  51A1     MOVF 0xA1, W, BANKED
2CCE  E103     BNZ 0x2CD6
337:           				M_Ind_data.data[MIDDLE_INDICATOR] = INDEX_OF_BLANK_SYMBOL;
2CD0  0100     MOVLB 0x0
2CD2  0E17     MOVLW 0x17
2CD4  6FA1     MOVWF 0xA1, BANKED
338:           		} 	
339:           	}
340:           }
2CD6  0E02     MOVLW 0x2
2CD8  5CE1     SUBWF FSR1, W, ACCESS
2CDA  E202     BC 0x2CE0
2CDC  6AE1     CLRF FSR1, ACCESS
2CDE  52E5     MOVF POSTDEC1, F, ACCESS
2CE0  6EE1     MOVWF FSR1, ACCESS
2CE2  52E5     MOVF POSTDEC1, F, ACCESS
2CE4  CFE7     MOVFF INDF1, FSR2
2CE6  FFD9     NOP
2CE8  0012     RETURN 0
341:           
342:           /* Индикация светодиода "Вентилятор" */
343:           static void M_Ind_led_fan_mode(void)
344:           {
345:           	switch(M_Mngm_get_burning_state())
2CEA  EC7F     CALL 0x14FE, 0
2CEC  F00A     NOP
2CEE  0A04     XORLW 0x4
2CF0  E00F     BZ 0x2D10
2CF2  0A05     XORLW 0x5
2CF4  E00B     BZ 0x2D0C
2CF6  0A02     XORLW 0x2
2CF8  E009     BZ 0x2D0C
2CFA  0A01     XORLW 0x1
2CFC  E007     BZ 0x2D0C
2CFE  0A07     XORLW 0x7
2D00  E005     BZ 0x2D0C
2D02  0A05     XORLW 0x5
2D04  E001     BZ 0x2D08
2D06  D016     BRA 0x2D34
346:           	{
347:           		case CALC_PARAMS_PERIOD:
348:           			LED_FAN_PIN = OFF;
2D08  968D     BCF LATE, 3, ACCESS
349:           		break;
2D0A  D014     BRA 0x2D34
350:           		case START_BURNING:
351:           		case ECONOM_MODE:
352:           		case INCREASE_TEMPERATURE:
353:           		case MAINTENANCE_TEMPERATURE_INCR:
354:           			LED_FAN_PIN = ON;
2D0C  868D     BSF LATE, 3, ACCESS
355:           		break;
2D0E  D012     BRA 0x2D34
356:           		case MAINTENANCE_TEMPERATURE_CYCLE:
357:           			switch(M_Mngm_get_phase_cycle())
2D10  EC12     CALL 0x1424, 0
2D12  F00A     NOP
2D14  0A01     XORLW 0x1
2D16  E00B     BZ 0x2D2E
2D18  0A01     XORLW 0x1
2D1A  E001     BZ 0x2D1E
2D1C  D00A     BRA 0x2D32
358:           			{
359:           				case PAUSE_IN_CYCLE:
360:           					M_Ind_LED_blinking(BLINKING_FAN_PIN, INDEX_OF_FAN_LED);
2D1E  0E01     MOVLW 0x1
2D20  6EE6     MOVWF POSTINC1, ACCESS
2D22  0E04     MOVLW 0x4
2D24  6EE6     MOVWF POSTINC1, ACCESS
2D26  DB09     RCALL M_Ind_LED_blinking
2D28  52E5     MOVF POSTDEC1, F, ACCESS
2D2A  52E5     MOVF POSTDEC1, F, ACCESS
361:           				break;
2D2C  D002     BRA 0x2D32
362:           				case WORK_IN_CYCLE:
363:           					LED_FAN_PIN = ON;
2D2E  868D     BSF LATE, 3, ACCESS
364:           				break;
2D30  D000     BRA 0x2D32
365:           			}
366:           		break;
2D32  D000     BRA 0x2D34
367:           	}
368:           }	
2D34  0012     RETURN 0
369:           
370:           
371:           /* Автомат состояний модуля индикации */
372:           void M_Ind_Run (void)
373:           {
374:           	switch(M_Ind_State)
2D36  0100     MOVLB 0x0
2D38  51B0     MOVF M_Ind_State, W, BANKED
2D3A  0A08     XORLW 0x8
2D3C  E101     BNZ 0x2D40
2D3E  D0F2     BRA 0x2F24
2D40  0A0F     XORLW 0xF
2D42  E101     BNZ 0x2D46
2D44  D0C8     BRA 0x2ED6
2D46  0A01     XORLW 0x1
2D48  E101     BNZ 0x2D4C
2D4A  D0AC     BRA 0x2EA4
2D4C  0A03     XORLW 0x3
2D4E  E101     BNZ 0x2D52
2D50  D093     BRA 0x2E78
2D52  0A0C     XORLW 0xC
2D54  E101     BNZ 0x2D58
2D56  D079     BRA 0x2E4A
2D58  0A0D     XORLW 0xD
2D5A  E05C     BZ 0x2E14
2D5C  0A07     XORLW 0x7
2D5E  E02B     BZ 0x2DB6
2D60  0A01     XORLW 0x1
2D62  E01C     BZ 0x2D9C
2D64  0A03     XORLW 0x3
2D66  E00D     BZ 0x2D82
2D68  0A01     XORLW 0x1
2D6A  E001     BZ 0x2D6E
2D6C  D0E4     BRA 0x2F36
375:           	{
376:           		case STATE_IND_INIT :						//инициализация (мигание версии ПО), все светоиоды отключены
377:           			M_Ind_View_SW_version();					
2D6E  DA96     RCALL M_Ind_View_SW_version
378:           			LED_BICOLOR_GREEN_PIN = OFF;
2D70  9A8D     BCF LATE, 5, ACCESS
379:           			LED_BICOLOR_RED_PIN = OFF;
2D72  988D     BCF LATE, 4, ACCESS
380:           			LED_FAN_PIN = OFF;
2D74  968D     BCF LATE, 3, ACCESS
381:           			M_Ind_LED_blinking(NO_BLINKING, INDEX_OF_BICOLOR_LED);
2D76  6AE6     CLRF POSTINC1, ACCESS
2D78  6AE6     CLRF POSTINC1, ACCESS
2D7A  DADF     RCALL M_Ind_LED_blinking
2D7C  52E5     MOVF POSTDEC1, F, ACCESS
2D7E  52E5     MOVF POSTDEC1, F, ACCESS
382:                       break;
2D80  D0DA     BRA 0x2F36
383:           		case STATE_VIEW_NUM_PAGE_MENU :		//отображение номера страницы пользовательского меню
384:           			M_Ind_Previous_State = STATE_VIEW_NUM_PAGE_MENU;
2D82  0100     MOVLB 0x0
2D84  0E01     MOVLW 0x1
2D86  6FB1     MOVWF M_Ind_Previous_State, BANKED
385:           			M_Ind_LED_blinking(BLINKING_YELLOW, INDEX_OF_BICOLOR_LED);
2D88  6AE6     CLRF POSTINC1, ACCESS
2D8A  0E03     MOVLW 0x3
2D8C  6EE6     MOVWF POSTINC1, ACCESS
2D8E  DAD5     RCALL M_Ind_LED_blinking
2D90  52E5     MOVF POSTDEC1, F, ACCESS
2D92  52E5     MOVF POSTDEC1, F, ACCESS
386:           			LED_FAN_PIN = OFF;
2D94  968D     BCF LATE, 3, ACCESS
387:           			M_Ind_view_num_page_menu();
2D96  D9DE     RCALL M_Ind_view_num_page_menu
388:           			M_Ind_TimerAutoExit();
2D98  D997     RCALL M_Ind_TimerAutoExit
389:           		break;
2D9A  D0CD     BRA 0x2F36
390:           		case STATE_VIEW_PARAMETER_MENU :	//отображение параметра меню на выбранной странице (мигаем Ж+З)
391:           			M_Ind_Previous_State = STATE_VIEW_PARAMETER_MENU;
2D9C  0100     MOVLB 0x0
2D9E  0E02     MOVLW 0x2
2DA0  6FB1     MOVWF M_Ind_Previous_State, BANKED
392:           			M_Ind_LED_blinking(BLINKING_YELLOW, INDEX_OF_BICOLOR_LED);
2DA2  6AE6     CLRF POSTINC1, ACCESS
2DA4  0E03     MOVLW 0x3
2DA6  6EE6     MOVWF POSTINC1, ACCESS
2DA8  DAC8     RCALL M_Ind_LED_blinking
2DAA  52E5     MOVF POSTDEC1, F, ACCESS
2DAC  52E5     MOVF POSTDEC1, F, ACCESS
393:           			LED_FAN_PIN = OFF;
2DAE  968D     BCF LATE, 3, ACCESS
394:           			M_Ind_view_parameter_menu();
2DB0  D9ED     RCALL M_Ind_view_parameter_menu
395:           			M_Ind_TimerAutoExit();
2DB2  D98A     RCALL M_Ind_TimerAutoExit
396:           		break;
2DB4  D0C0     BRA 0x2F36
397:           		case STATE_VIEW_TEMPERATURE_REAL :		//отображение типа топлива и текущей температуры воды в контуре отопления
398:           			M_Ind_Previous_State = STATE_VIEW_TEMPERATURE_REAL;
2DB6  0100     MOVLB 0x0
2DB8  0E03     MOVLW 0x3
2DBA  6FB1     MOVWF M_Ind_Previous_State, BANKED
399:           			M_Ind_temperature_real();
2DBC  DA1A     RCALL M_Ind_temperature_real
400:           			switch(M_Mngm_Get_state())
2DBE  ECA7     CALL 0x154E, 0
2DC0  F00A     NOP
2DC2  0A02     XORLW 0x2
2DC4  E00C     BZ 0x2DDE
2DC6  0A02     XORLW 0x2
2DC8  E001     BZ 0x2DCC
2DCA  D023     BRA 0x2E12
401:           			{
402:           				case STATE_WAITING:		//мигать 2-цветным светодиодом в режиме "Ожидание"
403:           					M_Ind_LED_blinking(BLINKING_GREEN, INDEX_OF_BICOLOR_LED);
2DCC  6AE6     CLRF POSTINC1, ACCESS
2DCE  0E02     MOVLW 0x2
2DD0  6EE6     MOVWF POSTINC1, ACCESS
2DD2  DAB3     RCALL M_Ind_LED_blinking
2DD4  52E5     MOVF POSTDEC1, F, ACCESS
2DD6  52E5     MOVF POSTDEC1, F, ACCESS
404:           					LED_FAN_PIN = OFF;
2DD8  968D     BCF LATE, 3, ACCESS
405:           					LED_BICOLOR_RED_PIN = OFF;
2DDA  988D     BCF LATE, 4, ACCESS
406:           				break;
2DDC  D01A     BRA 0x2E12
407:           				case STATE_BURNING:		//светить 2-цветным светодиодом в режиме "Горение"
408:           					switch(M_Mngm_get_burning_state())
2DDE  EC7F     CALL 0x14FE, 0
2DE0  F00A     NOP
2DE2  0A05     XORLW 0x5
2DE4  E011     BZ 0x2E08
2DE6  0A01     XORLW 0x1
2DE8  E00F     BZ 0x2E08
2DEA  0A05     XORLW 0x5
2DEC  E00A     BZ 0x2E02
2DEE  0A03     XORLW 0x3
2DF0  E008     BZ 0x2E02
2DF2  0A01     XORLW 0x1
2DF4  E006     BZ 0x2E02
2DF6  0A03     XORLW 0x3
2DF8  E001     BZ 0x2DFC
2DFA  D009     BRA 0x2E0E
409:           					{
410:           						case CALC_PARAMS_PERIOD:
411:           							LED_BICOLOR_RED_PIN = OFF;
2DFC  988D     BCF LATE, 4, ACCESS
412:           							LED_BICOLOR_GREEN_PIN = OFF;
2DFE  9A8D     BCF LATE, 5, ACCESS
413:           						break;
2E00  D006     BRA 0x2E0E
414:           						case START_BURNING:
415:           						case INCREASE_TEMPERATURE:
416:           						case ECONOM_MODE:
417:           							LED_BICOLOR_RED_PIN = ON;
2E02  888D     BSF LATE, 4, ACCESS
418:           							LED_BICOLOR_GREEN_PIN = OFF;
2E04  9A8D     BCF LATE, 5, ACCESS
419:           						break;
2E06  D003     BRA 0x2E0E
420:           						case MAINTENANCE_TEMPERATURE_INCR:
421:           						case MAINTENANCE_TEMPERATURE_CYCLE:	
422:           							LED_BICOLOR_RED_PIN = OFF;
2E08  988D     BCF LATE, 4, ACCESS
423:           							LED_BICOLOR_GREEN_PIN = ON;
2E0A  8A8D     BSF LATE, 5, ACCESS
424:           						break;
2E0C  D000     BRA 0x2E0E
425:           					}
426:           					M_Ind_led_fan_mode();
2E0E  DF6D     RCALL M_Ind_led_fan_mode
427:           				break;
2E10  D000     BRA 0x2E12
428:           			}
429:           		break;
2E12  D091     BRA 0x2F36
430:           		case STATE_VIEW_TEMPERATURE_SETUP :				//отображение мигающего значения устанавливаемого пользователем значения температуры (мигаем К+З)
431:           			M_Ind_Previous_State = STATE_VIEW_TEMPERATURE_SETUP;
2E14  0100     MOVLB 0x0
2E16  0E04     MOVLW 0x4
2E18  6FB1     MOVWF M_Ind_Previous_State, BANKED
432:           			M_Ind_view_temperature_or_fan_level_setup(OFFSET_TO_SYMBOL_t, M_Mngm_Get_parameters_buffer()->menu_parameters.temper_setup);
2E1A  EC8E     CALL 0x151C, 0
2E1C  F00A     NOP
2E1E  CFF3     MOVFF PROD, FSR0
2E20  FFE9     NOP
2E22  CFF4     MOVFF PRODH, FSR0H
2E24  FFEA     NOP
2E26  0E27     MOVLW 0x27
2E28  26E9     ADDWF FSR0, F, ACCESS
2E2A  0E00     MOVLW 0x0
2E2C  22EA     ADDWFC FSR0H, F, ACCESS
2E2E  50EF     MOVF INDF0, W, ACCESS
2E30  6EE6     MOVWF POSTINC1, ACCESS
2E32  0E0A     MOVLW 0xA
2E34  6EE6     MOVWF POSTINC1, ACCESS
2E36  D912     RCALL M_Ind_view_temperature_or_fan_level_setup
2E38  52E5     MOVF POSTDEC1, F, ACCESS
2E3A  52E5     MOVF POSTDEC1, F, ACCESS
433:           			M_Ind_LED_blinking(BLINKING_YELLOW, INDEX_OF_BICOLOR_LED);
2E3C  6AE6     CLRF POSTINC1, ACCESS
2E3E  0E03     MOVLW 0x3
2E40  6EE6     MOVWF POSTINC1, ACCESS
2E42  DA7B     RCALL M_Ind_LED_blinking
2E44  52E5     MOVF POSTDEC1, F, ACCESS
2E46  52E5     MOVF POSTDEC1, F, ACCESS
434:           		break;
2E48  D076     BRA 0x2F36
435:           		case STATE_VIEW_SPEED_FAN_SETUP:		//отображение мигающего значения устанавливаемого пользователем значения уровня оборотов вентилятора (мигаем К+З)	
436:           			M_Ind_Previous_State = STATE_VIEW_SPEED_FAN_SETUP;
2E4A  0100     MOVLB 0x0
2E4C  0E09     MOVLW 0x9
2E4E  6FB1     MOVWF M_Ind_Previous_State, BANKED
437:           			M_Ind_view_temperature_or_fan_level_setup(OFFSET_TO_SYMBOL_F, (*M_Mngm_get_pFanLevel()) - 1);
2E50  EC0C     CALL 0x1418, 0
2E52  F00A     NOP
2E54  CFF3     MOVFF PROD, FSR0
2E56  FFE9     NOP
2E58  CFF4     MOVFF PRODH, FSR0H
2E5A  FFEA     NOP
2E5C  04EF     DECF INDF0, W, ACCESS
2E5E  6EE6     MOVWF POSTINC1, ACCESS
2E60  0E0B     MOVLW 0xB
2E62  6EE6     MOVWF POSTINC1, ACCESS
2E64  D8FB     RCALL M_Ind_view_temperature_or_fan_level_setup
2E66  52E5     MOVF POSTDEC1, F, ACCESS
2E68  52E5     MOVF POSTDEC1, F, ACCESS
438:           			M_Ind_LED_blinking(BLINKING_YELLOW, INDEX_OF_BICOLOR_LED);
2E6A  6AE6     CLRF POSTINC1, ACCESS
2E6C  0E03     MOVLW 0x3
2E6E  6EE6     MOVWF POSTINC1, ACCESS
2E70  DA64     RCALL M_Ind_LED_blinking
2E72  52E5     MOVF POSTDEC1, F, ACCESS
2E74  52E5     MOVF POSTDEC1, F, ACCESS
439:           		break;
2E76  D05F     BRA 0x2F36
440:           		case STATE_VIEW_PAUSE :								//отображение в режиме "Пауза" (открыта крышка бункера, светим К+З)
441:           			M_Ind_view_text(IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_P, 
2E84  0E0B     MOVLW 0xB
2E86  6EE6     MOVWF POSTINC1, ACCESS
442:           			IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_A, IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_U, NEED_BLINK);
2E78  0E01     MOVLW 0x1
2E7A  6EE6     MOVWF POSTINC1, ACCESS
2E7C  0E0C     MOVLW 0xC
2E7E  6EE6     MOVWF POSTINC1, ACCESS
2E80  0E0A     MOVLW 0xA
2E82  6EE6     MOVWF POSTINC1, ACCESS
2E88  D858     RCALL M_Ind_view_text
2E8A  52E5     MOVF POSTDEC1, F, ACCESS
2E8C  52E5     MOVF POSTDEC1, F, ACCESS
2E8E  52E5     MOVF POSTDEC1, F, ACCESS
2E90  52E5     MOVF POSTDEC1, F, ACCESS
443:           			LED_BICOLOR_GREEN_PIN = ON;
2E92  8A8D     BSF LATE, 5, ACCESS
444:           			LED_BICOLOR_RED_PIN = ON;
2E94  888D     BSF LATE, 4, ACCESS
445:           			LED_FAN_PIN = OFF;
2E96  968D     BCF LATE, 3, ACCESS
446:           			M_Ind_LED_blinking(NO_BLINKING, INDEX_OF_BICOLOR_LED);
2E98  6AE6     CLRF POSTINC1, ACCESS
2E9A  6AE6     CLRF POSTINC1, ACCESS
2E9C  DA4E     RCALL M_Ind_LED_blinking
2E9E  52E5     MOVF POSTDEC1, F, ACCESS
2EA0  52E5     MOVF POSTDEC1, F, ACCESS
447:           		break;
2EA2  D049     BRA 0x2F36
448:           		case STATE_VIEW_CLEAN_CHIMNEY :					//отображение в режиме "Чистка дымохода" (светим К+З)
449:           			M_Ind_Previous_State = STATE_VIEW_CLEAN_CHIMNEY;
2EA4  0100     MOVLB 0x0
2EA6  0E06     MOVLW 0x6
2EA8  6FB1     MOVWF M_Ind_Previous_State, BANKED
450:           			M_Ind_view_text(IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_C, 
2EB6  0E0E     MOVLW 0xE
2EB8  6EE6     MOVWF POSTINC1, ACCESS
451:           			IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_L, IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_E, blink_mode);
2EAA  C0B2     MOVFF blink_mode, POSTINC1
2EAC  FFE6     NOP
2EAE  0E0D     MOVLW 0xD
2EB0  6EE6     MOVWF POSTINC1, ACCESS
2EB2  0E0F     MOVLW 0xF
2EB4  6EE6     MOVWF POSTINC1, ACCESS
2EBA  D83F     RCALL M_Ind_view_text
2EBC  52E5     MOVF POSTDEC1, F, ACCESS
2EBE  52E5     MOVF POSTDEC1, F, ACCESS
2EC0  52E5     MOVF POSTDEC1, F, ACCESS
2EC2  52E5     MOVF POSTDEC1, F, ACCESS
452:           			LED_BICOLOR_GREEN_PIN = ON;
2EC4  8A8D     BSF LATE, 5, ACCESS
453:           			LED_BICOLOR_RED_PIN = ON;
2EC6  888D     BSF LATE, 4, ACCESS
454:           			LED_FAN_PIN = OFF;
2EC8  968D     BCF LATE, 3, ACCESS
455:           			M_Ind_LED_blinking(NO_BLINKING, INDEX_OF_BICOLOR_LED);
2ECA  6AE6     CLRF POSTINC1, ACCESS
2ECC  6AE6     CLRF POSTINC1, ACCESS
2ECE  DA35     RCALL M_Ind_LED_blinking
2ED0  52E5     MOVF POSTDEC1, F, ACCESS
2ED2  52E5     MOVF POSTDEC1, F, ACCESS
456:           		break;
2ED4  D030     BRA 0x2F36
457:           		case STATE_VIEW_SUPPLY_FUEL :						//отображение в режиме "Загрузка топлива"
458:           			M_Ind_Previous_State = STATE_VIEW_SUPPLY_FUEL;
2ED6  0100     MOVLB 0x0
2ED8  0E07     MOVLW 0x7
2EDA  6FB1     MOVWF M_Ind_Previous_State, BANKED
459:           			M_Ind_view_text(IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_S, 
2EE8  0E10     MOVLW 0x10
2EEA  6EE6     MOVWF POSTINC1, ACCESS
460:           			IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_U, IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_P, blink_mode);
2EDC  C0B2     MOVFF blink_mode, POSTINC1
2EDE  FFE6     NOP
2EE0  0E0B     MOVLW 0xB
2EE2  6EE6     MOVWF POSTINC1, ACCESS
2EE4  0E0C     MOVLW 0xC
2EE6  6EE6     MOVWF POSTINC1, ACCESS
2EEC  D826     RCALL M_Ind_view_text
2EEE  52E5     MOVF POSTDEC1, F, ACCESS
2EF0  52E5     MOVF POSTDEC1, F, ACCESS
2EF2  52E5     MOVF POSTDEC1, F, ACCESS
2EF4  52E5     MOVF POSTDEC1, F, ACCESS
461:           			if(M_Motor_get_direction() == TIME_PAUSE_DISPENSER || M_Motor_get_direction() == TIME_PAUSE_SHATTER)
2EF6  EC0B     CALL 0x216, 0
2EF8  F001     NOP
2EFA  0803     SUBLW 0x3
2EFC  E004     BZ 0x2F06
2EFE  EC0B     CALL 0x216, 0
2F00  F001     NOP
2F02  0806     SUBLW 0x6
2F04  E107     BNZ 0x2F14
462:           				M_Ind_LED_blinking(BLINKING_YELLOW, INDEX_OF_BICOLOR_LED); 
2F06  6AE6     CLRF POSTINC1, ACCESS
2F08  0E03     MOVLW 0x3
2F0A  6EE6     MOVWF POSTINC1, ACCESS
2F0C  DA16     RCALL M_Ind_LED_blinking
2F0E  52E5     MOVF POSTDEC1, F, ACCESS
2F10  52E5     MOVF POSTDEC1, F, ACCESS
463:           			else
2F12  D007     BRA 0x2F22
464:           			{
465:           				M_Ind_LED_blinking(NO_BLINKING, INDEX_OF_BICOLOR_LED);
2F14  6AE6     CLRF POSTINC1, ACCESS
2F16  6AE6     CLRF POSTINC1, ACCESS
2F18  DA10     RCALL M_Ind_LED_blinking
2F1A  52E5     MOVF POSTDEC1, F, ACCESS
2F1C  52E5     MOVF POSTDEC1, F, ACCESS
466:           				LED_BICOLOR_GREEN_PIN = ON;
2F1E  8A8D     BSF LATE, 5, ACCESS
467:           				LED_BICOLOR_RED_PIN = ON;
2F20  888D     BSF LATE, 4, ACCESS
468:           			}
469:           		break;
2F22  D009     BRA 0x2F36
470:           		case STATE_VIEW_FAILURE :						//отображение в режиме "Авария "
471:           			M_Ind_view_failure();
2F24  D836     RCALL M_Ind_view_failure
472:           			M_Ind_LED_blinking(BLINKING_RED, INDEX_OF_BICOLOR_LED);
2F26  6AE6     CLRF POSTINC1, ACCESS
2F28  0E01     MOVLW 0x1
2F2A  6EE6     MOVWF POSTINC1, ACCESS
2F2C  DA06     RCALL M_Ind_LED_blinking
2F2E  52E5     MOVF POSTDEC1, F, ACCESS
2F30  52E5     MOVF POSTDEC1, F, ACCESS
473:           			LED_FAN_PIN = OFF;
2F32  968D     BCF LATE, 3, ACCESS
474:           		break;
2F34  D000     BRA 0x2F36
475:           		//default:
476:           	}
477:           	M_Ind_7_Segment_Out();
2F36  DE0B     RCALL M_Ind_7_Segment_Out
478:           }
2F38  0012     RETURN 0
479:           
480:           /*Отображение текстовых символов на индикаторе */
481:           static void M_Ind_view_text(const uint8_t left_ind_offset_to_symb, const uint8_t middle_ind_offset_to_symb, 
2F3A  CFD9     MOVFF FSR2, POSTINC1
2F3C  FFE6     NOP
2F3E  CFE1     MOVFF FSR1, FSR2
2F40  FFD9     NOP
482:           						const uint8_t right_ind_offset_to_symb, BOOL need_blink)
483:           {
484:           	if(M_Mngm_Get_Code_Failure() != CODE_FAILURE_IS_NO_FAILURE)
2F42  ECAB     CALL 0x1556, 0
2F44  F00A     NOP
2F46  0900     IORLW 0x0
2F48  E004     BZ 0x2F52
485:           		M_Ind_State = STATE_VIEW_FAILURE;
2F4A  0100     MOVLB 0x0
2F4C  0E08     MOVLW 0x8
2F4E  6FB0     MOVWF M_Ind_State, BANKED
486:           	else
2F50  D01C     BRA 0x2F8A
487:           	{
488:           		M_Ind_data.index_of_text_sym[LEFT_INDICATOR] = left_ind_offset_to_symb;
2F52  0EFE     MOVLW 0xFE
2F54  CFDB     MOVFF PLUSW2, 0x9D
2F56  F09D     NOP
489:           		M_Ind_data.index_of_text_sym[MIDDLE_INDICATOR] = middle_ind_offset_to_symb;
2F58  0EFD     MOVLW 0xFD
2F5A  CFDB     MOVFF PLUSW2, 0x9E
2F5C  F09E     NOP
490:           		M_Ind_data.index_of_text_sym[RIGHT_INDICATOR] = right_ind_offset_to_symb;
2F5E  0EFC     MOVLW 0xFC
2F60  CFDB     MOVFF PLUSW2, 0x9F
2F62  F09F     NOP
491:           		M_Ind_data.dot[LEFT_INDICATOR] = M_Ind_data.const_dot[INDEX_NO_DOT];
2F64  C0A7     MOVFF 0xA7, 0xA3
2F66  F0A3     NOP
492:           		M_Ind_data.dot[MIDDLE_INDICATOR] = M_Ind_data.const_dot[INDEX_NO_DOT];
2F68  C0A7     MOVFF 0xA7, 0xA4
2F6A  F0A4     NOP
493:                   M_Ind_data.dot[RIGHT_INDICATOR] = M_Ind_data.const_dot[INDEX_NO_DOT];
2F6C  C0A7     MOVFF 0xA7, 0xA5
2F6E  F0A5     NOP
494:                   M_Ind_blinking_7segm(LEFT_SYMBOL_NO_DOT, need_blink);
2F70  0EFB     MOVLW 0xFB
2F72  CFDB     MOVFF PLUSW2, POSTINC1
2F74  FFE6     NOP
2F76  6AE6     CLRF POSTINC1, ACCESS
2F78  D82F     RCALL M_Ind_blinking_7segm
2F7A  52E5     MOVF POSTDEC1, F, ACCESS
2F7C  52E5     MOVF POSTDEC1, F, ACCESS
495:                   M_Ind_bin2dec(IT_IS_A_TEXT_SYM_AREA);
2F7E  0E0A     MOVLW 0xA
2F80  6EE6     MOVWF POSTINC1, ACCESS
2F82  6AE6     CLRF POSTINC1, ACCESS
2F84  DE28     RCALL M_Ind_bin2dec
2F86  52E5     MOVF POSTDEC1, F, ACCESS
2F88  52E5     MOVF POSTDEC1, F, ACCESS
496:               }
497:           }
2F8A  52E5     MOVF POSTDEC1, F, ACCESS
2F8C  CFE7     MOVFF INDF1, FSR2
2F8E  FFD9     NOP
2F90  0012     RETURN 0
498:           
499:           /*Индикация в режиме "Авария" */
500:           void M_Ind_view_failure(void)
501:           {
502:           	if(M_Mngm_Get_Code_Failure() == CODE_FAILURE_IS_NO_FAILURE)
2F92  ECAB     CALL 0x1556, 0
2F94  F00A     NOP
2F96  0900     IORLW 0x0
2F98  E103     BNZ 0x2FA0
503:           		M_Ind_State = M_Ind_Previous_State;
2F9A  C0B1     MOVFF M_Ind_Previous_State, M_Ind_State
2F9C  F0B0     NOP
504:           	else
2F9E  D01B     BRA 0x2FD6
505:           	{
506:           		M_Ind_data.index_of_text_sym[LEFT_INDICATOR] = IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_E; 
2FA0  0100     MOVLB 0x0
2FA2  0E0D     MOVLW 0xD
2FA4  6F9D     MOVWF 0x9D, BANKED
507:           		M_Ind_data.index_of_text_sym[MIDDLE_INDICATOR] = M_Ind_data.index_of_text_sym[RIGHT_INDICATOR] = 0;
2FA6  0100     MOVLB 0x0
2FA8  6B9F     CLRF 0x9F, BANKED
2FAA  C09F     MOVFF 0x9F, 0x9E
2FAC  F09E     NOP
508:           		M_Ind_data.dot[LEFT_INDICATOR] = M_Ind_data.const_dot[INDEX_IS_DOT];
2FAE  C0A6     MOVFF 0xA6, 0xA3
2FB0  F0A3     NOP
509:           		M_Ind_data.dot[MIDDLE_INDICATOR] = M_Ind_data.const_dot[INDEX_NO_DOT];
2FB2  C0A7     MOVFF 0xA7, 0xA4
2FB4  F0A4     NOP
510:                   M_Ind_data.dot[RIGHT_INDICATOR] = M_Ind_data.const_dot[INDEX_NO_DOT];
2FB6  C0A7     MOVFF 0xA7, 0xA5
2FB8  F0A5     NOP
511:                   M_Ind_blinking_7segm(LEFT_SYMBOL_WITH_DOT, NEED_BLINK);
2FBA  0E01     MOVLW 0x1
2FBC  6EE6     MOVWF POSTINC1, ACCESS
2FBE  0E01     MOVLW 0x1
2FC0  6EE6     MOVWF POSTINC1, ACCESS
2FC2  D80A     RCALL M_Ind_blinking_7segm
2FC4  52E5     MOVF POSTDEC1, F, ACCESS
2FC6  52E5     MOVF POSTDEC1, F, ACCESS
512:           		M_Ind_bin2dec(M_Mngm_Get_Code_Failure());	
2FC8  ECAB     CALL 0x1556, 0
2FCA  F00A     NOP
2FCC  6EE6     MOVWF POSTINC1, ACCESS
2FCE  6AE6     CLRF POSTINC1, ACCESS
2FD0  DE02     RCALL M_Ind_bin2dec
2FD2  52E5     MOVF POSTDEC1, F, ACCESS
2FD4  52E5     MOVF POSTDEC1, F, ACCESS
513:           	}	
514:           }
2FD6  0012     RETURN 0
515:           
516:           
517:           //Реализация мигания символов
518:           static void M_Ind_blinking_7segm(BOOL state_left_symbol_dot, BOOL need_blink)
2FD8  CFD9     MOVFF FSR2, POSTINC1
2FDA  FFE6     NOP
2FDC  CFE1     MOVFF FSR1, FSR2
2FDE  FFD9     NOP
519:           {	
520:           	if(state_left_symbol_dot) //если в мигании участвует левое из 3-х знакомест с точкой
2FE0  0EFE     MOVLW 0xFE
2FE2  50DB     MOVF PLUSW2, W, ACCESS
2FE4  E00C     BZ 0x2FFE
521:           		M_Ind_data.dot[LEFT_INDICATOR] = M_Ind_data.const_dot[M_Ind_data.Flag_Blink_seven_segm];
2FE6  C099     MOVFF M_Ind_data, FSR0
2FE8  FFE9     NOP
2FEA  6AEA     CLRF FSR0H, ACCESS
2FEC  BEE9     BTFSC FSR0, 7, ACCESS
2FEE  68EA     SETF FSR0H, ACCESS
2FF0  0EA6     MOVLW 0xA6
2FF2  26E9     ADDWF FSR0, F, ACCESS
2FF4  0E00     MOVLW 0x0
2FF6  22EA     ADDWFC FSR0H, F, ACCESS
2FF8  CFEF     MOVFF INDF0, 0xA3
2FFA  F0A3     NOP
522:           	else
2FFC  D002     BRA 0x3002
523:           		M_Ind_data.dot[LEFT_INDICATOR] = M_Ind_data.const_dot[INDEX_NO_DOT];
2FFE  C0A7     MOVFF 0xA7, 0xA3
3000  F0A3     NOP
524:           	if(need_blink)
3002  0EFD     MOVLW 0xFD
3004  50DB     MOVF PLUSW2, W, ACCESS
3006  E024     BZ 0x3050
525:           	{
526:           		if(time_M_Ind.time_blink++ == M_Ind_time_const[e_Time_Blink])
3008  0100     MOVLB 0x0
300A  C0AA     MOVFF 0xAA, __tmp_0
300C  F032     NOP
300E  C0AB     MOVFF 0xAB, 0x33
3010  F033     NOP
3012  2BAA     INCF 0xAA, F, BANKED
3014  0E00     MOVLW 0x0
3016  23AB     ADDWFC 0xAB, F, BANKED
3018  0ED0     MOVLW 0xD0
301A  6EF6     MOVWF TBLPTR, ACCESS
301C  0E4D     MOVLW 0x4D
301E  6EF7     MOVWF TBLPTRH, ACCESS
3020  0009     TBLRD*+
3022  CFF5     MOVFF TABLAT, 0x34
3024  F034     NOP
3026  0008     TBLRD*
3028  CFF5     MOVFF TABLAT, 0x35
302A  F035     NOP
302C  5034     MOVF 0x34, W, ACCESS
302E  1832     XORWF __tmp_0, W, ACCESS
3030  E102     BNZ 0x3036
3032  5035     MOVF 0x35, W, ACCESS
3034  1833     XORWF 0x33, W, ACCESS
3036  E10B     BNZ 0x304E
527:           		{
528:           			time_M_Ind.time_blink = 0;
3038  0100     MOVLB 0x0
303A  6BAA     CLRF 0xAA, BANKED
303C  6BAB     CLRF 0xAB, BANKED
529:           			M_Ind_data.Flag_Blink_seven_segm = !M_Ind_data.Flag_Blink_seven_segm;
303E  0100     MOVLB 0x0
3040  5199     MOVF M_Ind_data, W, BANKED
3042  E002     BZ 0x3048
3044  0E00     MOVLW 0x0
3046  D001     BRA 0x304A
3048  0E01     MOVLW 0x1
304A  0100     MOVLB 0x0
304C  6F99     MOVWF M_Ind_data, BANKED
530:           		}
531:           	}	
532:           	else
304E  D002     BRA 0x3054
533:           		M_Ind_data.Flag_Blink_seven_segm = OFF;
3050  0100     MOVLB 0x0
3052  6B99     CLRF M_Ind_data, BANKED
534:           }
3054  52E5     MOVF POSTDEC1, F, ACCESS
3056  CFE7     MOVFF INDF1, FSR2
3058  FFD9     NOP
305A  0012     RETURN 0
535:           
536:           /* Отображение в режиме "Индикация установленной температуры", "Индикация установленных оборотов вентилятора" */
537:           static void M_Ind_view_temperature_or_fan_level_setup(const uint8_t offset_to_symb, uint8_t parameter)
305C  CFD9     MOVFF FSR2, POSTINC1
305E  FFE6     NOP
3060  CFE1     MOVFF FSR1, FSR2
3062  FFD9     NOP
538:           {
539:           	if(M_Mngm_Get_Code_Failure() != CODE_FAILURE_IS_NO_FAILURE)
3064  ECAB     CALL 0x1556, 0
3066  F00A     NOP
3068  0900     IORLW 0x0
306A  E004     BZ 0x3074
540:           		M_Ind_State = STATE_VIEW_FAILURE;
306C  0100     MOVLB 0x0
306E  0E08     MOVLW 0x8
3070  6FB0     MOVWF M_Ind_State, BANKED
541:           	else
3072  D019     BRA 0x30A6
542:           	{
543:           		M_Ind_data.index_of_text_sym[LEFT_INDICATOR] = IT_IS_A_TEXT_SYM_AREA + offset_to_symb; 
3074  0EFE     MOVLW 0xFE
3076  CFDB     MOVFF PLUSW2, __tmp_0
3078  F032     NOP
307A  0E0A     MOVLW 0xA
307C  2432     ADDWF __tmp_0, W, ACCESS
307E  0100     MOVLB 0x0
3080  6F9D     MOVWF 0x9D, BANKED
544:           		M_Ind_data.index_of_text_sym[MIDDLE_INDICATOR] = M_Ind_data.index_of_text_sym[RIGHT_INDICATOR] = 0;
3082  0100     MOVLB 0x0
3084  6B9F     CLRF 0x9F, BANKED
3086  C09F     MOVFF 0x9F, 0x9E
3088  F09E     NOP
545:           		M_Ind_blinking_7segm(LEFT_SYMBOL_WITH_DOT, NEED_BLINK);
308A  0E01     MOVLW 0x1
308C  6EE6     MOVWF POSTINC1, ACCESS
308E  0E01     MOVLW 0x1
3090  6EE6     MOVWF POSTINC1, ACCESS
3092  DFA2     RCALL M_Ind_blinking_7segm
3094  52E5     MOVF POSTDEC1, F, ACCESS
3096  52E5     MOVF POSTDEC1, F, ACCESS
546:           		M_Ind_bin2dec(parameter);
3098  0EFD     MOVLW 0xFD
309A  CFDB     MOVFF PLUSW2, POSTINC1
309C  FFE6     NOP
309E  6AE6     CLRF POSTINC1, ACCESS
30A0  DD9A     RCALL M_Ind_bin2dec
30A2  52E5     MOVF POSTDEC1, F, ACCESS
30A4  52E5     MOVF POSTDEC1, F, ACCESS
547:           	}
548:           }
30A6  52E5     MOVF POSTDEC1, F, ACCESS
30A8  CFE7     MOVFF INDF1, FSR2
30AA  FFD9     NOP
30AC  0012     RETURN 0
549:           
550:           /* Установка счётчикак таймера автовыхода по енажатию ни на одну из кнопок в меню*/
551:           void M_Ind_setTimeAutoExit( uint8_t value )
30AE  CFD9     MOVFF FSR2, POSTINC1
30B0  FFE6     NOP
30B2  CFE1     MOVFF FSR1, FSR2
30B4  FFD9     NOP
552:           {
553:           	time_M_Ind.time_auto_exit = value;
30B6  0EFE     MOVLW 0xFE
30B8  50DB     MOVF PLUSW2, W, ACCESS
30BA  0100     MOVLB 0x0
30BC  6FAC     MOVWF 0xAC, BANKED
30BE  6BAD     CLRF 0xAD, BANKED
554:           }
30C0  52E5     MOVF POSTDEC1, F, ACCESS
30C2  CFE7     MOVFF INDF1, FSR2
30C4  FFD9     NOP
30C6  0012     RETURN 0
555:           
556:           /* Организация таймера автовыхода по ненажатию ни на одну из кнопок в меню */
557:           void M_Ind_TimerAutoExit( void )
558:           {
559:           	//Организация автоматического выхода по таймеру, если не нажата ни одна из кнопок
560:           	if(time_M_Ind.time_auto_exit++ == (M_Mngm_Get_parameters_buffer()->menu_parameters.time_auto_exit) * 1000U)
30C8  0100     MOVLB 0x0
30CA  C0AC     MOVFF 0xAC, __tmp_0
30CC  F032     NOP
30CE  C0AD     MOVFF 0xAD, 0x33
30D0  F033     NOP
30D2  2BAC     INCF 0xAC, F, BANKED
30D4  0E00     MOVLW 0x0
30D6  23AD     ADDWFC 0xAD, F, BANKED
30D8  C032     MOVFF __tmp_0, POSTINC1
30DA  FFE6     NOP
30DC  C033     MOVFF 0x33, POSTINC1
30DE  FFE6     NOP
30E0  EC8E     CALL 0x151C, 0
30E2  F00A     NOP
30E4  52E5     MOVF POSTDEC1, F, ACCESS
30E6  CFE7     MOVFF INDF1, 0x33
30E8  F033     NOP
30EA  52E5     MOVF POSTDEC1, F, ACCESS
30EC  CFE7     MOVFF INDF1, __tmp_0
30EE  F032     NOP
30F0  CFF3     MOVFF PROD, FSR0
30F2  FFE9     NOP
30F4  CFF4     MOVFF PRODH, FSR0H
30F6  FFEA     NOP
30F8  0E2A     MOVLW 0x2A
30FA  26E9     ADDWF FSR0, F, ACCESS
30FC  0E00     MOVLW 0x0
30FE  22EA     ADDWFC FSR0H, F, ACCESS
3100  50EF     MOVF INDF0, W, ACCESS
3102  6E34     MOVWF 0x34, ACCESS
3104  6A35     CLRF 0x35, ACCESS
3106  0EE8     MOVLW 0xE8
3108  0235     MULWF 0x35, ACCESS
310A  CFF3     MOVFF PROD, 0x35
310C  F035     NOP
310E  0E03     MOVLW 0x3
3110  0234     MULWF 0x34, ACCESS
3112  50F3     MOVF PROD, W, ACCESS
3114  2635     ADDWF 0x35, F, ACCESS
3116  0EE8     MOVLW 0xE8
3118  0234     MULWF 0x34, ACCESS
311A  CFF3     MOVFF PROD, 0x34
311C  F034     NOP
311E  50F4     MOVF PRODH, W, ACCESS
3120  2635     ADDWF 0x35, F, ACCESS
3122  5034     MOVF 0x34, W, ACCESS
3124  1832     XORWF __tmp_0, W, ACCESS
3126  E102     BNZ 0x312C
3128  5035     MOVF 0x35, W, ACCESS
312A  1833     XORWF 0x33, W, ACCESS
312C  E112     BNZ 0x3152
561:           	{
562:           		time_M_Ind.time_auto_exit = 0;
312E  0100     MOVLB 0x0
3130  6BAC     CLRF 0xAC, BANKED
3132  6BAD     CLRF 0xAD, BANKED
563:           		if((M_LI_Get_Key_State()->M_LI_Code_Key) == 0U) //если по истечении времени автовыхода не нажата ни одна из кнопок
3134  ECC7     CALL 0x3B8E, 0
3136  F01D     NOP
3138  CFF3     MOVFF PROD, FSR0
313A  FFE9     NOP
313C  CFF4     MOVFF PRODH, FSR0H
313E  FFEA     NOP
3140  0E02     MOVLW 0x2
3142  26E9     ADDWF FSR0, F, ACCESS
3144  0E00     MOVLW 0x0
3146  22EA     ADDWFC FSR0H, F, ACCESS
3148  50EF     MOVF INDF0, W, ACCESS
314A  E103     BNZ 0x3152
564:           			M_Ind_State = STATE_VIEW_TEMPERATURE_REAL;	
314C  0100     MOVLB 0x0
314E  0E03     MOVLW 0x3
3150  6FB0     MOVWF M_Ind_State, BANKED
565:           	}
566:           }
3152  0012     RETURN 0
567:           
568:           /* Отображение номера страницы инженерного меню  */
569:           static void M_Ind_view_num_page_menu(void) 
570:           {
571:           	if(M_Mngm_Get_Code_Failure() != CODE_FAILURE_IS_NO_FAILURE)
3154  ECAB     CALL 0x1556, 0
3156  F00A     NOP
3158  0900     IORLW 0x0
315A  E007     BZ 0x316A
572:           	{
573:           		M_Ind_State = STATE_VIEW_FAILURE;
315C  0100     MOVLB 0x0
315E  0E08     MOVLW 0x8
3160  6FB0     MOVWF M_Ind_State, BANKED
574:           		time_M_Ind.time_auto_exit = 0;
3162  0100     MOVLB 0x0
3164  6BAC     CLRF 0xAC, BANKED
3166  6BAD     CLRF 0xAD, BANKED
575:           	}
576:           	else
3168  D010     BRA 0x318A
577:           	{
578:           		M_Ind_data.index_of_text_sym[LEFT_INDICATOR] = IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_P; 	
316A  0100     MOVLB 0x0
316C  0E0B     MOVLW 0xB
316E  6F9D     MOVWF 0x9D, BANKED
579:           		M_Ind_data.index_of_text_sym[MIDDLE_INDICATOR] = M_Ind_data.index_of_text_sym[RIGHT_INDICATOR] = 0;
3170  0100     MOVLB 0x0
3172  6B9F     CLRF 0x9F, BANKED
3174  C09F     MOVFF 0x9F, 0x9E
3176  F09E     NOP
580:           		M_Ind_bin2dec(Menu_Get_Num_Page_Menu());
3178  EC24     CALL 0x2048, 0
317A  F010     NOP
317C  6EE6     MOVWF POSTINC1, ACCESS
317E  6AE6     CLRF POSTINC1, ACCESS
3180  DD2A     RCALL M_Ind_bin2dec
3182  52E5     MOVF POSTDEC1, F, ACCESS
3184  52E5     MOVF POSTDEC1, F, ACCESS
581:           		M_Ind_data.dot[LEFT_INDICATOR] = M_Ind_data.const_dot[INDEX_IS_DOT];
3186  C0A6     MOVFF 0xA6, 0xA3
3188  F0A3     NOP
582:           	}
583:           }
318A  0012     RETURN 0
584:           
585:           /* Отображение параметра инженерного меню, подлежащего изменению и сохранению */
586:           static void M_Ind_view_parameter_menu(void)
587:           {
588:           	
589:           	if(M_Mngm_Get_Code_Failure() != CODE_FAILURE_IS_NO_FAILURE)
318C  ECAB     CALL 0x1556, 0
318E  F00A     NOP
3190  0900     IORLW 0x0
3192  E004     BZ 0x319C
590:           		M_Ind_State = STATE_VIEW_FAILURE;
3194  0100     MOVLB 0x0
3196  0E08     MOVLW 0x8
3198  6FB0     MOVWF M_Ind_State, BANKED
591:           	else
319A  D02A     BRA 0x31F0
592:           	{
593:           		M_Ind_data.dot[LEFT_INDICATOR] = NO_DOT;
319C  0100     MOVLB 0x0
319E  69A3     SETF 0xA3, BANKED
594:           		M_Ind_data.index_of_text_sym[LEFT_INDICATOR] = M_Ind_data.index_of_text_sym[MIDDLE_INDICATOR]
595:           		= M_Ind_data.index_of_text_sym[RIGHT_INDICATOR] = 0; //в этом режиме выводятся только цифры
31A0  0100     MOVLB 0x0
31A2  6B9F     CLRF 0x9F, BANKED
31A4  C09F     MOVFF 0x9F, 0x9E
31A6  F09E     NOP
31A8  C09F     MOVFF 0x9F, 0x9D
31AA  F09D     NOP
596:           		M_Ind_bin2dec(M_Mngm_Get_parameters_buffer()->buffer[Menu_Get_Num_Page_Menu()]);
31AC  EC8E     CALL 0x151C, 0
31AE  F00A     NOP
31B0  CFF3     MOVFF PROD, FSR0
31B2  FFE9     NOP
31B4  CFF4     MOVFF PRODH, FSR0H
31B6  FFEA     NOP
31B8  CFE9     MOVFF FSR0, __tmp_0
31BA  F032     NOP
31BC  CFEA     MOVFF FSR0H, 0x33
31BE  F033     NOP
31C0  C032     MOVFF __tmp_0, POSTINC1
31C2  FFE6     NOP
31C4  C033     MOVFF 0x33, POSTINC1
31C6  FFE6     NOP
31C8  EC24     CALL 0x2048, 0
31CA  F010     NOP
31CC  52E5     MOVF POSTDEC1, F, ACCESS
31CE  CFE7     MOVFF INDF1, 0x33
31D0  F033     NOP
31D2  52E5     MOVF POSTDEC1, F, ACCESS
31D4  CFE7     MOVFF INDF1, __tmp_0
31D6  F032     NOP
31D8  010F     MOVLB 0xF
31DA  2432     ADDWF __tmp_0, W, ACCESS
31DC  6EE9     MOVWF FSR0, ACCESS
31DE  0E00     MOVLW 0x0
31E0  2033     ADDWFC 0x33, W, ACCESS
31E2  6EEA     MOVWF FSR0H, ACCESS
31E4  50EF     MOVF INDF0, W, ACCESS
31E6  6EE6     MOVWF POSTINC1, ACCESS
31E8  6AE6     CLRF POSTINC1, ACCESS
31EA  DCF5     RCALL M_Ind_bin2dec
31EC  52E5     MOVF POSTDEC1, F, ACCESS
31EE  52E5     MOVF POSTDEC1, F, ACCESS
597:           	}
598:           }
31F0  0012     RETURN 0
599:           
600:           /* Вывод на индикатор температуры воды и типа топлива с точкой */
601:           static void M_Ind_temperature_real(void)
602:           {
603:           	if(M_Mngm_Get_Code_Failure() != CODE_FAILURE_IS_NO_FAILURE)
31F2  ECAB     CALL 0x1556, 0
31F4  F00A     NOP
31F6  0900     IORLW 0x0
31F8  E004     BZ 0x3202
604:           	    M_Ind_State = STATE_VIEW_FAILURE;
31FA  0100     MOVLB 0x0
31FC  0E08     MOVLW 0x8
31FE  6FB0     MOVWF M_Ind_State, BANKED
605:           	else
3200  D04C     BRA 0x329A
606:           	{	
607:           		M_Ind_data.index_of_text_sym[MIDDLE_INDICATOR] = M_Ind_data.index_of_text_sym[RIGHT_INDICATOR] = 0; 
3202  0100     MOVLB 0x0
3204  6B9F     CLRF 0x9F, BANKED
3206  C09F     MOVFF 0x9F, 0x9E
3208  F09E     NOP
608:           		if(Menu_get_temper_water_or_gas())
320A  EC20     CALL 0x2040, 0
320C  F010     NOP
320E  0900     IORLW 0x0
3210  E016     BZ 0x323E
609:           		{
610:           			M_Ind_data.index_of_text_sym[LEFT_INDICATOR] = IT_IS_A_TEXT_SYM_AREA + OFFSET_TO_SYMBOL_d;
3212  0100     MOVLB 0x0
3214  0E16     MOVLW 0x16
3216  6F9D     MOVWF 0x9D, BANKED
611:           			M_Ind_bin2dec(M_AI_Get_ADC_Data(CHN_T_GAS)->param);
3218  6AE6     CLRF POSTINC1, ACCESS
321A  EC3C     CALL 0x3478, 0
321C  F01A     NOP
321E  52E5     MOVF POSTDEC1, F, ACCESS
3220  CFF3     MOVFF PROD, FSR0
3222  FFE9     NOP
3224  CFF4     MOVFF PRODH, FSR0H
3226  FFEA     NOP
3228  0E05     MOVLW 0x5
322A  26E9     ADDWF FSR0, F, ACCESS
322C  0E00     MOVLW 0x0
322E  22EA     ADDWFC FSR0H, F, ACCESS
3230  50EF     MOVF INDF0, W, ACCESS
3232  6EE6     MOVWF POSTINC1, ACCESS
3234  6AE6     CLRF POSTINC1, ACCESS
3236  DCCF     RCALL M_Ind_bin2dec
3238  52E5     MOVF POSTDEC1, F, ACCESS
323A  52E5     MOVF POSTDEC1, F, ACCESS
612:           		}
613:           		else
323C  D02A     BRA 0x3292
614:           		{
615:           			M_Ind_bin2dec(M_AI_Get_ADC_Data(CHN_T_WATER)->param);
323E  0E01     MOVLW 0x1
3240  6EE6     MOVWF POSTINC1, ACCESS
3242  EC3C     CALL 0x3478, 0
3244  F01A     NOP
3246  52E5     MOVF POSTDEC1, F, ACCESS
3248  CFF3     MOVFF PROD, FSR0
324A  FFE9     NOP
324C  CFF4     MOVFF PRODH, FSR0H
324E  FFEA     NOP
3250  0E05     MOVLW 0x5
3252  26E9     ADDWF FSR0, F, ACCESS
3254  0E00     MOVLW 0x0
3256  22EA     ADDWFC FSR0H, F, ACCESS
3258  50EF     MOVF INDF0, W, ACCESS
325A  6EE6     MOVWF POSTINC1, ACCESS
325C  6AE6     CLRF POSTINC1, ACCESS
325E  DCBB     RCALL M_Ind_bin2dec
3260  52E5     MOVF POSTDEC1, F, ACCESS
3262  52E5     MOVF POSTDEC1, F, ACCESS
616:           			M_Ind_data.index_of_text_sym[LEFT_INDICATOR] = M_Mngm_Get_parameters_buffer()->menu_parameters.fuel_type 
3264  EC8E     CALL 0x151C, 0
3266  F00A     NOP
3268  CFF3     MOVFF PROD, FSR0
326A  FFE9     NOP
326C  CFF4     MOVFF PRODH, FSR0H
326E  FFEA     NOP
3270  0E28     MOVLW 0x28
3272  26E9     ADDWF FSR0, F, ACCESS
3274  0E00     MOVLW 0x0
3276  22EA     ADDWFC FSR0H, F, ACCESS
3278  50EF     MOVF INDF0, W, ACCESS
617:           				+ INDEX_OF_AREA_FUEL_TYPE;
327A  6E32     MOVWF __tmp_0, ACCESS
327C  6A33     CLRF 0x33, ACCESS
327E  0E18     MOVLW 0x18
3280  2632     ADDWF __tmp_0, F, ACCESS
3282  0E00     MOVLW 0x0
3284  2233     ADDWFC 0x33, F, ACCESS
3286  0E07     MOVLW 0x7
3288  5E32     SUBWF __tmp_0, F, ACCESS
328A  0E00     MOVLW 0x0
328C  5A33     SUBWFB 0x33, F, ACCESS
328E  C032     MOVFF __tmp_0, 0x9D
3290  F09D     NOP
618:           		}
619:           		M_Ind_data.dot[LEFT_INDICATOR] = M_Ind_data.const_dot[INDEX_IS_DOT];
3292  C0A6     MOVFF 0xA6, 0xA3
3294  F0A3     NOP
620:           		M_Ind_data.Flag_Blink_seven_segm = FALSE;
3296  0100     MOVLB 0x0
3298  6B99     CLRF M_Ind_data, BANKED
621:           	}
622:           }
329A  0012     RETURN 0
623:           
624:           /* Отображение номера версии ПО по старту программы  */
625:           static void M_Ind_View_SW_version(void)
626:           {
627:           	//Проверка - прошло ли время инициализации модуля индикации
628:           	M_Ind_data.dot[MIDDLE_INDICATOR] = M_Ind_data.const_dot[INDEX_NO_DOT];
329C  C0A7     MOVFF 0xA7, 0xA4
329E  F0A4     NOP
629:               M_Ind_data.dot[RIGHT_INDICATOR] = M_Ind_data.const_dot[INDEX_NO_DOT];
32A0  C0A7     MOVFF 0xA7, 0xA5
32A2  F0A5     NOP
630:               if(time_M_Ind.time_init++ == M_Ind_time_const[e_Time_Init]*1000U)
32A4  0100     MOVLB 0x0
32A6  C0A8     MOVFF time_M_Ind, __tmp_0
32A8  F032     NOP
32AA  C0A9     MOVFF 0xA9, 0x33
32AC  F033     NOP
32AE  2BA8     INCF time_M_Ind, F, BANKED
32B0  0E00     MOVLW 0x0
32B2  23A9     ADDWFC 0xA9, F, BANKED
32B4  0ECE     MOVLW 0xCE
32B6  6EF6     MOVWF TBLPTR, ACCESS
32B8  0E4D     MOVLW 0x4D
32BA  6EF7     MOVWF TBLPTRH, ACCESS
32BC  0009     TBLRD*+
32BE  CFF5     MOVFF TABLAT, 0x34
32C0  F034     NOP
32C2  0008     TBLRD*
32C4  CFF5     MOVFF TABLAT, 0x35
32C6  F035     NOP
32C8  0EE8     MOVLW 0xE8
32CA  0235     MULWF 0x35, ACCESS
32CC  CFF3     MOVFF PROD, 0x35
32CE  F035     NOP
32D0  0E03     MOVLW 0x3
32D2  0234     MULWF 0x34, ACCESS
32D4  50F3     MOVF PROD, W, ACCESS
32D6  2635     ADDWF 0x35, F, ACCESS
32D8  0EE8     MOVLW 0xE8
32DA  0234     MULWF 0x34, ACCESS
32DC  CFF3     MOVFF PROD, 0x34
32DE  F034     NOP
32E0  50F4     MOVF PRODH, W, ACCESS
32E2  2635     ADDWF 0x35, F, ACCESS
32E4  5034     MOVF 0x34, W, ACCESS
32E6  1832     XORWF __tmp_0, W, ACCESS
32E8  E102     BNZ 0x32EE
32EA  5035     MOVF 0x35, W, ACCESS
32EC  1833     XORWF 0x33, W, ACCESS
32EE  E10B     BNZ 0x3306
631:           	{
632:           		time_M_Ind.time_init = 0;
32F0  0100     MOVLB 0x0
32F2  6BA8     CLRF time_M_Ind, BANKED
32F4  6BA9     CLRF 0xA9, BANKED
633:           		M_Ind_data.Flag_Blink_seven_segm = FALSE;
32F6  0100     MOVLB 0x0
32F8  6B99     CLRF M_Ind_data, BANKED
634:           		M_Ind_data.dot[LEFT_INDICATOR] = NO_DOT;
32FA  0100     MOVLB 0x0
32FC  69A3     SETF 0xA3, BANKED
635:           		M_Ind_State = STATE_VIEW_TEMPERATURE_REAL;
32FE  0100     MOVLB 0x0
3300  0E03     MOVLW 0x3
3302  6FB0     MOVWF M_Ind_State, BANKED
636:           		//разрешить внешние прерывания INT2 (для детектирования переходов через нуль сетевого напряжения) 
637:           		//INTCON3 = 0xD8;		//и INT1 (для опроса датчика ворошителя)
638:           	}
639:           	else //иначе мигаем версией программного обеспечения
3304  D019     BRA 0x3338
640:           	{
641:           		M_Ind_blinking_7segm(LEFT_SYMBOL_WITH_DOT, NEED_BLINK);
3306  0E01     MOVLW 0x1
3308  6EE6     MOVWF POSTINC1, ACCESS
330A  0E01     MOVLW 0x1
330C  6EE6     MOVWF POSTINC1, ACCESS
330E  DE64     RCALL M_Ind_blinking_7segm
3310  52E5     MOVF POSTDEC1, F, ACCESS
3312  52E5     MOVF POSTDEC1, F, ACCESS
642:           
643:           		M_Ind_bin2dec(M_Mngm_Get_parameters_buffer()->menu_parameters.software_version);
3314  EC8E     CALL 0x151C, 0
3316  F00A     NOP
3318  CFF3     MOVFF PROD, FSR0
331A  FFE9     NOP
331C  CFF4     MOVFF PRODH, FSR0H
331E  FFEA     NOP
3320  0E34     MOVLW 0x34
3322  26E9     ADDWF FSR0, F, ACCESS
3324  0E00     MOVLW 0x0
3326  22EA     ADDWFC FSR0H, F, ACCESS
3328  50EF     MOVF INDF0, W, ACCESS
332A  6EE6     MOVWF POSTINC1, ACCESS
332C  6AE6     CLRF POSTINC1, ACCESS
332E  DC53     RCALL M_Ind_bin2dec
3330  52E5     MOVF POSTDEC1, F, ACCESS
3332  52E5     MOVF POSTDEC1, F, ACCESS
644:           		M_Ind_State = STATE_IND_INIT;		
3334  0100     MOVLB 0x0
3336  6BB0     CLRF M_Ind_State, BANKED
645:           	}
646:           }
3338  0012     RETURN 0
647:           
648:           /* Мигание светодиодов  */
649:           static void M_Ind_LED_blinking(uint8_t action, const uint8_t index)
333A  CFD9     MOVFF FSR2, POSTINC1
333C  FFE6     NOP
333E  CFE1     MOVFF FSR1, FSR2
3340  FFD9     NOP
650:           {
651:           	if(action != NO_BLINKING)
3342  0EFE     MOVLW 0xFE
3344  50DB     MOVF PLUSW2, W, ACCESS
3346  E101     BNZ 0x334A
3348  D088     BRA 0x345A
652:           	{
653:           		if(time_M_Ind.time_blink_LED++ == M_Ind_time_const[e_Time_Blink])
334A  0100     MOVLB 0x0
334C  C0AE     MOVFF 0xAE, __tmp_0
334E  F032     NOP
3350  C0AF     MOVFF 0xAF, 0x33
3352  F033     NOP
3354  2BAE     INCF 0xAE, F, BANKED
3356  0E00     MOVLW 0x0
3358  23AF     ADDWFC 0xAF, F, BANKED
335A  0ED0     MOVLW 0xD0
335C  6EF6     MOVWF TBLPTR, ACCESS
335E  0E4D     MOVLW 0x4D
3360  6EF7     MOVWF TBLPTRH, ACCESS
3362  0009     TBLRD*+
3364  CFF5     MOVFF TABLAT, 0x34
3366  F034     NOP
3368  0008     TBLRD*
336A  CFF5     MOVFF TABLAT, 0x35
336C  F035     NOP
336E  5034     MOVF 0x34, W, ACCESS
3370  1832     XORWF __tmp_0, W, ACCESS
3372  E102     BNZ 0x3378
3374  5035     MOVF 0x35, W, ACCESS
3376  1833     XORWF 0x33, W, ACCESS
3378  E11A     BNZ 0x33AE
654:           		{
655:           			time_M_Ind.time_blink_LED = 0;
337A  0100     MOVLB 0x0
337C  6BAE     CLRF 0xAE, BANKED
337E  6BAF     CLRF 0xAF, BANKED
656:           			M_Ind_data.Flag_Blink_led[index] = !M_Ind_data.Flag_Blink_led[index];
3380  0EFD     MOVLW 0xFD
3382  50DB     MOVF PLUSW2, W, ACCESS
3384  6AEA     CLRF FSR0H, ACCESS
3386  0F9A     ADDLW 0x9A
3388  6EE9     MOVWF FSR0, ACCESS
338A  0E00     MOVLW 0x0
338C  22EA     ADDWFC FSR0H, F, ACCESS
338E  50EF     MOVF INDF0, W, ACCESS
3390  E002     BZ 0x3396
3392  0E00     MOVLW 0x0
3394  D001     BRA 0x3398
3396  0E01     MOVLW 0x1
3398  6EE6     MOVWF POSTINC1, ACCESS
339A  0EFD     MOVLW 0xFD
339C  50DB     MOVF PLUSW2, W, ACCESS
339E  6AEA     CLRF FSR0H, ACCESS
33A0  0F9A     ADDLW 0x9A
33A2  6EE9     MOVWF FSR0, ACCESS
33A4  0E00     MOVLW 0x0
33A6  22EA     ADDWFC FSR0H, F, ACCESS
33A8  52E5     MOVF POSTDEC1, F, ACCESS
33AA  50E7     MOVF INDF1, W, ACCESS
33AC  6EEF     MOVWF INDF0, ACCESS
657:           		}
658:           		switch(action)
33AE  0EFE     MOVLW 0xFE
33B0  50DB     MOVF PLUSW2, W, ACCESS
33B2  0A05     XORLW 0x5
33B4  E044     BZ 0x343E
33B6  0A01     XORLW 0x1
33B8  E036     BZ 0x3426
33BA  0A07     XORLW 0x7
33BC  E021     BZ 0x3400
33BE  0A01     XORLW 0x1
33C0  E011     BZ 0x33E4
33C2  0A03     XORLW 0x3
33C4  E001     BZ 0x33C8
33C6  D048     BRA 0x3458
659:           		{
660:           			case BLINKING_RED:	//мигание красного
661:           				LED_BICOLOR_RED_PIN = M_Ind_data.Flag_Blink_led[index];
33C8  0EFD     MOVLW 0xFD
33CA  50DB     MOVF PLUSW2, W, ACCESS
33CC  6AEA     CLRF FSR0H, ACCESS
33CE  0F9A     ADDLW 0x9A
33D0  6EE9     MOVWF FSR0, ACCESS
33D2  0E00     MOVLW 0x0
33D4  22EA     ADDWFC FSR0H, F, ACCESS
33D6  50EF     MOVF INDF0, W, ACCESS
33D8  B0E8     BTFSC WREG, 0, ACCESS
33DA  888D     BSF LATE, 4, ACCESS
33DC  A0E8     BTFSS WREG, 0, ACCESS
33DE  988D     BCF LATE, 4, ACCESS
662:           				LED_BICOLOR_GREEN_PIN = OFF;
33E0  9A8D     BCF LATE, 5, ACCESS
663:           				break;
33E2  D03A     BRA 0x3458
664:           			case BLINKING_GREEN:	//мигание зелёного
665:           				LED_BICOLOR_RED_PIN = OFF;
33E4  988D     BCF LATE, 4, ACCESS
666:           				LED_BICOLOR_GREEN_PIN = M_Ind_data.Flag_Blink_led[index];
33E6  0EFD     MOVLW 0xFD
33E8  50DB     MOVF PLUSW2, W, ACCESS
33EA  6AEA     CLRF FSR0H, ACCESS
33EC  0F9A     ADDLW 0x9A
33EE  6EE9     MOVWF FSR0, ACCESS
33F0  0E00     MOVLW 0x0
33F2  22EA     ADDWFC FSR0H, F, ACCESS
33F4  50EF     MOVF INDF0, W, ACCESS
33F6  B0E8     BTFSC WREG, 0, ACCESS
33F8  8A8D     BSF LATE, 5, ACCESS
33FA  A0E8     BTFSS WREG, 0, ACCESS
33FC  9A8D     BCF LATE, 5, ACCESS
667:           				break;	
33FE  D02C     BRA 0x3458
668:           			case BLINKING_YELLOW:	//мигание жёлтого (Ж = К+З)
669:           				LED_BICOLOR_RED_PIN = LED_BICOLOR_GREEN_PIN = M_Ind_data.Flag_Blink_led[index]; 
3400  0EFD     MOVLW 0xFD
3402  50DB     MOVF PLUSW2, W, ACCESS
3404  6AEA     CLRF FSR0H, ACCESS
3406  0F9A     ADDLW 0x9A
3408  6EE9     MOVWF FSR0, ACCESS
340A  0E00     MOVLW 0x0
340C  22EA     ADDWFC FSR0H, F, ACCESS
340E  50EF     MOVF INDF0, W, ACCESS
3410  B0E8     BTFSC WREG, 0, ACCESS
3412  8A8D     BSF LATE, 5, ACCESS
3414  A0E8     BTFSS WREG, 0, ACCESS
3416  9A8D     BCF LATE, 5, ACCESS
3418  508D     MOVF LATE, W, ACCESS
341A  0B20     ANDLW 0x20
341C  E002     BZ 0x3422
341E  888D     BSF LATE, 4, ACCESS
3420  D001     BRA 0x3424
3422  988D     BCF LATE, 4, ACCESS
670:           				break;
3424  D019     BRA 0x3458
671:           			case BLINKING_FAN_PIN:	//мигание светодиода "Вентилятор" (при горении, в подсостояния подержания температуры)
672:           				LED_FAN_PIN =  M_Ind_data.Flag_Blink_led[index];
3426  0EFD     MOVLW 0xFD
3428  50DB     MOVF PLUSW2, W, ACCESS
342A  6AEA     CLRF FSR0H, ACCESS
342C  0F9A     ADDLW 0x9A
342E  6EE9     MOVWF FSR0, ACCESS
3430  0E00     MOVLW 0x0
3432  22EA     ADDWFC FSR0H, F, ACCESS
3434  50EF     MOVF INDF0, W, ACCESS
3436  B0E8     BTFSC WREG, 0, ACCESS
3438  868D     BSF LATE, 3, ACCESS
343A  A0E8     BTFSS WREG, 0, ACCESS
343C  968D     BCF LATE, 3, ACCESS
673:                       case BLINKING_PUMP_PIN:  //to do!!!
674:                           LED_PUMP_PIN =  M_Ind_data.Flag_Blink_led[index]; //Мигание светодиода "Насос"
343E  0EFD     MOVLW 0xFD
3440  50DB     MOVF PLUSW2, W, ACCESS
3442  6AEA     CLRF FSR0H, ACCESS
3444  0F9A     ADDLW 0x9A
3446  6EE9     MOVWF FSR0, ACCESS
3448  0E00     MOVLW 0x0
344A  22EA     ADDWFC FSR0H, F, ACCESS
344C  50EF     MOVF INDF0, W, ACCESS
344E  B0E8     BTFSC WREG, 0, ACCESS
3450  848D     BSF LATE, 2, ACCESS
3452  A0E8     BTFSS WREG, 0, ACCESS
3454  948D     BCF LATE, 2, ACCESS
675:                           break;
3456  D000     BRA 0x3458
676:                   }
677:           	}
678:           	else
3458  D00B     BRA 0x3470
679:           	{
680:           		M_Ind_data.Flag_Blink_led[index] = NO_BLINKING; 
345A  0EFD     MOVLW 0xFD
345C  50DB     MOVF PLUSW2, W, ACCESS
345E  6AEA     CLRF FSR0H, ACCESS
3460  0F9A     ADDLW 0x9A
3462  6EE9     MOVWF FSR0, ACCESS
3464  0E00     MOVLW 0x0
3466  22EA     ADDWFC FSR0H, F, ACCESS
3468  6AEF     CLRF INDF0, ACCESS
681:           		time_M_Ind.time_blink_LED = 0;
346A  0100     MOVLB 0x0
346C  6BAE     CLRF 0xAE, BANKED
346E  6BAF     CLRF 0xAF, BANKED
682:           	}
683:           }
3470  52E5     MOVF POSTDEC1, F, ACCESS
3472  CFE7     MOVFF INDF1, FSR2
3474  FFD9     NOP
3476  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_fan/module_fan.c  -------------------------
1:             #include "stdint.h"
2:             #include "module_fan.h"
3:             #include "module_indication.h"
4:             #include "interrupts.h"
5:             #include "module_management.h"
6:             #include "main.h"
7:             #include <p18cxxx.h>
8:             
9:             
10:            #define THRESHOLD_ZERO_CROSS 			480U	//порог накопления количества переходов через нуль для определения наличия напряжения ~220В
11:            #define M_FAN_WAITING					1
12:            #define M_FAN_FAILURE					2
13:            #define M_FAN_WORK_OR_OFF				3
14:            #define M_FAN_WORK_CYCLE_TIMER          4
15:            #define TIME_CHECK_SYNCHRO_IMPULSE		25U //25мс
16:            
17:            #define HALF_SINUS_PERIOD_MS			10
18:            #define FAN_PIN							LATFbits.LATF2
19:            #define FAN_TRIS                        TRISFbits.TRISF2
20:            #define TIMEOUT_TASK_FAN				1
21:            #define TIME_TRIAK_IS_ON				1
22:            #define FIRST_HALF_SINUS_PERIOD			0
23:            #define SECOND_HALF_SINUS_PERIOD		1
24:            #define FAN_MAX_LEVEL_ROTATION_SPEED	8U
25:            #define MIN_FAN_LEVEL					2
26:            
27:            
28:            typedef struct 
29:            {
30:            	uint16_t time_detect_zero_cross;
31:            	uint16_t time_before_triac_is_on;
32:            }TIME_M_Fan;
33:            
34:            
35:            const rom uint16_t M_fan_time_accum_zero_cross = 10000;  //10 с - время накопления переходов через ноль напряжения 220В 
36:            
37:            /* Переменные модуля */
38:            BOOL M_fan_is_220V = ON;
39:            BOOL ctrl_fan = FALSE;
40:            uint8_t M_fan_state = M_FAN_WAITING;
41:            uint8_t M_fan_previous_state = M_FAN_WAITING;
42:            uint8_t level_fan = MIN_FAN_LEVEL;
43:            uint8_t step_force_fan = 0;
44:            uint16_t timer_force_fan = 0;
45:            
46:            
47:            /* Структуры модуля  */
48:            TIME_M_Fan time_M_Fan = {0};
49:            
50:            
51:            
52:            void M_Fan_ctor( void )
53:            {
54:                FAN_TRIS = OUT;
41A4  9497     BCF TRISF, 2, ACCESS
55:                FAN_PIN = OFF;		
41A6  948E     BCF LATF, 2, ACCESS
56:            }
41A8  0012     RETURN 0
57:            
58:            void M_fan_set_level_fan(uint8_t value)
41AA  CFD9     MOVFF FSR2, POSTINC1
41AC  FFE6     NOP
41AE  CFE1     MOVFF FSR1, FSR2
41B0  FFD9     NOP
59:            {
60:            	level_fan = value;
41B2  0EFE     MOVLW 0xFE
41B4  CFDB     MOVFF PLUSW2, level_fan
41B6  F0ED     NOP
61:            }
41B8  52E5     MOVF POSTDEC1, F, ACCESS
41BA  CFE7     MOVFF INDF1, FSR2
41BC  FFD9     NOP
41BE  0012     RETURN 0
62:            
63:            /* Функции*/
64:            void M_fan_set_ctrl_fan (BOOL value)
41C0  CFD9     MOVFF FSR2, POSTINC1
41C2  FFE6     NOP
41C4  CFE1     MOVFF FSR1, FSR2
41C6  FFD9     NOP
65:            {
66:            	ctrl_fan = value;
41C8  0EFE     MOVLW 0xFE
41CA  CFDB     MOVFF PLUSW2, ctrl_fan
41CC  F0EA     NOP
67:            }
41CE  52E5     MOVF POSTDEC1, F, ACCESS
41D0  CFE7     MOVFF INDF1, FSR2
41D2  FFD9     NOP
41D4  0012     RETURN 0
68:            
69:            BOOL M_fan_get_ctrl_fan(void)
70:            {
71:            	return ctrl_fan;
41D6  0100     MOVLB 0x0
41D8  51EA     MOVF ctrl_fan, W, BANKED
41DA  D000     BRA 0x41DC
72:            }
41DC  0012     RETURN 0
73:            
74:            BOOL M_fan_get_is_220V(void)
75:            {
76:            	return M_fan_is_220V;
41DE  0100     MOVLB 0x0
41E0  51E9     MOVF M_fan_is_220V, W, BANKED
41E2  D000     BRA 0x41E4
77:            }
41E4  0012     RETURN 0
78:            
79:            /* Функция проверки наличия 220В  */
80:            BOOL  M_fan_check_220V(void)
81:            {
82:            	#ifdef NO_220V_CONTROL
83:            		M_fan_is_220V = ON;
41E6  0100     MOVLB 0x0
41E8  0E01     MOVLW 0x1
41EA  6FE9     MOVWF M_fan_is_220V, BANKED
84:            	#else		
85:            		if(time_M_Fan.time_detect_zero_cross++ >= M_fan_time_accum_zero_cross)
86:            		{
87:            			time_M_Fan.time_detect_zero_cross = 0;
88:            			M_fan_is_220V = (Intr_get_cnt_zero_crossing() >= THRESHOLD_ZERO_CROSS);
89:            			Intr_set_cnt_zero_crossing(0);
90:            		}	
91:            	#endif
92:            	return M_fan_is_220V;
41EC  0100     MOVLB 0x0
41EE  51E9     MOVF M_fan_is_220V, W, BANKED
41F0  D000     BRA 0x41F2
93:            }
41F2  0012     RETURN 0
94:            
95:            void M_fan_clear_timeouts(void)
96:            {
97:            	time_M_Fan.time_before_triac_is_on = step_force_fan = timer_force_fan = 0;
41F4  0E00     MOVLW 0x0
41F6  0100     MOVLB 0x0
41F8  6FEF     MOVWF timer_force_fan, BANKED
41FA  6BF0     CLRF 0xF0, BANKED
41FC  0100     MOVLB 0x0
41FE  6FEE     MOVWF step_force_fan, BANKED
4200  0100     MOVLB 0x0
4202  6FF3     MOVWF 0xF3, BANKED
4204  6BF4     CLRF 0xF4, BANKED
98:            }
4206  0012     RETURN 0
99:            
100:           void M_fan_run(void)
101:           {
102:           	
103:            	#define LEVEL_FORCE_FAN 	4U
104:           	#define TIMEOUT_FORCE_FAN	3500U
105:           	
106:           	if(M_Ind_Get_state() == STATE_IND_INIT)
4208  ECA3     CALL 0x2B46, 0
420A  F015     NOP
420C  0900     IORLW 0x0
420E  E101     BNZ 0x4212
107:           		return;
4210  D044     BRA 0x429A
108:           	
109:           	M_fan_check_220V(); //проверка наличия 220В
4212  DFE9     RCALL M_fan_check_220V
110:           	
111:           	if(M_Mngm_Get_state() == STATE_PAUSE)	
4214  ECA7     CALL 0x154E, 0
4216  F00A     NOP
4218  0803     SUBLW 0x3
421A  E102     BNZ 0x4220
112:           	{
113:           		FAN_PIN = OFF;	
421C  948E     BCF LATF, 2, ACCESS
114:           	}
115:           	else
421E  D03D     BRA 0x429A
116:           	{
117:           		switch(M_fan_state)
4220  0100     MOVLB 0x0
4222  51EB     MOVF M_fan_state, W, BANKED
4224  0A03     XORLW 0x3
4226  E01D     BZ 0x4262
4228  0A01     XORLW 0x1
422A  E013     BZ 0x4252
422C  0A03     XORLW 0x3
422E  E001     BZ 0x4232
4230  D034     BRA 0x429A
118:           		{
119:           			case M_FAN_WAITING:
120:           				M_fan_previous_state = M_fan_state;
4232  C0EB     MOVFF M_fan_state, M_fan_previous_state
4234  F0EC     NOP
121:           				/* отладка (в рабочей версии убрать)*/ //ctrl_fan = TRUE;  
122:           				if(!M_fan_is_220V) 
4236  0100     MOVLB 0x0
4238  51E9     MOVF M_fan_is_220V, W, BANKED
423A  E104     BNZ 0x4244
123:           				{
124:           					M_fan_state = M_FAN_FAILURE; 	
423C  0100     MOVLB 0x0
423E  0E02     MOVLW 0x2
4240  6FEB     MOVWF M_fan_state, BANKED
125:           				}
126:           				else
4242  D006     BRA 0x4250
127:           				{
128:           					if( ctrl_fan ) 
4244  0100     MOVLB 0x0
4246  51EA     MOVF ctrl_fan, W, BANKED
4248  E003     BZ 0x4250
129:           						M_fan_state = M_FAN_WORK_OR_OFF;
424A  0100     MOVLB 0x0
424C  0E03     MOVLW 0x3
424E  6FEB     MOVWF M_fan_state, BANKED
130:           				}
131:           			break;
4250  D024     BRA 0x429A
132:           			case M_FAN_FAILURE:
133:           				if(M_fan_is_220V) 		//условие выхода из состояния аварии
4252  0100     MOVLB 0x0
4254  51E9     MOVF M_fan_is_220V, W, BANKED
4256  E003     BZ 0x425E
134:           				{		
135:           					M_fan_state = M_fan_previous_state;
4258  C0EC     MOVFF M_fan_previous_state, M_fan_state
425A  F0EB     NOP
136:           				}
137:           				else
425C  D001     BRA 0x4260
138:           				{
139:           					FAN_PIN = OFF;
425E  948E     BCF LATF, 2, ACCESS
140:           				}
141:           			break;
4260  D01C     BRA 0x429A
142:           			case M_FAN_WORK_OR_OFF:
143:           				M_fan_previous_state = M_fan_state;
4262  C0EB     MOVFF M_fan_state, M_fan_previous_state
4264  F0EC     NOP
144:           				if(!M_fan_is_220V) 
4266  0100     MOVLB 0x0
4268  51E9     MOVF M_fan_is_220V, W, BANKED
426A  E109     BNZ 0x427E
145:           				{
146:           					M_fan_state = M_FAN_FAILURE; 	
426C  0100     MOVLB 0x0
426E  0E02     MOVLW 0x2
4270  6FEB     MOVWF M_fan_state, BANKED
147:           					Intr_set_is_zero_cross (FALSE); 
4272  6AE6     CLRF POSTINC1, ACCESS
4274  EC3D     CALL 0x447A, 0
4276  F022     NOP
4278  52E5     MOVF POSTDEC1, F, ACCESS
148:           					M_fan_clear_timeouts();
427A  DFBC     RCALL M_fan_clear_timeouts
149:           				}
150:           				else
427C  D00D     BRA 0x4298
151:           				{
152:           					if( !ctrl_fan )
427E  0100     MOVLB 0x0
4280  51EA     MOVF ctrl_fan, W, BANKED
4282  E106     BNZ 0x4290
153:           					{	
154:           						M_fan_state = M_FAN_WAITING;
4284  0100     MOVLB 0x0
4286  0E01     MOVLW 0x1
4288  6FEB     MOVWF M_fan_state, BANKED
155:           						FAN_PIN = OFF;	
428A  948E     BCF LATF, 2, ACCESS
156:           						M_fan_clear_timeouts();
428C  DFB3     RCALL M_fan_clear_timeouts
157:           					}
158:           					else
428E  D004     BRA 0x4298
159:           					{
160:           						//0 - форсированный старт (на 5 секунд включить вентилятор на 3-ем уровне), 1 - работа по передаваемому level_fan
161:           						/*
162:           						switch (step_force_fan) 
163:           						{
164:           							case 0:
165:           								if(timer_force_fan ++ >= TIMEOUT_FORCE_FAN)
166:           								{
167:           									timer_force_fan = 0;
168:           									step_force_fan++;		
169:           								}
170:           								else
171:           								{
172:           									M_Fan_work_fan(LEVEL_FORCE_FAN);
173:           								}
174:           							break;
175:           							case 1:
176:           								M_Fan_work_fan(level_fan);
177:           							break;
178:           						}
179:           					    */
180:           					    M_Fan_work_fan(level_fan);
4290  C0ED     MOVFF level_fan, POSTINC1
4292  FFE6     NOP
4294  D803     RCALL M_Fan_work_fan
4296  52E5     MOVF POSTDEC1, F, ACCESS
181:           					}
182:           				}
183:           			break;
4298  D000     BRA 0x429A
184:           		}
185:           	}
186:           }
429A  0012     RETURN 0
187:           
188:           /* Функция, в которой устанавливается время работы симистора в зависимости от уровня, заданного в меню */
189:           void M_Fan_work_fan ( uint8_t level )
429C  CFD9     MOVFF FSR2, POSTINC1
429E  FFE6     NOP
42A0  CFE1     MOVFF FSR1, FSR2
42A2  FFD9     NOP
190:           {
191:           	static uint8_t counter = 0;
192:           	static BOOL cnt_half_period = FIRST_HALF_SINUS_PERIOD;
193:           	
194:           		
195:           	if( level == FAN_MAX_LEVEL_ROTATION_SPEED )  //при максимальном уровне оборотов вентилятор всегда включен
42A4  0EFE     MOVLW 0xFE
42A6  50DB     MOVF PLUSW2, W, ACCESS
42A8  0808     SUBLW 0x8
42AA  E102     BNZ 0x42B0
196:           	{
197:           		FAN_PIN = ON;		
42AC  848E     BSF LATF, 2, ACCESS
198:           	}
199:           	else if (level == 1U)
42AE  D03C     BRA 0x4328
42B0  0EFE     MOVLW 0xFE
42B2  04DB     DECF PLUSW2, W, ACCESS
42B4  E102     BNZ 0x42BA
200:           	{	
201:           		FAN_PIN = OFF;
42B6  948E     BCF LATF, 2, ACCESS
202:           	}
203:           	else
42B8  D037     BRA 0x4328
204:           	{
205:           		if (Intr_get_is_zero_cross())		//если был переход через нуль сетевого напряжения
42BA  EC48     CALL 0x4490, 0
42BC  F022     NOP
42BE  0900     IORLW 0x0
42C0  E031     BZ 0x4324
206:           		{
207:           		
208:           				switch (counter)  //реализация фазового регулирования оборотов вентилятора
42C2  0100     MOVLB 0x0
42C4  51F5     MOVF 0xF5, W, BANKED
42C6  0A01     XORLW 0x1
42C8  E024     BZ 0x4312
42CA  0A01     XORLW 0x1
42CC  E001     BZ 0x42D0
42CE  D029     BRA 0x4322
209:           				{
210:           					case 0:  	//отсчёт времени паузы, затем включение симистора
211:           						if(time_M_Fan.time_before_triac_is_on++ < (HALF_SINUS_PERIOD_MS - level - TIMEOUT_TASK_FAN - 1))
42D0  0100     MOVLB 0x0
42D2  C0F3     MOVFF 0xF3, __tmp_0
42D4  F032     NOP
42D6  C0F4     MOVFF 0xF4, 0x33
42D8  F033     NOP
42DA  2BF3     INCF 0xF3, F, BANKED
42DC  0E00     MOVLW 0x0
42DE  23F4     ADDWFC 0xF4, F, BANKED
42E0  0EFE     MOVLW 0xFE
42E2  CFDB     MOVFF PLUSW2, POSTINC1
42E4  FFE6     NOP
42E6  0E0A     MOVLW 0xA
42E8  52E5     MOVF POSTDEC1, F, ACCESS
42EA  80D8     BSF STATUS, 0, ACCESS
42EC  54E7     SUBFWB INDF1, W, ACCESS
42EE  0FFF     ADDLW 0xFF
42F0  0FFF     ADDLW 0xFF
42F2  6E34     MOVWF 0x34, ACCESS
42F4  6A35     CLRF 0x35, ACCESS
42F6  5034     MOVF 0x34, W, ACCESS
42F8  5C32     SUBWF __tmp_0, W, ACCESS
42FA  5035     MOVF 0x35, W, ACCESS
42FC  5833     SUBWFB 0x33, W, ACCESS
42FE  E202     BC 0x4304
212:           							break;
4300  D010     BRA 0x4322
213:           						else
4302  D006     BRA 0x4310
214:           						{
215:           							time_M_Fan.time_before_triac_is_on = 0;
4304  0100     MOVLB 0x0
4306  6BF3     CLRF 0xF3, BANKED
4308  6BF4     CLRF 0xF4, BANKED
216:           							FAN_PIN = ON;		
430A  848E     BSF LATF, 2, ACCESS
217:           							counter++;	
430C  0100     MOVLB 0x0
430E  2BF5     INCF 0xF5, F, BANKED
218:           						}
219:           						break;
4310  D008     BRA 0x4322
220:           					case 1:  	//выключение симистора и отсчёт времени до конца полупериода
221:           						FAN_PIN = OFF;
4312  948E     BCF LATF, 2, ACCESS
222:           						counter = 0;
4314  0100     MOVLB 0x0
4316  6BF5     CLRF 0xF5, BANKED
223:           						Intr_set_is_zero_cross (FALSE); 	 //в конце полупериода синуса (10мс) сбросить флаг синхроимпульса
4318  6AE6     CLRF POSTINC1, ACCESS
431A  EC3D     CALL 0x447A, 0
431C  F022     NOP
431E  52E5     MOVF POSTDEC1, F, ACCESS
224:           						break;
4320  D000     BRA 0x4322
225:           				}
226:           			}
227:           		
228:           		else
4322  D002     BRA 0x4328
229:           		{
230:           			cnt_half_period = FIRST_HALF_SINUS_PERIOD;	
4324  0100     MOVLB 0x0
4326  6BF6     CLRF 0xF6, BANKED
231:           		}
232:           	}
233:           }
4328  52E5     MOVF POSTDEC1, F, ACCESS
432A  CFE7     MOVFF INDF1, FSR2
432C  FFD9     NOP
432E  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Module_analog_inputs/module_analog_inputs.c  -----
1:             #include <p18cxxx.h>
2:             #include <adc.h>
3:             #include "module_analog_inputs.h"
4:             
5:             
6:             /* 
7:             Таблица температуры для терморезистора 10 кОм с характеристикой В3950
8:             Диапазон от 0 до 99 градусов с шагом 1 градус
9:             Таблица в дискретах 10-битного АЦП
10:            */
11:            const rom uint16_t M_AI_Table_thermoresistor[] =
12:            {
13:            789, 780, 770, 760, 749, 739, 728, 718, 707, 696, 685, 673, 662, 651, 639, 628, 616, 604, 593, 581,
14:            570, 558, 546, 535, 523, 512, 501, 489, 478, 467, 456, 445, 435, 424, 414, 404, 394, 384, 374, 364,
15:            355, 346, 336, 328, 319, 310, 302, 294, 286, 278, 270, 263, 256, 249, 242, 235, 228, 222, 216, 210,
16:            204, 198, 193, 187, 182, 177, 172, 167, 162, 158, 153, 149, 145, 141, 137, 133, 129, 126, 122, 119,
17:            115, 112, 109, 106, 103, 100, 98, 95, 92, 90, 87, 85, 83, 81, 78, 76, 74, 72, 70, 69
18:            };
19:            
20:            
21:            /* 
22:            Таблица температуры для датчика температуры PT100
23:            Диапазон от 0 до 850 градусов с шагом 10 градусов
24:            Таблица в дискретах 10-битного АЦП
25:            Конечная температура будет в виде числа от 0 до 85
26:            */
27:            const rom uint16_t M_AI_Table_PT100[] = 
28:            {
29:            59, 71, 83, 95, 107, 119, 131, 143, 155, 167, 178, 190, 202, 213, 225, 236, 247, 259, 270, 281,
30:            292, 303, 314, 325, 336, 347, 358, 369, 380, 390, 401, 412, 422, 433, 443, 453, 464, 474, 484,
31:            495, 505, 515, 525, 535, 545, 555, 565, 574, 584, 594, 604, 613, 623, 632, 642, 651, 661, 670,
32:            679, 689, 698, 707, 716, 725, 734, 743, 752, 761, 770, 779, 788, 796, 805, 814, 822, 831, 839, 
33:            848, 856, 865, 873, 881, 890, 898, 906, 914
34:            };
35:            
36:            //#define ALL_ANALOG_CHANNELS_IN_USE
37:            
38:            // Количество значений в таблице температуры терморезистора от 0 до 100 градусов в дискретах АЦП (10 бит)
39:            #define SIZE_TABLE_TERMO_RES  	sizeof(M_AI_Table_thermoresistor) / sizeof(M_AI_Table_thermoresistor[0])  
40:            
41:            // Количество значений в таблице температуры PT100 от 0 до 850 градусов в дискретах АЦП (10 бит)
42:            #define SIZE_TABLE_PT100	  	sizeof(M_AI_Table_PT100) / sizeof(M_AI_Table_PT100[0])     
43:            
44:            #ifdef ALL_ANALOG_CHANNELS_IN_USE
45:                #define QUANTITY_ANALOG_CHANNELS    6U 	   		//Общее количество каналов АЦП
46:                #define QUANTITY_TEMPER_CHANNELS    5U          //Количество каналов АЦП измерения температуры  
47:            #else
48:                #define QUANTITY_ANALOG_CHANNELS    3U 	   		//Общее количество каналов АЦП
49:                #define QUANTITY_TEMPER_CHANNELS    2U          //Количество каналов АЦП измерения температуры
50:            #endif
51:            
52:            #define QUANTITY_DC_CURRENT_CHANNELS    1U          //Количество каналов АЦП измерения постоянного тока         
53:            #define QUANTITY_OF_SHR                 6 			//Для усреднения результата (количество сдвигов вправо)
54:            #define QUANTITY_ELEMENTS_OF_SUMMARY  	1U << QUANTITY_OF_SHR  //Величина буфера суммы			 
55:            #define QUANTITY_TABLES_TEMPERATURE		2
56:            #define ADC_CH0_TRIS                    TRISAbits.TRISA0
57:            #define ADC_CH1_TRIS                    TRISAbits.TRISA1
58:            #define ADC_CH2_TRIS                    TRISAbits.TRISA2
59:            #define ADC_CH3_TRIS                    TRISAbits.TRISA3
60:            #define ADC_CH4_TRIS                    TRISAbits.TRISA5
61:            #define ADC_CH012_TRIS                  TRISHbits.TRISH4
62:            #define ADC_MASK_CHANNELS               0b1110111111100000  //Маска аналоговыз каналов (1 - цифровой вход/выход, 0 - аналоговый вход)
63:            
64:            
65:            
66:            const rom uint8_t M_AI_Type_Table_Sorted[QUANTITY_TABLES_TEMPERATURE] = {TABLE_SORTED_UP, TABLE_SORTED_DOWN};
67:            
68:            const rom uint8_t M_AI_Offset_in_table[QUANTITY_TABLES_TEMPERATURE][QUANTITY_TABLES_TEMPERATURE] = 
69:            {
70:            {0, SIZE_TABLE_PT100 - 1},
71:            {SIZE_TABLE_TERMO_RES - 1, 0}
72:            };
73:            
74:            const rom uint16_t* M_AI_ptrTable [QUANTITY_TABLES_TEMPERATURE] = {M_AI_Table_PT100, M_AI_Table_thermoresistor};
75:            #ifdef ALL_ANALOG_CHANNELS_IN_USE
76:                const rom uint8_t M_AI_Mask_ADC_channels [QUANTITY_ANALOG_CHANNELS] = 
77:                                { ADC_CH3, ADC_CH1, ADC_CH12, ADC_CH0, ADC_CH4, ADC_CH2 }; 
78:            #else
79:                const rom uint8_t M_AI_Mask_ADC_channels [QUANTITY_ANALOG_CHANNELS] = 
80:                                { ADC_CH3, ADC_CH1, ADC_CH12 }; 
81:            #endif
82:            const rom uint8_t M_AI_Size_Table_temperature [QUANTITY_TABLES_TEMPERATURE] = {SIZE_TABLE_PT100, SIZE_TABLE_TERMO_RES};
83:            
84:            //Объявление структур температур и постоянного тока
85:            ADC_Data  M_AI_ADC_Data[QUANTITY_ANALOG_CHANNELS] = {0};
86:            
87:            
88:            /*Функция возвращает адрес массива структур канала АЦП */
89:            ADC_Data* M_AI_Get_ADC_Data(uint8_t index)
3478  CFD9     MOVFF FSR2, POSTINC1
347A  FFE6     NOP
347C  CFE1     MOVFF FSR1, FSR2
347E  FFD9     NOP
90:            {
91:            	return (ADC_Data*)&M_AI_ADC_Data[index];
3480  0EFE     MOVLW 0xFE
3482  50DB     MOVF PLUSW2, W, ACCESS
3484  0D06     MULLW 0x6
3486  CFF3     MOVFF PROD, __tmp_0
3488  F032     NOP
348A  CFF4     MOVFF PRODH, 0x33
348C  F033     NOP
348E  0EB8     MOVLW 0xB8
3490  2632     ADDWF __tmp_0, F, ACCESS
3492  0E00     MOVLW 0x0
3494  2233     ADDWFC 0x33, F, ACCESS
3496  C032     MOVFF __tmp_0, PROD
3498  FFF3     NOP
349A  C033     MOVFF 0x33, PRODH
349C  FFF4     NOP
349E  D000     BRA 0x34A0
92:            }  
34A0  52E5     MOVF POSTDEC1, F, ACCESS
34A2  CFE7     MOVFF INDF1, FSR2
34A4  FFD9     NOP
34A6  0012     RETURN 0
93:            
94:            //Инициализация модуля АЦП
95:            void M_AI_ctor( void )
96:            {
97:                OpenADC(ADC_FOSC_64 & ADC_RIGHT_JUST & ADC_12_TAD,  
34B4  0EEB     MOVLW 0xEB
34B6  6EE6     MOVWF POSTINC1, ACCESS
98:                        ADC_CH0 & ADC_CH1 & ADC_CH2 & ADC_CH3 &  
99:                        ADC_CH4 & ADC_CH12 & ADC_INT_OFF & ADC_REF_VDD_VSS, ADC_MASK_CHANNELS);
34A8  0EE0     MOVLW 0xE0
34AA  6EE6     MOVWF POSTINC1, ACCESS
34AC  0EEF     MOVLW 0xEF
34AE  6EE6     MOVWF POSTINC1, ACCESS
34B0  0E04     MOVLW 0x4
34B2  6EE6     MOVWF POSTINC1, ACCESS
34B8  EC78     CALL 0x4AF0, 0
34BA  F025     NOP
34BC  52E5     MOVF POSTDEC1, F, ACCESS
34BE  52E5     MOVF POSTDEC1, F, ACCESS
34C0  52E5     MOVF POSTDEC1, F, ACCESS
34C2  52E5     MOVF POSTDEC1, F, ACCESS
100:               ADC_CH0_TRIS   = IN;   
34C4  8092     BSF TRISA, 0, ACCESS
101:               ADC_CH1_TRIS   = IN;  
34C6  8292     BSF TRISA, 1, ACCESS
102:               ADC_CH2_TRIS   = IN;  
34C8  8492     BSF TRISA, 2, ACCESS
103:               ADC_CH3_TRIS   = IN;  
34CA  8692     BSF TRISA, 3, ACCESS
104:               ADC_CH4_TRIS   = IN;  
34CC  8A92     BSF TRISA, 5, ACCESS
105:               ADC_CH012_TRIS = IN;      
34CE  8899     BSF TRISH, 4, ACCESS
106:           }
34D0  0012     RETURN 0
107:           
108:           
109:           
110:           //Поиск в таблице значения температуры по данным работы АЦП (методом двоичного поиска)
111:           //в зависимости от типа таблицы (отсортирована по возрастанию или по убыванию в зависимости от  аргумента uint8_t sort_direction)
112:           uint8_t M_AI_Search(uint16_t value, const rom uint16_t* table, const uint8_t length, uint8_t sort_direction)
34D2  CFD9     MOVFF FSR2, POSTINC1
34D4  FFE6     NOP
34D6  CFE1     MOVFF FSR1, FSR2
34D8  FFD9     NOP
34DA  0E03     MOVLW 0x3
34DC  26E1     ADDWF FSR1, F, ACCESS
113:           {
114:           	uint8_t U, L, M;
115:           	
116:           	U = length;
34DE  0EFA     MOVLW 0xFA
34E0  50DB     MOVF PLUSW2, W, ACCESS
34E2  6EDF     MOVWF INDF2, ACCESS
117:           	L = 0;
34E4  0E01     MOVLW 0x1
34E6  6ADB     CLRF PLUSW2, ACCESS
118:           
119:           	while(1)
3642  D752     BRA 0x34E8
120:           	{
121:           		 M = (L + U) / 2;
34E8  0E01     MOVLW 0x1
34EA  50DB     MOVF PLUSW2, W, ACCESS
34EC  24DF     ADDWF INDF2, W, ACCESS
34EE  0BFE     ANDLW 0xFE
34F0  42E8     RRNCF WREG, F, ACCESS
34F2  6EE7     MOVWF INDF1, ACCESS
34F4  0E02     MOVLW 0x2
34F6  CFE7     MOVFF INDF1, PLUSW2
34F8  FFDB     NOP
122:           		 if(sort_direction) //условие истинно для таблицы, отсортированной по убыванию (терморезистор NTC)
34FA  0EF9     MOVLW 0xF9
34FC  50DB     MOVF PLUSW2, W, ACCESS
34FE  E04D     BZ 0x359A
123:           		 {
124:           		 	if (value > table[M]) 
3500  0EFD     MOVLW 0xFD
3502  CFDB     MOVFF PLUSW2, __tmp_0
3504  F032     NOP
3506  0EFE     MOVLW 0xFE
3508  CFDB     MOVFF PLUSW2, 0x33
350A  F033     NOP
350C  0E02     MOVLW 0x2
350E  6A37     CLRF 0x37, ACCESS
3510  34DB     RLCF PLUSW2, W, ACCESS
3512  0BFE     ANDLW 0xFE
3514  3637     RLCF 0x37, F, ACCESS
3516  6E36     MOVWF 0x36, ACCESS
3518  0EFB     MOVLW 0xFB
351A  50DB     MOVF PLUSW2, W, ACCESS
351C  2436     ADDWF 0x36, W, ACCESS
351E  6EF6     MOVWF TBLPTR, ACCESS
3520  0EFC     MOVLW 0xFC
3522  50DB     MOVF PLUSW2, W, ACCESS
3524  2037     ADDWFC 0x37, W, ACCESS
3526  6EF7     MOVWF TBLPTRH, ACCESS
3528  0009     TBLRD*+
352A  CFF5     MOVFF TABLAT, 0x34
352C  F034     NOP
352E  0008     TBLRD*
3530  CFF5     MOVFF TABLAT, 0x35
3532  F035     NOP
3534  5032     MOVF __tmp_0, W, ACCESS
3536  5C34     SUBWF 0x34, W, ACCESS
3538  5033     MOVF 0x33, W, ACCESS
353A  5835     SUBWFB 0x35, W, ACCESS
353C  E204     BC 0x3546
125:           		 	U = M; /*- 1*/
353E  0E02     MOVLW 0x2
3540  50DB     MOVF PLUSW2, W, ACCESS
3542  6EDF     MOVWF INDF2, ACCESS
126:           		 else
3544  D029     BRA 0x3598
127:           		 	if (value < table[M]) 
3546  0EFD     MOVLW 0xFD
3548  CFDB     MOVFF PLUSW2, __tmp_0
354A  F032     NOP
354C  0EFE     MOVLW 0xFE
354E  CFDB     MOVFF PLUSW2, 0x33
3550  F033     NOP
3552  0E02     MOVLW 0x2
3554  6A37     CLRF 0x37, ACCESS
3556  34DB     RLCF PLUSW2, W, ACCESS
3558  0BFE     ANDLW 0xFE
355A  3637     RLCF 0x37, F, ACCESS
355C  6E36     MOVWF 0x36, ACCESS
355E  0EFB     MOVLW 0xFB
3560  50DB     MOVF PLUSW2, W, ACCESS
3562  2436     ADDWF 0x36, W, ACCESS
3564  6EF6     MOVWF TBLPTR, ACCESS
3566  0EFC     MOVLW 0xFC
3568  50DB     MOVF PLUSW2, W, ACCESS
356A  2037     ADDWFC 0x37, W, ACCESS
356C  6EF7     MOVWF TBLPTRH, ACCESS
356E  0009     TBLRD*+
3570  CFF5     MOVFF TABLAT, 0x34
3572  F034     NOP
3574  0008     TBLRD*
3576  CFF5     MOVFF TABLAT, 0x35
3578  F035     NOP
357A  5034     MOVF 0x34, W, ACCESS
357C  5C32     SUBWF __tmp_0, W, ACCESS
357E  5035     MOVF 0x35, W, ACCESS
3580  5833     SUBWFB 0x33, W, ACCESS
3582  E207     BC 0x3592
128:           		 		L = M; /*+ 1*/
3584  0E02     MOVLW 0x2
3586  50DB     MOVF PLUSW2, W, ACCESS
3588  6EE7     MOVWF INDF1, ACCESS
358A  0E01     MOVLW 0x1
358C  CFE7     MOVFF INDF1, PLUSW2
358E  FFDB     NOP
129:           		 	else 
3590  D003     BRA 0x3598
130:           		 		return M;
3592  0E02     MOVLW 0x2
3594  50DB     MOVF PLUSW2, W, ACCESS
3596  D056     BRA 0x3644
131:           		 } 
132:           		else  //эта ветвь выполняется для таблицы, отсортированной по возрастанию (датчик PT100)
3598  D04C     BRA 0x3632
133:           		{
134:           			if (value < table[M]) 
359A  0EFD     MOVLW 0xFD
359C  CFDB     MOVFF PLUSW2, __tmp_0
359E  F032     NOP
35A0  0EFE     MOVLW 0xFE
35A2  CFDB     MOVFF PLUSW2, 0x33
35A4  F033     NOP
35A6  0E02     MOVLW 0x2
35A8  6A37     CLRF 0x37, ACCESS
35AA  34DB     RLCF PLUSW2, W, ACCESS
35AC  0BFE     ANDLW 0xFE
35AE  3637     RLCF 0x37, F, ACCESS
35B0  6E36     MOVWF 0x36, ACCESS
35B2  0EFB     MOVLW 0xFB
35B4  50DB     MOVF PLUSW2, W, ACCESS
35B6  2436     ADDWF 0x36, W, ACCESS
35B8  6EF6     MOVWF TBLPTR, ACCESS
35BA  0EFC     MOVLW 0xFC
35BC  50DB     MOVF PLUSW2, W, ACCESS
35BE  2037     ADDWFC 0x37, W, ACCESS
35C0  6EF7     MOVWF TBLPTRH, ACCESS
35C2  0009     TBLRD*+
35C4  CFF5     MOVFF TABLAT, 0x34
35C6  F034     NOP
35C8  0008     TBLRD*
35CA  CFF5     MOVFF TABLAT, 0x35
35CC  F035     NOP
35CE  5034     MOVF 0x34, W, ACCESS
35D0  5C32     SUBWF __tmp_0, W, ACCESS
35D2  5035     MOVF 0x35, W, ACCESS
35D4  5833     SUBWFB 0x33, W, ACCESS
35D6  E204     BC 0x35E0
135:           		 	U = M; /*- 1*/
35D8  0E02     MOVLW 0x2
35DA  50DB     MOVF PLUSW2, W, ACCESS
35DC  6EDF     MOVWF INDF2, ACCESS
136:           		 else
35DE  D029     BRA 0x3632
137:           		 	if (value > table[M]) 
35E0  0EFD     MOVLW 0xFD
35E2  CFDB     MOVFF PLUSW2, __tmp_0
35E4  F032     NOP
35E6  0EFE     MOVLW 0xFE
35E8  CFDB     MOVFF PLUSW2, 0x33
35EA  F033     NOP
35EC  0E02     MOVLW 0x2
35EE  6A37     CLRF 0x37, ACCESS
35F0  34DB     RLCF PLUSW2, W, ACCESS
35F2  0BFE     ANDLW 0xFE
35F4  3637     RLCF 0x37, F, ACCESS
35F6  6E36     MOVWF 0x36, ACCESS
35F8  0EFB     MOVLW 0xFB
35FA  50DB     MOVF PLUSW2, W, ACCESS
35FC  2436     ADDWF 0x36, W, ACCESS
35FE  6EF6     MOVWF TBLPTR, ACCESS
3600  0EFC     MOVLW 0xFC
3602  50DB     MOVF PLUSW2, W, ACCESS
3604  2037     ADDWFC 0x37, W, ACCESS
3606  6EF7     MOVWF TBLPTRH, ACCESS
3608  0009     TBLRD*+
360A  CFF5     MOVFF TABLAT, 0x34
360C  F034     NOP
360E  0008     TBLRD*
3610  CFF5     MOVFF TABLAT, 0x35
3612  F035     NOP
3614  5032     MOVF __tmp_0, W, ACCESS
3616  5C34     SUBWF 0x34, W, ACCESS
3618  5033     MOVF 0x33, W, ACCESS
361A  5835     SUBWFB 0x35, W, ACCESS
361C  E207     BC 0x362C
138:           		 		L = M; /*+ 1*/
361E  0E02     MOVLW 0x2
3620  50DB     MOVF PLUSW2, W, ACCESS
3622  6EE7     MOVWF INDF1, ACCESS
3624  0E01     MOVLW 0x1
3626  CFE7     MOVFF INDF1, PLUSW2
3628  FFDB     NOP
139:           		 	else 
362A  D003     BRA 0x3632
140:           		 		return M;
362C  0E02     MOVLW 0x2
362E  50DB     MOVF PLUSW2, W, ACCESS
3630  D009     BRA 0x3644
141:           		 }
142:           		if ((U - L) == 1U) 
3632  0E01     MOVLW 0x1
3634  50DB     MOVF PLUSW2, W, ACCESS
3636  5CDF     SUBWF INDF2, W, ACCESS
3638  0801     SUBLW 0x1
363A  E103     BNZ 0x3642
143:           		 	return L;
363C  0E01     MOVLW 0x1
363E  50DB     MOVF PLUSW2, W, ACCESS
3640  D001     BRA 0x3644
144:           	}
145:           } 
3644  6E32     MOVWF __tmp_0, ACCESS
3646  0E03     MOVLW 0x3
3648  5CE1     SUBWF FSR1, W, ACCESS
364A  E202     BC 0x3650
364C  6AE1     CLRF FSR1, ACCESS
364E  52E5     MOVF POSTDEC1, F, ACCESS
3650  6EE1     MOVWF FSR1, ACCESS
3652  5032     MOVF __tmp_0, W, ACCESS
3654  52E5     MOVF POSTDEC1, F, ACCESS
3656  CFE7     MOVFF INDF1, FSR2
3658  FFD9     NOP
365A  0012     RETURN 0
146:           
147:           
148:           /*
149:           Метод Run модуля обработки АЦП
150:           */
151:           void M_AI_Run (void)
152:           {
153:           	static uint8_t index_channel = 0;
154:           	
155:           	M_AI_Processing_ADC (index_channel); //Преобразование АЦП, усреднение результатов
365C  C0CA     MOVFF 0xCA, POSTINC1
365E  FFE6     NOP
3660  D817     RCALL M_AI_Processing_ADC
3662  52E5     MOVF POSTDEC1, F, ACCESS
156:           	if( ++index_channel == QUANTITY_ANALOG_CHANNELS ) 
3664  0100     MOVLB 0x0
3666  2BCA     INCF 0xCA, F, BANKED
3668  0E03     MOVLW 0x3
366A  0100     MOVLB 0x0
366C  5DCA     SUBWF 0xCA, W, BANKED
366E  E102     BNZ 0x3674
157:           		index_channel = 0; //Когда все каналы пройдены, начинать снова с самого первого
3670  0100     MOVLB 0x0
3672  6BCA     CLRF 0xCA, BANKED
158:           	
159:           	SetChanADC(M_AI_Mask_ADC_channels[index_channel]); //Выбор следующего канала измерения
3674  0100     MOVLB 0x0
3676  51CA     MOVF 0xCA, W, BANKED
3678  6AF7     CLRF TBLPTRH, ACCESS
367A  0F30     ADDLW 0x30
367C  6EF6     MOVWF TBLPTR, ACCESS
367E  0E46     MOVLW 0x46
3680  22F7     ADDWFC TBLPTRH, F, ACCESS
3682  0008     TBLRD*
3684  50F5     MOVF TABLAT, W, ACCESS
3686  6EE6     MOVWF POSTINC1, ACCESS
3688  EC73     CALL 0x4CE6, 0
368A  F026     NOP
368C  52E5     MOVF POSTDEC1, F, ACCESS
160:           }
368E  0012     RETURN 0
161:           
162:           /* 
163:           Измерение АЦП и обработка результатов измерений
164:           */
165:           void M_AI_Processing_ADC (uint8_t index)
3690  CFD9     MOVFF FSR2, POSTINC1
3692  FFE6     NOP
3694  CFE1     MOVFF FSR1, FSR2
3696  FFD9     NOP
166:           {
167:           	if(M_AI_ADC_Data[index].quantity++ < QUANTITY_ELEMENTS_OF_SUMMARY) //Измерение и суммирование в буфер
3698  0EFE     MOVLW 0xFE
369A  50DB     MOVF PLUSW2, W, ACCESS
369C  0D06     MULLW 0x6
369E  CFF3     MOVFF PROD, FSR0
36A0  FFE9     NOP
36A2  CFF4     MOVFF PRODH, FSR0H
36A4  FFEA     NOP
36A6  0EB8     MOVLW 0xB8
36A8  26E9     ADDWF FSR0, F, ACCESS
36AA  0E00     MOVLW 0x0
36AC  22EA     ADDWFC FSR0H, F, ACCESS
36AE  0E02     MOVLW 0x2
36B0  26E9     ADDWF FSR0, F, ACCESS
36B2  0E00     MOVLW 0x0
36B4  22EA     ADDWFC FSR0H, F, ACCESS
36B6  50EF     MOVF INDF0, W, ACCESS
36B8  2AEF     INCF INDF0, F, ACCESS
36BA  6E32     MOVWF __tmp_0, ACCESS
36BC  0E40     MOVLW 0x40
36BE  5C32     SUBWF __tmp_0, W, ACCESS
36C0  E21D     BC 0x36FC
168:           	{
169:           		ConvertADC( );
36C2  EC55     CALL 0x4EAA, 0
36C4  F027     NOP
170:           		while( BusyADC( ) );
36C6  EC4F     CALL 0x4E9E, 0
36C8  F027     NOP
36CA  0900     IORLW 0x0
36CC  E001     BZ 0x36D0
36CE  D7FB     BRA 0x36C6
171:                   M_AI_ADC_Data[index].sum_discr += ReadADC();	//накопление суммы отсчётов выбранного канала АЦП	
36D0  EC46     CALL 0x4E8C, 0
36D2  F027     NOP
36D4  CFF3     MOVFF PROD, __tmp_0
36D6  F032     NOP
36D8  CFF4     MOVFF PRODH, 0x33
36DA  F033     NOP
36DC  0EFE     MOVLW 0xFE
36DE  50DB     MOVF PLUSW2, W, ACCESS
36E0  0D06     MULLW 0x6
36E2  CFF3     MOVFF PROD, FSR0
36E4  FFE9     NOP
36E6  CFF4     MOVFF PRODH, FSR0H
36E8  FFEA     NOP
36EA  0EB8     MOVLW 0xB8
36EC  26E9     ADDWF FSR0, F, ACCESS
36EE  0E00     MOVLW 0x0
36F0  22EA     ADDWFC FSR0H, F, ACCESS
36F2  5032     MOVF __tmp_0, W, ACCESS
36F4  26EE     ADDWF POSTINC0, F, ACCESS
36F6  5033     MOVF 0x33, W, ACCESS
36F8  22ED     ADDWFC POSTDEC0, F, ACCESS
172:           		
173:           	}
174:           	else
36FA  D21B     BRA 0x3B32
175:           	{
176:           		M_AI_ADC_Data[index].data_value = M_AI_ADC_Data[index].sum_discr >> QUANTITY_OF_SHR; //усреднение результата
36FC  0EFE     MOVLW 0xFE
36FE  50DB     MOVF PLUSW2, W, ACCESS
3700  0D06     MULLW 0x6
3702  CFF3     MOVFF PROD, FSR0
3704  FFE9     NOP
3706  CFF4     MOVFF PRODH, FSR0H
3708  FFEA     NOP
370A  0EB8     MOVLW 0xB8
370C  26E9     ADDWF FSR0, F, ACCESS
370E  0E00     MOVLW 0x0
3710  22EA     ADDWFC FSR0H, F, ACCESS
3712  CFEE     MOVFF POSTINC0, __tmp_0
3714  F032     NOP
3716  CFEF     MOVFF INDF0, 0x33
3718  F033     NOP
371A  0E06     MOVLW 0x6
371C  90D8     BCF STATUS, 0, ACCESS
371E  3233     RRCF 0x33, F, ACCESS
3720  3232     RRCF __tmp_0, F, ACCESS
3722  04E8     DECF WREG, W, ACCESS
3724  E1FB     BNZ 0x371C
3726  0EFE     MOVLW 0xFE
3728  50DB     MOVF PLUSW2, W, ACCESS
372A  0D06     MULLW 0x6
372C  CFF3     MOVFF PROD, FSR0
372E  FFE9     NOP
3730  CFF4     MOVFF PRODH, FSR0H
3732  FFEA     NOP
3734  0EB8     MOVLW 0xB8
3736  26E9     ADDWF FSR0, F, ACCESS
3738  0E00     MOVLW 0x0
373A  22EA     ADDWFC FSR0H, F, ACCESS
373C  0E03     MOVLW 0x3
373E  26E9     ADDWF FSR0, F, ACCESS
3740  0E00     MOVLW 0x0
3742  22EA     ADDWFC FSR0H, F, ACCESS
3744  C032     MOVFF __tmp_0, POSTINC0
3746  FFEE     NOP
3748  C033     MOVFF 0x33, POSTDEC0
374A  FFED     NOP
177:           		M_AI_ADC_Data[index].sum_discr = 0;
374C  0EFE     MOVLW 0xFE
374E  50DB     MOVF PLUSW2, W, ACCESS
3750  0D06     MULLW 0x6
3752  CFF3     MOVFF PROD, FSR0
3754  FFE9     NOP
3756  CFF4     MOVFF PRODH, FSR0H
3758  FFEA     NOP
375A  0EB8     MOVLW 0xB8
375C  26E9     ADDWF FSR0, F, ACCESS
375E  0E00     MOVLW 0x0
3760  22EA     ADDWFC FSR0H, F, ACCESS
3762  6AEE     CLRF POSTINC0, ACCESS
3764  6AED     CLRF POSTDEC0, ACCESS
178:           		M_AI_ADC_Data[index].quantity = 0;
3766  0EFE     MOVLW 0xFE
3768  50DB     MOVF PLUSW2, W, ACCESS
376A  0D06     MULLW 0x6
376C  CFF3     MOVFF PROD, FSR0
376E  FFE9     NOP
3770  CFF4     MOVFF PRODH, FSR0H
3772  FFEA     NOP
3774  0EB8     MOVLW 0xB8
3776  26E9     ADDWF FSR0, F, ACCESS
3778  0E00     MOVLW 0x0
377A  22EA     ADDWFC FSR0H, F, ACCESS
377C  0E02     MOVLW 0x2
377E  26E9     ADDWF FSR0, F, ACCESS
3780  0E00     MOVLW 0x0
3782  22EA     ADDWFC FSR0H, F, ACCESS
3784  6AEF     CLRF INDF0, ACCESS
179:           		
180:                   switch(index)
3786  0EFE     MOVLW 0xFE
3788  50DB     MOVF PLUSW2, W, ACCESS
378A  0A02     XORLW 0x2
378C  E101     BNZ 0x3790
378E  D1D0     BRA 0x3B30
3790  0A02     XORLW 0x2
3792  E003     BZ 0x379A
3794  0A01     XORLW 0x1
3796  E001     BZ 0x379A
3798  D1CC     BRA 0x3B32
181:                   {    
182:                       case CHN_T_GAS: //Обработка температуры
183:                       case CHN_T_WATER:
184:                           if (M_AI_ADC_Data[index].data_value < SHORT_CIRCUIT_SENSOR_THRESHOLD) // проверка на КЗ датчика температуры
379A  0EFE     MOVLW 0xFE
379C  50DB     MOVF PLUSW2, W, ACCESS
379E  0D06     MULLW 0x6
37A0  CFF3     MOVFF PROD, FSR0
37A2  FFE9     NOP
37A4  CFF4     MOVFF PRODH, FSR0H
37A6  FFEA     NOP
37A8  0EB8     MOVLW 0xB8
37AA  26E9     ADDWF FSR0, F, ACCESS
37AC  0E00     MOVLW 0x0
37AE  22EA     ADDWFC FSR0H, F, ACCESS
37B0  0E03     MOVLW 0x3
37B2  26E9     ADDWF FSR0, F, ACCESS
37B4  0E00     MOVLW 0x0
37B6  22EA     ADDWFC FSR0H, F, ACCESS
37B8  CFEE     MOVFF POSTINC0, __tmp_0
37BA  F032     NOP
37BC  CFEF     MOVFF INDF0, 0x33
37BE  F033     NOP
37C0  0E0A     MOVLW 0xA
37C2  5C32     SUBWF __tmp_0, W, ACCESS
37C4  0E00     MOVLW 0x0
37C6  5833     SUBWFB 0x33, W, ACCESS
37C8  E213     BC 0x37F0
185:                           {
186:                               M_AI_ADC_Data[index].param = SHORT_CIRCUIT_SENSOR_VALUE; 
37CA  0EFE     MOVLW 0xFE
37CC  50DB     MOVF PLUSW2, W, ACCESS
37CE  0D06     MULLW 0x6
37D0  CFF3     MOVFF PROD, FSR0
37D2  FFE9     NOP
37D4  CFF4     MOVFF PRODH, FSR0H
37D6  FFEA     NOP
37D8  0EB8     MOVLW 0xB8
37DA  26E9     ADDWF FSR0, F, ACCESS
37DC  0E00     MOVLW 0x0
37DE  22EA     ADDWFC FSR0H, F, ACCESS
37E0  0E05     MOVLW 0x5
37E2  26E9     ADDWF FSR0, F, ACCESS
37E4  0E00     MOVLW 0x0
37E6  22EA     ADDWFC FSR0H, F, ACCESS
37E8  0EFB     MOVLW 0xFB
37EA  6EEF     MOVWF INDF0, ACCESS
187:                               return;
37EC  D1A2     BRA 0x3B32
188:                           }
189:                           else if (M_AI_ADC_Data[index].data_value > BREAK_SENSOR_THRESHOLD) // проверка на обрыв датчика температуры
37EE  D152     BRA 0x3A94
37F0  0EFE     MOVLW 0xFE
37F2  50DB     MOVF PLUSW2, W, ACCESS
37F4  0D06     MULLW 0x6
37F6  CFF3     MOVFF PROD, FSR0
37F8  FFE9     NOP
37FA  CFF4     MOVFF PRODH, FSR0H
37FC  FFEA     NOP
37FE  0EB8     MOVLW 0xB8
3800  26E9     ADDWF FSR0, F, ACCESS
3802  0E00     MOVLW 0x0
3804  22EA     ADDWFC FSR0H, F, ACCESS
3806  0E03     MOVLW 0x3
3808  26E9     ADDWF FSR0, F, ACCESS
380A  0E00     MOVLW 0x0
380C  22EA     ADDWFC FSR0H, F, ACCESS
380E  0ED4     MOVLW 0xD4
3810  80D8     BSF STATUS, 0, ACCESS
3812  54EE     SUBFWB POSTINC0, W, ACCESS
3814  0E03     MOVLW 0x3
3816  54ED     SUBFWB POSTDEC0, W, ACCESS
3818  E213     BC 0x3840
190:                           {
191:                                M_AI_ADC_Data[index].param = BREAK_SENSOR_VALUE;
381A  0EFE     MOVLW 0xFE
381C  50DB     MOVF PLUSW2, W, ACCESS
381E  0D06     MULLW 0x6
3820  CFF3     MOVFF PROD, FSR0
3822  FFE9     NOP
3824  CFF4     MOVFF PRODH, FSR0H
3826  FFEA     NOP
3828  0EB8     MOVLW 0xB8
382A  26E9     ADDWF FSR0, F, ACCESS
382C  0E00     MOVLW 0x0
382E  22EA     ADDWFC FSR0H, F, ACCESS
3830  0E05     MOVLW 0x5
3832  26E9     ADDWF FSR0, F, ACCESS
3834  0E00     MOVLW 0x0
3836  22EA     ADDWFC FSR0H, F, ACCESS
3838  0EFA     MOVLW 0xFA
383A  6EEF     MOVWF INDF0, ACCESS
192:                               #ifndef NO_SENSOR_GAS
193:                                   return;
383C  D17A     BRA 0x3B32
194:                               #else
195:                                   if(index == CHN_T_GAS)	
196:                                   {
197:                                       M_AI_ADC_Data[index].param = 2;  //типа фиктивные 20 градусов
198:                                       return;
199:                                   }	
200:                               #endif
201:                           }
202:                           else if (M_AI_ADC_Data[index].data_value >= SHORT_CIRCUIT_SENSOR_THRESHOLD && 
383E  D12A     BRA 0x3A94
3840  0EFE     MOVLW 0xFE
3842  50DB     MOVF PLUSW2, W, ACCESS
3844  0D06     MULLW 0x6
3846  CFF3     MOVFF PROD, FSR0
3848  FFE9     NOP
384A  CFF4     MOVFF PRODH, FSR0H
384C  FFEA     NOP
384E  0EB8     MOVLW 0xB8
3850  26E9     ADDWF FSR0, F, ACCESS
3852  0E00     MOVLW 0x0
3854  22EA     ADDWFC FSR0H, F, ACCESS
3856  0E03     MOVLW 0x3
3858  26E9     ADDWF FSR0, F, ACCESS
385A  0E00     MOVLW 0x0
385C  22EA     ADDWFC FSR0H, F, ACCESS
385E  CFEE     MOVFF POSTINC0, __tmp_0
3860  F032     NOP
3862  CFEF     MOVFF INDF0, 0x33
3864  F033     NOP
3866  0E0A     MOVLW 0xA
3868  5C32     SUBWF __tmp_0, W, ACCESS
386A  0E00     MOVLW 0x0
386C  5833     SUBWFB 0x33, W, ACCESS
203:                                    M_AI_ADC_Data[index].data_value < *(M_AI_ptrTable[index] + M_AI_Offset_in_table[index][0])) 
386E  E201     BC 0x3872
3870  D07A     BRA 0x3966
3872  0EFE     MOVLW 0xFE
3874  50DB     MOVF PLUSW2, W, ACCESS
3876  0D06     MULLW 0x6
3878  CFF3     MOVFF PROD, FSR0
387A  FFE9     NOP
387C  CFF4     MOVFF PRODH, FSR0H
387E  FFEA     NOP
3880  0EB8     MOVLW 0xB8
3882  26E9     ADDWF FSR0, F, ACCESS
3884  0E00     MOVLW 0x0
3886  22EA     ADDWFC FSR0H, F, ACCESS
3888  0E03     MOVLW 0x3
388A  26E9     ADDWF FSR0, F, ACCESS
388C  0E00     MOVLW 0x0
388E  22EA     ADDWFC FSR0H, F, ACCESS
3890  CFEE     MOVFF POSTINC0, 0x34
3892  F034     NOP
3894  CFEF     MOVFF INDF0, 0x35
3896  F035     NOP
3898  0EFE     MOVLW 0xFE
389A  6AEA     CLRF FSR0H, ACCESS
389C  34DB     RLCF PLUSW2, W, ACCESS
389E  0BFE     ANDLW 0xFE
38A0  36EA     RLCF FSR0H, F, ACCESS
38A2  6EE9     MOVWF FSR0, ACCESS
38A4  0EB4     MOVLW 0xB4
38A6  26E9     ADDWF FSR0, F, ACCESS
38A8  0E00     MOVLW 0x0
38AA  22EA     ADDWFC FSR0H, F, ACCESS
38AC  CFEE     MOVFF POSTINC0, 0x38
38AE  F038     NOP
38B0  CFEF     MOVFF INDF0, 0x39
38B2  F039     NOP
38B4  0EFE     MOVLW 0xFE
38B6  6AF7     CLRF TBLPTRH, ACCESS
38B8  34DB     RLCF PLUSW2, W, ACCESS
38BA  0BFE     ANDLW 0xFE
38BC  36F7     RLCF TBLPTRH, F, ACCESS
38BE  6EF6     MOVWF TBLPTR, ACCESS
38C0  0E2C     MOVLW 0x2C
38C2  26F6     ADDWF TBLPTR, F, ACCESS
38C4  0E46     MOVLW 0x46
38C6  22F7     ADDWFC TBLPTRH, F, ACCESS
38C8  0008     TBLRD*
38CA  50F5     MOVF TABLAT, W, ACCESS
38CC  0D02     MULLW 0x2
38CE  5038     MOVF 0x38, W, ACCESS
38D0  24F3     ADDWF PROD, W, ACCESS
38D2  6EF6     MOVWF TBLPTR, ACCESS
38D4  5039     MOVF 0x39, W, ACCESS
38D6  20F4     ADDWFC PRODH, W, ACCESS
38D8  6EF7     MOVWF TBLPTRH, ACCESS
38DA  0009     TBLRD*+
38DC  CFF5     MOVFF TABLAT, 0x36
38DE  F036     NOP
38E0  0008     TBLRD*
38E2  CFF5     MOVFF TABLAT, 0x37
38E4  F037     NOP
38E6  5036     MOVF 0x36, W, ACCESS
38E8  5C34     SUBWF 0x34, W, ACCESS
38EA  5037     MOVF 0x37, W, ACCESS
38EC  5835     SUBWFB 0x35, W, ACCESS
38EE  E23B     BC 0x3966
204:                                       M_AI_ADC_Data[index].data_value = *(M_AI_ptrTable[index] + M_AI_Offset_in_table[index][0]);
38F0  0EFE     MOVLW 0xFE
38F2  6AEA     CLRF FSR0H, ACCESS
38F4  34DB     RLCF PLUSW2, W, ACCESS
38F6  0BFE     ANDLW 0xFE
38F8  36EA     RLCF FSR0H, F, ACCESS
38FA  6EE9     MOVWF FSR0, ACCESS
38FC  0EB4     MOVLW 0xB4
38FE  26E9     ADDWF FSR0, F, ACCESS
3900  0E00     MOVLW 0x0
3902  22EA     ADDWFC FSR0H, F, ACCESS
3904  CFEE     MOVFF POSTINC0, 0x34
3906  F034     NOP
3908  CFEF     MOVFF INDF0, 0x35
390A  F035     NOP
390C  0EFE     MOVLW 0xFE
390E  6AF7     CLRF TBLPTRH, ACCESS
3910  34DB     RLCF PLUSW2, W, ACCESS
3912  0BFE     ANDLW 0xFE
3914  36F7     RLCF TBLPTRH, F, ACCESS
3916  6EF6     MOVWF TBLPTR, ACCESS
3918  0E2C     MOVLW 0x2C
391A  26F6     ADDWF TBLPTR, F, ACCESS
391C  0E46     MOVLW 0x46
391E  22F7     ADDWFC TBLPTRH, F, ACCESS
3920  0008     TBLRD*
3922  50F5     MOVF TABLAT, W, ACCESS
3924  0D02     MULLW 0x2
3926  5034     MOVF 0x34, W, ACCESS
3928  24F3     ADDWF PROD, W, ACCESS
392A  6EF6     MOVWF TBLPTR, ACCESS
392C  5035     MOVF 0x35, W, ACCESS
392E  20F4     ADDWFC PRODH, W, ACCESS
3930  6EF7     MOVWF TBLPTRH, ACCESS
3932  0009     TBLRD*+
3934  CFF5     MOVFF TABLAT, __tmp_0
3936  F032     NOP
3938  0008     TBLRD*
393A  CFF5     MOVFF TABLAT, 0x33
393C  F033     NOP
393E  0EFE     MOVLW 0xFE
3940  50DB     MOVF PLUSW2, W, ACCESS
3942  0D06     MULLW 0x6
3944  CFF3     MOVFF PROD, FSR0
3946  FFE9     NOP
3948  CFF4     MOVFF PRODH, FSR0H
394A  FFEA     NOP
394C  0EB8     MOVLW 0xB8
394E  26E9     ADDWF FSR0, F, ACCESS
3950  0E00     MOVLW 0x0
3952  22EA     ADDWFC FSR0H, F, ACCESS
3954  0E03     MOVLW 0x3
3956  26E9     ADDWF FSR0, F, ACCESS
3958  0E00     MOVLW 0x0
395A  22EA     ADDWFC FSR0H, F, ACCESS
395C  C032     MOVFF __tmp_0, POSTINC0
395E  FFEE     NOP
3960  C033     MOVFF 0x33, POSTDEC0
3962  FFED     NOP
205:                           else if (M_AI_ADC_Data[index].data_value <= BREAK_SENSOR_THRESHOLD && 
3964  D097     BRA 0x3A94
3966  0EFE     MOVLW 0xFE
3968  50DB     MOVF PLUSW2, W, ACCESS
396A  0D06     MULLW 0x6
396C  CFF3     MOVFF PROD, FSR0
396E  FFE9     NOP
3970  CFF4     MOVFF PRODH, FSR0H
3972  FFEA     NOP
3974  0EB8     MOVLW 0xB8
3976  26E9     ADDWF FSR0, F, ACCESS
3978  0E00     MOVLW 0x0
397A  22EA     ADDWFC FSR0H, F, ACCESS
397C  0E03     MOVLW 0x3
397E  26E9     ADDWF FSR0, F, ACCESS
3980  0E00     MOVLW 0x0
3982  22EA     ADDWFC FSR0H, F, ACCESS
3984  0ED4     MOVLW 0xD4
3986  80D8     BSF STATUS, 0, ACCESS
3988  54EE     SUBFWB POSTINC0, W, ACCESS
398A  0E03     MOVLW 0x3
398C  54ED     SUBFWB POSTDEC0, W, ACCESS
206:                                    M_AI_ADC_Data[index].data_value > *(M_AI_ptrTable[index] + M_AI_Offset_in_table[index][1])) 
398E  E201     BC 0x3992
3990  D081     BRA 0x3A94
3992  0EFE     MOVLW 0xFE
3994  50DB     MOVF PLUSW2, W, ACCESS
3996  0D06     MULLW 0x6
3998  CFF3     MOVFF PROD, FSR0
399A  FFE9     NOP
399C  CFF4     MOVFF PRODH, FSR0H
399E  FFEA     NOP
39A0  0EB8     MOVLW 0xB8
39A2  26E9     ADDWF FSR0, F, ACCESS
39A4  0E00     MOVLW 0x0
39A6  22EA     ADDWFC FSR0H, F, ACCESS
39A8  0E03     MOVLW 0x3
39AA  26E9     ADDWF FSR0, F, ACCESS
39AC  0E00     MOVLW 0x0
39AE  22EA     ADDWFC FSR0H, F, ACCESS
39B0  CFEE     MOVFF POSTINC0, __tmp_0
39B2  F032     NOP
39B4  CFEF     MOVFF INDF0, 0x33
39B6  F033     NOP
39B8  0EFE     MOVLW 0xFE
39BA  6AEA     CLRF FSR0H, ACCESS
39BC  34DB     RLCF PLUSW2, W, ACCESS
39BE  0BFE     ANDLW 0xFE
39C0  36EA     RLCF FSR0H, F, ACCESS
39C2  6EE9     MOVWF FSR0, ACCESS
39C4  0EB4     MOVLW 0xB4
39C6  26E9     ADDWF FSR0, F, ACCESS
39C8  0E00     MOVLW 0x0
39CA  22EA     ADDWFC FSR0H, F, ACCESS
39CC  CFEE     MOVFF POSTINC0, 0x36
39CE  F036     NOP
39D0  CFEF     MOVFF INDF0, 0x37
39D2  F037     NOP
39D4  0EFE     MOVLW 0xFE
39D6  6AF7     CLRF TBLPTRH, ACCESS
39D8  34DB     RLCF PLUSW2, W, ACCESS
39DA  0BFE     ANDLW 0xFE
39DC  36F7     RLCF TBLPTRH, F, ACCESS
39DE  6EF6     MOVWF TBLPTR, ACCESS
39E0  0E2C     MOVLW 0x2C
39E2  26F6     ADDWF TBLPTR, F, ACCESS
39E4  0E46     MOVLW 0x46
39E6  22F7     ADDWFC TBLPTRH, F, ACCESS
39E8  0E01     MOVLW 0x1
39EA  26F6     ADDWF TBLPTR, F, ACCESS
39EC  0E00     MOVLW 0x0
39EE  22F7     ADDWFC TBLPTRH, F, ACCESS
39F0  0008     TBLRD*
39F2  50F5     MOVF TABLAT, W, ACCESS
39F4  0D02     MULLW 0x2
39F6  5036     MOVF 0x36, W, ACCESS
39F8  24F3     ADDWF PROD, W, ACCESS
39FA  6EF6     MOVWF TBLPTR, ACCESS
39FC  5037     MOVF 0x37, W, ACCESS
39FE  20F4     ADDWFC PRODH, W, ACCESS
3A00  6EF7     MOVWF TBLPTRH, ACCESS
3A02  0009     TBLRD*+
3A04  CFF5     MOVFF TABLAT, 0x34
3A06  F034     NOP
3A08  0008     TBLRD*
3A0A  CFF5     MOVFF TABLAT, 0x35
3A0C  F035     NOP
3A0E  5032     MOVF __tmp_0, W, ACCESS
3A10  5C34     SUBWF 0x34, W, ACCESS
3A12  5033     MOVF 0x33, W, ACCESS
3A14  5835     SUBWFB 0x35, W, ACCESS
3A16  E23E     BC 0x3A94
207:                                       M_AI_ADC_Data[index].data_value = *(M_AI_ptrTable[index] + M_AI_Offset_in_table[index][1]);
3A18  0EFE     MOVLW 0xFE
3A1A  6AEA     CLRF FSR0H, ACCESS
3A1C  34DB     RLCF PLUSW2, W, ACCESS
3A1E  0BFE     ANDLW 0xFE
3A20  36EA     RLCF FSR0H, F, ACCESS
3A22  6EE9     MOVWF FSR0, ACCESS
3A24  0EB4     MOVLW 0xB4
3A26  26E9     ADDWF FSR0, F, ACCESS
3A28  0E00     MOVLW 0x0
3A2A  22EA     ADDWFC FSR0H, F, ACCESS
3A2C  CFEE     MOVFF POSTINC0, 0x34
3A2E  F034     NOP
3A30  CFEF     MOVFF INDF0, 0x35
3A32  F035     NOP
3A34  0EFE     MOVLW 0xFE
3A36  6AF7     CLRF TBLPTRH, ACCESS
3A38  34DB     RLCF PLUSW2, W, ACCESS
3A3A  0BFE     ANDLW 0xFE
3A3C  36F7     RLCF TBLPTRH, F, ACCESS
3A3E  6EF6     MOVWF TBLPTR, ACCESS
3A40  0E2C     MOVLW 0x2C
3A42  26F6     ADDWF TBLPTR, F, ACCESS
3A44  0E46     MOVLW 0x46
3A46  22F7     ADDWFC TBLPTRH, F, ACCESS
3A48  0E01     MOVLW 0x1
3A4A  26F6     ADDWF TBLPTR, F, ACCESS
3A4C  0E00     MOVLW 0x0
3A4E  22F7     ADDWFC TBLPTRH, F, ACCESS
3A50  0008     TBLRD*
3A52  50F5     MOVF TABLAT, W, ACCESS
3A54  0D02     MULLW 0x2
3A56  5034     MOVF 0x34, W, ACCESS
3A58  24F3     ADDWF PROD, W, ACCESS
3A5A  6EF6     MOVWF TBLPTR, ACCESS
3A5C  5035     MOVF 0x35, W, ACCESS
3A5E  20F4     ADDWFC PRODH, W, ACCESS
3A60  6EF7     MOVWF TBLPTRH, ACCESS
3A62  0009     TBLRD*+
3A64  CFF5     MOVFF TABLAT, __tmp_0
3A66  F032     NOP
3A68  0008     TBLRD*
3A6A  CFF5     MOVFF TABLAT, 0x33
3A6C  F033     NOP
3A6E  0EFE     MOVLW 0xFE
3A70  50DB     MOVF PLUSW2, W, ACCESS
3A72  0D06     MULLW 0x6
3A74  CFF3     MOVFF PROD, FSR0
3A76  FFE9     NOP
3A78  CFF4     MOVFF PRODH, FSR0H
3A7A  FFEA     NOP
3A7C  0EB8     MOVLW 0xB8
3A7E  26E9     ADDWF FSR0, F, ACCESS
3A80  0E00     MOVLW 0x0
3A82  22EA     ADDWFC FSR0H, F, ACCESS
3A84  0E03     MOVLW 0x3
3A86  26E9     ADDWF FSR0, F, ACCESS
3A88  0E00     MOVLW 0x0
3A8A  22EA     ADDWFC FSR0H, F, ACCESS
3A8C  C032     MOVFF __tmp_0, POSTINC0
3A8E  FFEE     NOP
3A90  C033     MOVFF 0x33, POSTDEC0
3A92  FFED     NOP
208:           
209:                                   //Вычисление температуры поиском по таблице
210:                                   M_AI_ADC_Data[index].param = M_AI_Search(M_AI_ADC_Data[index].data_value, M_AI_ptrTable[index],
3ABC  0EFE     MOVLW 0xFE
3ABE  6AEA     CLRF FSR0H, ACCESS
3AC0  34DB     RLCF PLUSW2, W, ACCESS
3AC2  0BFE     ANDLW 0xFE
3AC4  36EA     RLCF FSR0H, F, ACCESS
3AC6  6EE9     MOVWF FSR0, ACCESS
3AC8  0EB4     MOVLW 0xB4
3ACA  26E9     ADDWF FSR0, F, ACCESS
3ACC  0E00     MOVLW 0x0
3ACE  22EA     ADDWFC FSR0H, F, ACCESS
3AD0  CFEE     MOVFF POSTINC0, POSTINC1
3AD2  FFE6     NOP
3AD4  CFEF     MOVFF INDF0, POSTINC1
3AD6  FFE6     NOP
3AD8  0EFE     MOVLW 0xFE
3ADA  50DB     MOVF PLUSW2, W, ACCESS
3ADC  0D06     MULLW 0x6
3ADE  CFF3     MOVFF PROD, FSR0
3AE0  FFE9     NOP
3AE2  CFF4     MOVFF PRODH, FSR0H
3AE4  FFEA     NOP
3AE6  0EB8     MOVLW 0xB8
3AE8  26E9     ADDWF FSR0, F, ACCESS
3AEA  0E00     MOVLW 0x0
3AEC  22EA     ADDWFC FSR0H, F, ACCESS
3AEE  0E03     MOVLW 0x3
3AF0  26E9     ADDWF FSR0, F, ACCESS
3AF2  0E00     MOVLW 0x0
3AF4  22EA     ADDWFC FSR0H, F, ACCESS
3AF6  CFEE     MOVFF POSTINC0, POSTINC1
3AF8  FFE6     NOP
3AFA  CFEF     MOVFF INDF0, POSTINC1
3AFC  FFE6     NOP
3B0A  0EFE     MOVLW 0xFE
3B0C  50DB     MOVF PLUSW2, W, ACCESS
3B0E  0D06     MULLW 0x6
3B10  CFF3     MOVFF PROD, FSR0
3B12  FFE9     NOP
3B14  CFF4     MOVFF PRODH, FSR0H
3B16  FFEA     NOP
3B18  0EB8     MOVLW 0xB8
3B1A  26E9     ADDWF FSR0, F, ACCESS
3B1C  0E00     MOVLW 0x0
3B1E  22EA     ADDWFC FSR0H, F, ACCESS
3B20  0E05     MOVLW 0x5
3B22  26E9     ADDWF FSR0, F, ACCESS
3B24  0E00     MOVLW 0x0
3B26  22EA     ADDWFC FSR0H, F, ACCESS
211:                                                                            M_AI_Size_Table_temperature[index], M_AI_Type_Table_Sorted[index]); 
3A94  0EFE     MOVLW 0xFE
3A96  50DB     MOVF PLUSW2, W, ACCESS
3A98  6AF7     CLRF TBLPTRH, ACCESS
3A9A  0F2A     ADDLW 0x2A
3A9C  6EF6     MOVWF TBLPTR, ACCESS
3A9E  0E46     MOVLW 0x46
3AA0  22F7     ADDWFC TBLPTRH, F, ACCESS
3AA2  0008     TBLRD*
3AA4  50F5     MOVF TABLAT, W, ACCESS
3AA6  6EE6     MOVWF POSTINC1, ACCESS
3AA8  0EFE     MOVLW 0xFE
3AAA  50DB     MOVF PLUSW2, W, ACCESS
3AAC  6AF7     CLRF TBLPTRH, ACCESS
3AAE  0F33     ADDLW 0x33
3AB0  6EF6     MOVWF TBLPTR, ACCESS
3AB2  0E46     MOVLW 0x46
3AB4  22F7     ADDWFC TBLPTRH, F, ACCESS
3AB6  0008     TBLRD*
3AB8  50F5     MOVF TABLAT, W, ACCESS
3ABA  6EE6     MOVWF POSTINC1, ACCESS
3AFE  DCE9     RCALL M_AI_Search
3B00  6E32     MOVWF __tmp_0, ACCESS
3B02  0E06     MOVLW 0x6
3B04  5EE1     SUBWF FSR1, F, ACCESS
3B06  5032     MOVF __tmp_0, W, ACCESS
3B08  6EE6     MOVWF POSTINC1, ACCESS
3B28  52E5     MOVF POSTDEC1, F, ACCESS
3B2A  50E7     MOVF INDF1, W, ACCESS
3B2C  6EEF     MOVWF INDF0, ACCESS
212:                           break;
3B2E  D001     BRA 0x3B32
213:                   
214:                       case CHN_I_SUPPLY_12V:
215:                           break;
3B30  D000     BRA 0x3B32
216:                   }
217:               }
218:           }
3B32  52E5     MOVF POSTDEC1, F, ACCESS
3B34  CFE7     MOVFF INDF1, FSR2
3B36  FFD9     NOP
3B38  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Menu/menu.c  -------------------------------------
1:             #include "menu.h"
2:             #include "stdint.h"
3:             #include "module_indication.h"
4:             #include "module_management.h"
5:             #include "module_motor.h"
6:             #include "module_logic_inputs.h"
7:             #include "module_analog_inputs.h"
8:             #include "module_fan.h"
9:             #include <string.h>
10:            #include "eeprom.h"
11:            #include "module_sound.h"
12:            
13:            
14:            /* Константа минимальных и максимальных значений порогов величин, 
15:            значения которых устанавливаются в меню.
16:            Размещены последовательно по 2 элемента. 1-ый элемент - минимальное значение,
17:            2-ой элемент - максимальное значение
18:            */
19:            const rom uint8_t Menu_items_thresholds[] = 
20:            {
21:            /* №стр Значение параметра   */
22:            /*P0*/  10, 99,		//время разгона двигателя(дозатора) в 1/100 с. Диапазон значений 10...99 (100мс...990мс)
23:            /*P1*/  1, 60,		//максимальное время вращения двигателя(дозатора) в секундах. Диапазон значений 1...60 (1с...60с)
24:            /*P2*/  28, 100,	//минимальный процент скважности ШИМа при разгоне двигателя(дозатора). Диапазон значений 28...100
25:            /*P3*/  0, 3,		//количество повторных попыток вращения двигателя(дозатора) при несрабатывании концевика, после которого появляется признак аварии
26:            /*P4*/  10, 99,		//время разгона двигателя(ворошителя) в 1/100 с. Диапазон значений 10...99 (100мс...990мс)
27:            /*P5*/  1, 60,		//максимальное время вращения двигателя(ворошителя) в секундах. Диапазон значений 1...60 (1с...60с)
28:            /*P6*/  28, 100,	//минимальный процент скважности ШИМа при разгоне двигателя(ворошителя). Диапазон значений 28...100
29:            /*P7*/  0, 0,		//количество повторных попыток вращения двигателя(ворошителя) при несрабатывании концевика, после которого появляется признак аварии
30:            /*P8*/  10, 99,		//время разгона двигателя(заслонки) в 1/100 с. Диапазон значений 10...99 (100мс...990мс)
31:            /*P9*/  1, 60,		//максимальное время вращения двигателя(заслонки) в секундах. Диапазон значений 1...60 (1с...60с)
32:            /*P10*/ 28, 100,	//минимальный процент скважности ШИМа при разгоне двигателя(заслонки). Диапазон значений 28...100
33:            /*P11*/ 0, 7, 		//количество повторных попыток вращения двигателя(заслонки) при несрабатывании концевика, после которого появляется признак аварии
34:            /*P12*/ 10, 99,		//время разгона двигателя(чистка золы) в 1/100 с. Диапазон значений 10...99 (100мс...990мс)
35:            /*P13*/ 1, 60,		//максимальное время вращения двигателя(чистка золы) в секундах. Диапазон значений 1...60 (1с...60с)
36:            /*P14*/ 28, 100,	//минимальный процент скважности ШИМа при разгоне двигателя(чистка золы). Диапазон значений 28...100
37:            /*P15*/ 0, 0,		//количество повторных попыток вращения двигателя(чистка золы) при несрабатывании концевика, после которого появляется признак аварии
38:            /*P16*/ 2, 2,		//минимальный уровень оборотов вентилятора в режиме поддержания температуры при горении топлива. Диапазон значений 2...2 
39:            /*P17*/ 4, 8,		//максимальный процент скорости оборотов вентилятора. Диапазон значений 4...8
40:            /*P18*/ 5, 120,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для угля)
41:            /*P19*/ 5, 120,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для щепы)
42:            /*P20*/ 5, 120,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для пеллет)
43:            /*P21*/ 1, 36,		//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для угля)
44:            /*P22*/ 1, 36,  	//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для щепы)
45:            /*P23*/ 1, 36,  	//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для пеллет)
46:            /*P24*/ 1, 10,		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для угля)
47:            /*P25*/ 1, 10,		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для щепы)
48:            /*P26*/ 1, 10, 		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для пеллет)
49:            /*P27*/ 6, 42,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для угля)
50:            /*P28*/ 6, 42,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для щепы)
51:            /*P29*/ 6, 42,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для пеллет)
52:            /*P30*/ 1, 15,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для угля
53:            /*P31*/ 1, 8,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для щепы
54:            /*P32*/ 1, 8,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для пеллет
55:            /*P33*/ 1, 8,		// уровень оборотов вентилятора в эконом-режиме от 2 до 8 для угля
56:            /*P34*/ 1, 8,		// уровень оборотов вентилятора в эконом-режиме от 2 до 8 для щепы
57:            /*P35*/ 1, 8,		// уровень оборотов вентилятора в эконом-режиме от 2 до 8 для пеллет
58:            /*P36*/ 1, 8,		// уровень оборотов вентилятора в режиме продувки от 2 до 8 для угля
59:            /*P37*/ 1, 8,		// уровень оборотов вентилятора в режиме продувки от 2 до 8 для щепы
60:            /*P38*/ 1, 8,		// уровень оборотов вентилятора в режиме продувки от 2 до 8 для пеллет
61:            /*P39*/ 30, 90, 	//установленная температура
62:            /*P40*/ 0, 2, 		//тип топлива
63:            /*P41*/ 0, 1, 		//флаг разрешения звука. 1 - разрешён, 0 - запрещён
64:            /*P42*/ 8, 60,		//время в секундах, по истечении которого, если нет действий пользователя, выходим из меню
65:            /*P43*/ 1, 63,		//период загрузок топлива "Уголь"  (в сотнях секунд, от 1 до 54, т.е. от 100 секунд до 1 часа 45 минут) 
66:            /*P44*/ 1, 63, 		//период загрузок топлива "Брикеты" (в сотнях секунд, от 1 до 54, т.е. от 100 секунд до 1.5 часа) 
67:            /*P45*/ 1, 63,		//период загрузок топлива "Пеллеты" (в сотнях секунд, от 1 до 54, т.е. от 100 секунд до 1.5 часа)
68:            /*P46*/ 2, 10,		//пороговое значение разницы между текущей и установленной температурой, по которому делается выход из циклического режима работы вентилятора
69:            /*P47*/ 1, 8,		//уровень оборотов вентилятора для режима горения (фактически, это время, в течение которого симистор открыт в каждом полупериоде синусоиды)  
70:            /*P48*/ 5, 20,       //время работы двигателя чистки золы (в секундах)
71:            /*P49*/ 18, 216     //период между включениями двигателя чистки золы (от 30 минут до 6 часов)
72:            };
73:            
74:            #define QUANTITY_OF_MENU_PARAMETERS	 ( sizeof(Menu_items_thresholds) / Menu_items_thresholds[0] - 1 ) 
75:            #define INCREMENT	1
76:            #define DECREMENT	0
77:            
78:            
79:            uint8_t Menu_Num_Page_Menu = 0; 
80:            uint8_t M_Menu_src_param_menu = 0;
81:            BOOL temper_water_or_gas = 0;
82:            BOOL Menu_manual_supply = OFF;
83:            
84:            BOOL Menu_get_manual_supply(void)
85:            {
86:            	return Menu_manual_supply;
2038  0101     MOVLB 0x1
203A  5112     MOVF 0x12, W, BANKED
203C  D000     BRA 0x203E
87:            }
203E  0012     RETURN 0
88:            
89:            BOOL Menu_get_temper_water_or_gas(void)
90:            {
91:            	return temper_water_or_gas;
2040  0101     MOVLB 0x1
2042  5111     MOVF 0x11, W, BANKED
2044  D000     BRA 0x2046
92:            }
2046  0012     RETURN 0
93:            
94:            
95:            uint8_t Menu_Get_Num_Page_Menu(void)
96:            {
97:            	return Menu_Num_Page_Menu;
2048  0101     MOVLB 0x1
204A  510F     MOVF 0xF, W, BANKED
204C  D000     BRA 0x204E
98:            }
204E  0012     RETURN 0
99:            
100:           //Функция увеличения параметра меню до установленного предела
101:           void Menu_inc_param(uint8_t* parameter, const uint8_t threshold_up)
2050  CFD9     MOVFF FSR2, POSTINC1
2052  FFE6     NOP
2054  CFE1     MOVFF FSR1, FSR2
2056  FFD9     NOP
102:           {
103:           	if(*parameter < threshold_up) (*parameter)++;
2058  0EFD     MOVLW 0xFD
205A  CFDB     MOVFF PLUSW2, FSR0
205C  FFE9     NOP
205E  0EFE     MOVLW 0xFE
2060  CFDB     MOVFF PLUSW2, FSR0H
2062  FFEA     NOP
2064  CFEF     MOVFF INDF0, __tmp_0
2066  F032     NOP
2068  0EFC     MOVLW 0xFC
206A  50DB     MOVF PLUSW2, W, ACCESS
206C  5C32     SUBWF __tmp_0, W, ACCESS
206E  E207     BC 0x207E
2070  0EFD     MOVLW 0xFD
2072  CFDB     MOVFF PLUSW2, FSR0
2074  FFE9     NOP
2076  0EFE     MOVLW 0xFE
2078  CFDB     MOVFF PLUSW2, FSR0H
207A  FFEA     NOP
207C  2AEF     INCF INDF0, F, ACCESS
104:           }
207E  52E5     MOVF POSTDEC1, F, ACCESS
2080  CFE7     MOVFF INDF1, FSR2
2082  FFD9     NOP
2084  0012     RETURN 0
105:           
106:           //Функция уменьшения параметра меню до установленного предела
107:           void Menu_dec_param(uint8_t* parameter, const uint8_t threshold_down)
2086  CFD9     MOVFF FSR2, POSTINC1
2088  FFE6     NOP
208A  CFE1     MOVFF FSR1, FSR2
208C  FFD9     NOP
108:           {
109:           	if(*parameter > threshold_down) (*parameter)--;
208E  0EFD     MOVLW 0xFD
2090  CFDB     MOVFF PLUSW2, FSR0
2092  FFE9     NOP
2094  0EFE     MOVLW 0xFE
2096  CFDB     MOVFF PLUSW2, FSR0H
2098  FFEA     NOP
209A  CFEF     MOVFF INDF0, __tmp_0
209C  F032     NOP
209E  0EFC     MOVLW 0xFC
20A0  50DB     MOVF PLUSW2, W, ACCESS
20A2  80D8     BSF STATUS, 0, ACCESS
20A4  5432     SUBFWB __tmp_0, W, ACCESS
20A6  E207     BC 0x20B6
20A8  0EFD     MOVLW 0xFD
20AA  CFDB     MOVFF PLUSW2, FSR0
20AC  FFE9     NOP
20AE  0EFE     MOVLW 0xFE
20B0  CFDB     MOVFF PLUSW2, FSR0H
20B2  FFEA     NOP
20B4  06EF     DECF INDF0, F, ACCESS
110:           }
20B6  52E5     MOVF POSTDEC1, F, ACCESS
20B8  CFE7     MOVFF INDF1, FSR2
20BA  FFD9     NOP
20BC  0012     RETURN 0
111:           
112:           /*Функция изменения параметра меню в зависимости от направления изменения (инкремент/декремент)
113:           direction = 1 - инкремент
114:           direction = 0 -декремент
115:           */
116:           void Menu_item_change(uint8_t* menu_param, uint8_t index, BOOL direction)
20BE  CFD9     MOVFF FSR2, POSTINC1
20C0  FFE6     NOP
20C2  CFE1     MOVFF FSR1, FSR2
20C4  FFD9     NOP
117:           {
118:           	if(direction) //увеличение параметра
20C6  0EFB     MOVLW 0xFB
20C8  50DB     MOVF PLUSW2, W, ACCESS
20CA  E022     BZ 0x2110
119:           	{
120:           		Menu_inc_param(&menu_param[index], Menu_items_thresholds[index*2 + 1]);  			
20CC  0EFC     MOVLW 0xFC
20CE  50DB     MOVF PLUSW2, W, ACCESS
20D0  24E8     ADDWF WREG, W, ACCESS
20D2  0F01     ADDLW 0x1
20D4  6AF7     CLRF TBLPTRH, ACCESS
20D6  0F7A     ADDLW 0x7A
20D8  6EF6     MOVWF TBLPTR, ACCESS
20DA  0E4B     MOVLW 0x4B
20DC  22F7     ADDWFC TBLPTRH, F, ACCESS
20DE  0008     TBLRD*
20E0  50F5     MOVF TABLAT, W, ACCESS
20E2  6EE6     MOVWF POSTINC1, ACCESS
20E4  0EFC     MOVLW 0xFC
20E6  50DB     MOVF PLUSW2, W, ACCESS
20E8  6EE7     MOVWF INDF1, ACCESS
20EA  0EFD     MOVLW 0xFD
20EC  CFDB     MOVFF PLUSW2, __tmp_0
20EE  F032     NOP
20F0  0EFE     MOVLW 0xFE
20F2  CFDB     MOVFF PLUSW2, 0x33
20F4  F033     NOP
20F6  50E7     MOVF INDF1, W, ACCESS
20F8  2632     ADDWF __tmp_0, F, ACCESS
20FA  0E00     MOVLW 0x0
20FC  2233     ADDWFC 0x33, F, ACCESS
20FE  C032     MOVFF __tmp_0, POSTINC1
2100  FFE6     NOP
2102  C033     MOVFF 0x33, POSTINC1
2104  FFE6     NOP
2106  DFA4     RCALL Menu_inc_param
2108  52E5     MOVF POSTDEC1, F, ACCESS
210A  52E5     MOVF POSTDEC1, F, ACCESS
210C  52E5     MOVF POSTDEC1, F, ACCESS
121:           	}
122:           	else
210E  D020     BRA 0x2150
123:           	{
124:           		Menu_dec_param(&menu_param[index], Menu_items_thresholds[index*2]);
2110  0EFC     MOVLW 0xFC
2112  50DB     MOVF PLUSW2, W, ACCESS
2114  24E8     ADDWF WREG, W, ACCESS
2116  6AF7     CLRF TBLPTRH, ACCESS
2118  0F7A     ADDLW 0x7A
211A  6EF6     MOVWF TBLPTR, ACCESS
211C  0E4B     MOVLW 0x4B
211E  22F7     ADDWFC TBLPTRH, F, ACCESS
2120  0008     TBLRD*
2122  50F5     MOVF TABLAT, W, ACCESS
2124  6EE6     MOVWF POSTINC1, ACCESS
2126  0EFC     MOVLW 0xFC
2128  50DB     MOVF PLUSW2, W, ACCESS
212A  6EE7     MOVWF INDF1, ACCESS
212C  0EFD     MOVLW 0xFD
212E  CFDB     MOVFF PLUSW2, __tmp_0
2130  F032     NOP
2132  0EFE     MOVLW 0xFE
2134  CFDB     MOVFF PLUSW2, 0x33
2136  F033     NOP
2138  50E7     MOVF INDF1, W, ACCESS
213A  2632     ADDWF __tmp_0, F, ACCESS
213C  0E00     MOVLW 0x0
213E  2233     ADDWFC 0x33, F, ACCESS
2140  C032     MOVFF __tmp_0, POSTINC1
2142  FFE6     NOP
2144  C033     MOVFF 0x33, POSTINC1
2146  FFE6     NOP
2148  DF9E     RCALL Menu_dec_param
214A  52E5     MOVF POSTDEC1, F, ACCESS
214C  52E5     MOVF POSTDEC1, F, ACCESS
214E  52E5     MOVF POSTDEC1, F, ACCESS
125:           	}
126:           }
2150  52E5     MOVF POSTDEC1, F, ACCESS
2152  CFE7     MOVFF INDF1, FSR2
2154  FFD9     NOP
2156  0012     RETURN 0
127:           
128:           /* Установка указателя на текущий параметр меню, который подлежит изменению */
129:           void M_Menu_Set_src_param_menu(uint8_t* menu_param, uint8_t num_page)
2158  CFD9     MOVFF FSR2, POSTINC1
215A  FFE6     NOP
215C  CFE1     MOVFF FSR1, FSR2
215E  FFD9     NOP
130:           {
131:           	M_Menu_src_param_menu = menu_param[num_page];		
2160  0EFC     MOVLW 0xFC
2162  50DB     MOVF PLUSW2, W, ACCESS
2164  6EE7     MOVWF INDF1, ACCESS
2166  0EFD     MOVLW 0xFD
2168  CFDB     MOVFF PLUSW2, FSR0
216A  FFE9     NOP
216C  0EFE     MOVLW 0xFE
216E  CFDB     MOVFF PLUSW2, FSR0H
2170  FFEA     NOP
2172  50E7     MOVF INDF1, W, ACCESS
2174  26E9     ADDWF FSR0, F, ACCESS
2176  0E00     MOVLW 0x0
2178  22EA     ADDWFC FSR0H, F, ACCESS
217A  CFEF     MOVFF INDF0, M_Menu_src_param_menu
217C  F110     NOP
132:           }
217E  52E5     MOVF POSTDEC1, F, ACCESS
2180  CFE7     MOVFF INDF1, FSR2
2182  FFD9     NOP
2184  0012     RETURN 0
133:           
134:           
135:           BOOL M_Menu_write_changed_param(uint8_t addr_param, uint8_t src_param, uint8_t changed_param)
2186  CFD9     MOVFF FSR2, POSTINC1
2188  FFE6     NOP
218A  CFE1     MOVFF FSR1, FSR2
218C  FFD9     NOP
136:           {
137:           	if(src_param != changed_param) //параметр изменился
218E  0EFC     MOVLW 0xFC
2190  50DB     MOVF PLUSW2, W, ACCESS
2192  6EF3     MOVWF PROD, ACCESS
2194  0EFD     MOVLW 0xFD
2196  50DB     MOVF PLUSW2, W, ACCESS
2198  5CF3     SUBWF PROD, W, ACCESS
219A  E00F     BZ 0x21BA
138:           	{
139:           		DataEEWrite (changed_param, addr_param );
219C  0EFE     MOVLW 0xFE
219E  CFDB     MOVFF PLUSW2, POSTINC1
21A0  FFE6     NOP
21A2  0EFC     MOVLW 0xFC
21A4  CFDB     MOVFF PLUSW2, POSTINC1
21A6  FFE6     NOP
21A8  6AE6     CLRF POSTINC1, ACCESS
21AA  EC0E     CALL 0x3E1C, 0
21AC  F01F     NOP
21AE  52E5     MOVF POSTDEC1, F, ACCESS
21B0  52E5     MOVF POSTDEC1, F, ACCESS
21B2  52E5     MOVF POSTDEC1, F, ACCESS
140:           		return TRUE;
21B4  0E01     MOVLW 0x1
21B6  D003     BRA 0x21BE
141:           	}		
142:           	else
21B8  D002     BRA 0x21BE
143:           	{
144:           		return FALSE;
21BA  0E00     MOVLW 0x0
21BC  D000     BRA 0x21BE
145:           	}	
146:           }
21BE  52E5     MOVF POSTDEC1, F, ACCESS
21C0  CFE7     MOVFF INDF1, FSR2
21C2  FFD9     NOP
21C4  0012     RETURN 0
147:           
148:           /* 
149:           Проверка того, изменился ли параметр меню
150:           Возвращает:
151:           1 - изменился
152:           0 - не изменился 
153:           */
154:           BOOL M_Menu_parameter_is_changed(uint8_t* menu_param, uint8_t num_page)
21C6  CFD9     MOVFF FSR2, POSTINC1
21C8  FFE6     NOP
21CA  CFE1     MOVFF FSR1, FSR2
21CC  FFD9     NOP
155:           {
156:           	return (M_Menu_src_param_menu != menu_param[num_page]);	
21CE  0EFC     MOVLW 0xFC
21D0  50DB     MOVF PLUSW2, W, ACCESS
21D2  6EE7     MOVWF INDF1, ACCESS
21D4  0EFD     MOVLW 0xFD
21D6  CFDB     MOVFF PLUSW2, FSR0
21D8  FFE9     NOP
21DA  0EFE     MOVLW 0xFE
21DC  CFDB     MOVFF PLUSW2, FSR0H
21DE  FFEA     NOP
21E0  50E7     MOVF INDF1, W, ACCESS
21E2  26E9     ADDWF FSR0, F, ACCESS
21E4  0E00     MOVLW 0x0
21E6  22EA     ADDWFC FSR0H, F, ACCESS
21E8  50EF     MOVF INDF0, W, ACCESS
21EA  0101     MOVLB 0x1
21EC  5D10     SUBWF 0x10, W, BANKED
21EE  E102     BNZ 0x21F4
21F0  0E00     MOVLW 0x0
21F2  D001     BRA 0x21F6
21F4  0E01     MOVLW 0x1
21F6  D000     BRA 0x21F8
157:           }
21F8  52E5     MOVF POSTDEC1, F, ACCESS
21FA  CFE7     MOVFF INDF1, FSR2
21FC  FFD9     NOP
21FE  0012     RETURN 0
158:           
159:           /* Функция сохранения параметра меню, если он изменился */
160:           void M_Menu_write_parameter(uint8_t* menu_param, uint8_t num_page)
2200  CFD9     MOVFF FSR2, POSTINC1
2202  FFE6     NOP
2204  CFE1     MOVFF FSR1, FSR2
2206  FFD9     NOP
161:           {
162:           	if(M_Menu_parameter_is_changed(menu_param, num_page))
2208  0EFC     MOVLW 0xFC
220A  CFDB     MOVFF PLUSW2, POSTINC1
220C  FFE6     NOP
220E  0EFD     MOVLW 0xFD
2210  CFDB     MOVFF PLUSW2, POSTINC1
2212  FFE6     NOP
2214  0EFE     MOVLW 0xFE
2216  CFDB     MOVFF PLUSW2, POSTINC1
2218  FFE6     NOP
221A  DFD5     RCALL M_Menu_parameter_is_changed
221C  52E5     MOVF POSTDEC1, F, ACCESS
221E  52E5     MOVF POSTDEC1, F, ACCESS
2220  52E5     MOVF POSTDEC1, F, ACCESS
2222  0900     IORLW 0x0
2224  E018     BZ 0x2256
163:           		DataEEWrite (menu_param[num_page], num_page );
2226  0EFC     MOVLW 0xFC
2228  CFDB     MOVFF PLUSW2, POSTINC1
222A  FFE6     NOP
222C  0EFC     MOVLW 0xFC
222E  50DB     MOVF PLUSW2, W, ACCESS
2230  6EE7     MOVWF INDF1, ACCESS
2232  0EFD     MOVLW 0xFD
2234  CFDB     MOVFF PLUSW2, FSR0
2236  FFE9     NOP
2238  0EFE     MOVLW 0xFE
223A  CFDB     MOVFF PLUSW2, FSR0H
223C  FFEA     NOP
223E  50E7     MOVF INDF1, W, ACCESS
2240  26E9     ADDWF FSR0, F, ACCESS
2242  0E00     MOVLW 0x0
2244  22EA     ADDWFC FSR0H, F, ACCESS
2246  50EF     MOVF INDF0, W, ACCESS
2248  6EE6     MOVWF POSTINC1, ACCESS
224A  6AE6     CLRF POSTINC1, ACCESS
224C  EC0E     CALL 0x3E1C, 0
224E  F01F     NOP
2250  52E5     MOVF POSTDEC1, F, ACCESS
2252  52E5     MOVF POSTDEC1, F, ACCESS
2254  52E5     MOVF POSTDEC1, F, ACCESS
164:           }
2256  52E5     MOVF POSTDEC1, F, ACCESS
2258  CFE7     MOVFF INDF1, FSR2
225A  FFD9     NOP
225C  0012     RETURN 0
165:           
166:           
167:           void M_Menu_entry_rotation_clean_chimney(void)
168:           {	M_Ind_Set_Previous_State(M_Ind_Get_state());
225E  ECA3     CALL 0x2B46, 0
2260  F015     NOP
2262  6EE6     MOVWF POSTINC1, ACCESS
2264  EC8D     CALL 0x2B1A, 0
2266  F015     NOP
2268  52E5     MOVF POSTDEC1, F, ACCESS
169:           	M_Ind_Set_state(STATE_VIEW_CLEAN_CHIMNEY);
226A  0E06     MOVLW 0x6
226C  6EE6     MOVWF POSTINC1, ACCESS
226E  EC98     CALL 0x2B30, 0
2270  F015     NOP
2272  52E5     MOVF POSTDEC1, F, ACCESS
170:           	M_Mngm_Set_state(STATE_CLEAN_CHIMNEY);
2274  0E04     MOVLW 0x4
2276  6EE6     MOVWF POSTINC1, ACCESS
2278  EC98     CALL 0x1530, 0
227A  F00A     NOP
227C  52E5     MOVF POSTDEC1, F, ACCESS
171:           	M_Ind_Set_blink_mode(NO_NEED_BLINK);
227E  6AE6     CLRF POSTINC1, ACCESS
2280  EC7E     CALL 0x2AFC, 0
2282  F015     NOP
2284  52E5     MOVF POSTDEC1, F, ACCESS
172:           	M_Motor_set_state(STATE_MODULE_MOTOR_WAITING_FOR_MOVE_CLEAN_CHIMNEY);
2286  0E05     MOVLW 0x5
2288  6EE6     MOVWF POSTINC1, ACCESS
228A  EC00     CALL 0x200, 0
228C  F001     NOP
228E  52E5     MOVF POSTDEC1, F, ACCESS
173:           	M_Motor_set_ctrl_shatter(WAITING_MOVEMENT);
2290  0E03     MOVLW 0x3
2292  6EE6     MOVWF POSTINC1, ACCESS
2294  EC22     CALL 0x244, 0
2296  F001     NOP
2298  52E5     MOVF POSTDEC1, F, ACCESS
174:           }
229A  0012     RETURN 0
175:           
176:           
177:           
178:           /* Обработчик нажатых кнопок 
179:           В зависимости от кода нажатой кнопки устанавливает переменную автомата состояний следущих модулей:
180:           - модуль управления 
181:           - модуль индикации 
182:           */
183:           void Menu_Key_handler(KeyState* key_str)
229C  CFD9     MOVFF FSR2, POSTINC1
229E  FFE6     NOP
22A0  CFE1     MOVFF FSR1, FSR2
22A2  FFD9     NOP
184:           {
185:           		
186:           	// Все длительные нажатия кнопок обрабатываются только в режиме ожидания
187:           	if ((((key_str->M_LI_Code_Key) & 0x01) == 1U) && 
22A4  0EFD     MOVLW 0xFD
22A6  CFDB     MOVFF PLUSW2, FSR0
22A8  FFE9     NOP
22AA  0EFE     MOVLW 0xFE
22AC  CFDB     MOVFF PLUSW2, FSR0H
22AE  FFEA     NOP
22B0  0E02     MOVLW 0x2
22B2  26E9     ADDWF FSR0, F, ACCESS
22B4  0E00     MOVLW 0x0
22B6  22EA     ADDWFC FSR0H, F, ACCESS
22B8  50EF     MOVF INDF0, W, ACCESS
22BA  0B01     ANDLW 0x1
22BC  0801     SUBLW 0x1
188:           	((M_Mngm_Get_state() == STATE_WAITING) || ((M_Mngm_Get_state() == STATE_BURNING) && ((key_str->M_LI_Code_Key & NO_KEY_PRESSED) 
22C2  ECA7     CALL 0x154E, 0
22C4  F00A     NOP
22C6  0900     IORLW 0x0
22CA  ECA7     CALL 0x154E, 0
22CC  F00A     NOP
22CE  0802     SUBLW 0x2
22D4  0EFD     MOVLW 0xFD
22D6  CFDB     MOVFF PLUSW2, FSR0
22D8  FFE9     NOP
22DA  0EFE     MOVLW 0xFE
22DC  CFDB     MOVFF PLUSW2, FSR0H
22DE  FFEA     NOP
22E0  0E02     MOVLW 0x2
22E2  26E9     ADDWF FSR0, F, ACCESS
22E4  0E00     MOVLW 0x0
22E6  22EA     ADDWFC FSR0H, F, ACCESS
22E8  50EF     MOVF INDF0, W, ACCESS
22EA  0B0F     ANDLW 0xF
189:           	== CODE_KEY_DEC_LONG__PRESSED)))) //произошло длительное нажатие какой-либо кнопки
22BE  E001     BZ 0x22C2
22C0  D09B     BRA 0x23F8
22C8  E014     BZ 0x22F2
22D0  E001     BZ 0x22D4
22D2  D092     BRA 0x23F8
22EC  080E     SUBLW 0xE
22EE  E001     BZ 0x22F2
22F0  D083     BRA 0x23F8
190:           	{
191:           		//M_Sound_set_button_submergence (ON);  //установить флаг подзвучки кнопки
192:           		switch ((key_str->M_LI_Code_Key) & NO_KEY_PRESSED)
22F2  0EFD     MOVLW 0xFD
22F4  CFDB     MOVFF PLUSW2, FSR0
22F6  FFE9     NOP
22F8  0EFE     MOVLW 0xFE
22FA  CFDB     MOVFF PLUSW2, FSR0H
22FC  FFEA     NOP
22FE  0E02     MOVLW 0x2
2300  26E9     ADDWF FSR0, F, ACCESS
2302  0E00     MOVLW 0x0
2304  22EA     ADDWFC FSR0H, F, ACCESS
2306  50EF     MOVF INDF0, W, ACCESS
2308  0B0F     ANDLW 0xF
230A  0A0E     XORLW 0xE
230C  E02B     BZ 0x2364
230E  0A09     XORLW 0x9
2310  E011     BZ 0x2334
2312  0A0C     XORLW 0xC
2314  E001     BZ 0x2318
2316  D064     BRA 0x23E0
193:           		{
194:           			case CODE_KEY_MENU_LONG__PRESSED:
195:           				
196:           					M_Ind_Set_Previous_State(M_Ind_Get_state());
2318  ECA3     CALL 0x2B46, 0
231A  F015     NOP
231C  6EE6     MOVWF POSTINC1, ACCESS
231E  EC8D     CALL 0x2B1A, 0
2320  F015     NOP
2322  52E5     MOVF POSTDEC1, F, ACCESS
197:           					M_Ind_Set_state(STATE_VIEW_NUM_PAGE_MENU);
2324  0E01     MOVLW 0x1
2326  6EE6     MOVWF POSTINC1, ACCESS
2328  EC98     CALL 0x2B30, 0
232A  F015     NOP
232C  52E5     MOVF POSTDEC1, F, ACCESS
198:           					Menu_Num_Page_Menu = 0;
232E  0101     MOVLB 0x1
2330  6B0F     CLRF 0xF, BANKED
199:           			break;
2332  D056     BRA 0x23E0
200:           			case CODE_KEY_INC_LONG__PRESSED:
201:           				M_Ind_Set_Previous_State(M_Ind_Get_state());
2334  ECA3     CALL 0x2B46, 0
2336  F015     NOP
2338  6EE6     MOVWF POSTINC1, ACCESS
233A  EC8D     CALL 0x2B1A, 0
233C  F015     NOP
233E  52E5     MOVF POSTDEC1, F, ACCESS
202:           				M_Ind_Set_state(STATE_VIEW_SUPPLY_FUEL);
2340  0E07     MOVLW 0x7
2342  6EE6     MOVWF POSTINC1, ACCESS
2344  EC98     CALL 0x2B30, 0
2346  F015     NOP
2348  52E5     MOVF POSTDEC1, F, ACCESS
203:           				M_Mngm_Set_state(STATE_FUEL_SUPPLY);
234A  0E01     MOVLW 0x1
234C  6EE6     MOVWF POSTINC1, ACCESS
234E  EC98     CALL 0x1530, 0
2350  F00A     NOP
2352  52E5     MOVF POSTDEC1, F, ACCESS
204:           				M_Ind_Set_blink_mode(NO_NEED_BLINK);
2354  6AE6     CLRF POSTINC1, ACCESS
2356  EC7E     CALL 0x2AFC, 0
2358  F015     NOP
235A  52E5     MOVF POSTDEC1, F, ACCESS
205:           				Menu_manual_supply = ON;
235C  0101     MOVLB 0x1
235E  0E01     MOVLW 0x1
2360  6F12     MOVWF 0x12, BANKED
206:           				break;	
2362  D03E     BRA 0x23E0
207:           			case CODE_KEY_DEC_LONG__PRESSED: //уловие перехода в режим чистки дымохода
208:           				if(M_Mngm_Get_state() == STATE_BURNING)
2364  ECA7     CALL 0x154E, 0
2366  F00A     NOP
2368  0802     SUBLW 0x2
236A  E109     BNZ 0x237E
209:           				{
210:           					temper_water_or_gas = !temper_water_or_gas;
236C  0101     MOVLB 0x1
236E  5111     MOVF 0x11, W, BANKED
2370  E002     BZ 0x2376
2372  0E00     MOVLW 0x0
2374  D001     BRA 0x2378
2376  0E01     MOVLW 0x1
2378  0101     MOVLB 0x1
237A  6F11     MOVWF 0x11, BANKED
211:           				}
212:           				else
237C  D030     BRA 0x23DE
213:           				{
214:           					if(M_AI_Get_ADC_Data(CHN_T_GAS)->param <=  MAX_TEMPER_GAS_SENSOR_FOR_CLEAN_CHIMNEY && 
237E  6AE6     CLRF POSTINC1, ACCESS
2380  EC3C     CALL 0x3478, 0
2382  F01A     NOP
2384  52E5     MOVF POSTDEC1, F, ACCESS
2386  CFF3     MOVFF PROD, FSR0
2388  FFE9     NOP
238A  CFF4     MOVFF PRODH, FSR0H
238C  FFEA     NOP
238E  0E05     MOVLW 0x5
2390  26E9     ADDWF FSR0, F, ACCESS
2392  0E00     MOVLW 0x0
2394  22EA     ADDWFC FSR0H, F, ACCESS
2396  50EF     MOVF INDF0, W, ACCESS
2398  0803     SUBLW 0x3
215:           					M_LI_Get_Limit_Switches()->ls_dispenser_start_state && M_LI_Get_Limit_Switches()->ls_shatter_start_state && 
239A  E321     BNC 0x23DE
239C  ECBD     CALL 0x3B7A, 0
239E  F01D     NOP
23A0  CFF3     MOVFF PROD, FSR0
23A2  FFE9     NOP
23A4  CFF4     MOVFF PRODH, FSR0H
23A6  FFEA     NOP
23A8  50EF     MOVF INDF0, W, ACCESS
23AA  E019     BZ 0x23DE
23AC  ECBD     CALL 0x3B7A, 0
23AE  F01D     NOP
23B0  CFF3     MOVFF PROD, FSR0
23B2  FFE9     NOP
23B4  CFF4     MOVFF PRODH, FSR0H
23B6  FFEA     NOP
23B8  0E02     MOVLW 0x2
23BA  26E9     ADDWF FSR0, F, ACCESS
23BC  0E00     MOVLW 0x0
23BE  22EA     ADDWFC FSR0H, F, ACCESS
23C0  50EF     MOVF INDF0, W, ACCESS
23C2  E00D     BZ 0x23DE
216:           					!M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state)
23C4  ECBD     CALL 0x3B7A, 0
23C6  F01D     NOP
23C8  CFF3     MOVFF PROD, FSR0
23CA  FFE9     NOP
23CC  CFF4     MOVFF PRODH, FSR0H
23CE  FFEA     NOP
23D0  0E04     MOVLW 0x4
23D2  26E9     ADDWF FSR0, F, ACCESS
23D4  0E00     MOVLW 0x0
23D6  22EA     ADDWFC FSR0H, F, ACCESS
23D8  50EF     MOVF INDF0, W, ACCESS
23DA  E101     BNZ 0x23DE
217:           					{
218:           						M_Menu_entry_rotation_clean_chimney();
23DC  DF40     RCALL M_Menu_entry_rotation_clean_chimney
219:           					}
220:           				}
221:           				break;	
23DE  D000     BRA 0x23E0
222:           		}
223:           		key_str->M_LI_Code_Key = 0;
23E0  0EFD     MOVLW 0xFD
23E2  CFDB     MOVFF PLUSW2, FSR0
23E4  FFE9     NOP
23E6  0EFE     MOVLW 0xFE
23E8  CFDB     MOVFF PLUSW2, FSR0H
23EA  FFEA     NOP
23EC  0E02     MOVLW 0x2
23EE  26E9     ADDWF FSR0, F, ACCESS
23F0  0E00     MOVLW 0x0
23F2  22EA     ADDWFC FSR0H, F, ACCESS
23F4  6AEF     CLRF INDF0, ACCESS
224:           	}
225:           	else if ((key_str->M_LI_Code_Key & 0x80) == 0x80) //произошло короткое нажатие какой-либо кнопки и её отпускание
23F6  D371     BRA 0x2ADA
23F8  0EFD     MOVLW 0xFD
23FA  CFDB     MOVFF PLUSW2, FSR0
23FC  FFE9     NOP
23FE  0EFE     MOVLW 0xFE
2400  CFDB     MOVFF PLUSW2, FSR0H
2402  FFEA     NOP
2404  0E02     MOVLW 0x2
2406  26E9     ADDWF FSR0, F, ACCESS
2408  0E00     MOVLW 0x0
240A  22EA     ADDWFC FSR0H, F, ACCESS
240C  50EF     MOVF INDF0, W, ACCESS
240E  0B80     ANDLW 0x80
2410  0880     SUBLW 0x80
2412  E001     BZ 0x2416
2414  D362     BRA 0x2ADA
226:           	{
227:           		switch ((key_str->M_LI_Code_Key) & NO_KEY_PRESSED)
2416  0EFD     MOVLW 0xFD
2418  CFDB     MOVFF PLUSW2, FSR0
241A  FFE9     NOP
241C  0EFE     MOVLW 0xFE
241E  CFDB     MOVFF PLUSW2, FSR0H
2420  FFEA     NOP
2422  0E02     MOVLW 0x2
2424  26E9     ADDWF FSR0, F, ACCESS
2426  0E00     MOVLW 0x0
2428  22EA     ADDWFC FSR0H, F, ACCESS
242A  50EF     MOVF INDF0, W, ACCESS
242C  0B0F     ANDLW 0xF
242E  0A0E     XORLW 0xE
2430  E101     BNZ 0x2434
2432  D2A2     BRA 0x2978
2434  0A09     XORLW 0x9
2436  E101     BNZ 0x243A
2438  D1D6     BRA 0x27E6
243A  0A0C     XORLW 0xC
243C  E001     BZ 0x2440
243E  D33D     BRA 0x2ABA
228:           		{
229:           			case CODE_KEY_MENU_PRESSED_AND_FREE:
230:           				switch(M_Ind_Get_state())
2440  ECA3     CALL 0x2B46, 0
2442  F015     NOP
2444  0A06     XORLW 0x6
2446  E041     BZ 0x24CA
2448  0A07     XORLW 0x7
244A  E021     BZ 0x248E
244C  0A03     XORLW 0x3
244E  E001     BZ 0x2452
2450  D05E     BRA 0x250E
231:           				{
232:           					case STATE_VIEW_PARAMETER_MENU:
233:           						M_Ind_Set_state(STATE_VIEW_NUM_PAGE_MENU);	
2452  0E01     MOVLW 0x1
2454  6EE6     MOVWF POSTINC1, ACCESS
2456  EC98     CALL 0x2B30, 0
2458  F015     NOP
245A  52E5     MOVF POSTDEC1, F, ACCESS
234:           						//Сохранение в ЕЕПРОМ параметра, если он изменился
235:           						M_Menu_write_parameter(M_Mngm_Get_parameters_buffer()->buffer, Menu_Num_Page_Menu);
245C  C10F     MOVFF Menu_Num_Page_Menu, POSTINC1
245E  FFE6     NOP
2460  EC8E     CALL 0x151C, 0
2462  F00A     NOP
2464  CFF3     MOVFF PROD, FSR0
2466  FFE9     NOP
2468  CFF4     MOVFF PRODH, FSR0H
246A  FFEA     NOP
246C  CFE9     MOVFF FSR0, __tmp_0
246E  F032     NOP
2470  CFEA     MOVFF FSR0H, 0x33
2472  F033     NOP
2474  C032     MOVFF __tmp_0, POSTINC1
2476  FFE6     NOP
2478  C033     MOVFF 0x33, POSTINC1
247A  FFE6     NOP
247C  DEC1     RCALL M_Menu_write_parameter
247E  52E5     MOVF POSTDEC1, F, ACCESS
2480  52E5     MOVF POSTDEC1, F, ACCESS
2482  52E5     MOVF POSTDEC1, F, ACCESS
236:           						M_Ind_setTimeAutoExit(0);
2484  6AE6     CLRF POSTINC1, ACCESS
2486  EC57     CALL 0x30AE, 0
2488  F018     NOP
248A  52E5     MOVF POSTDEC1, F, ACCESS
237:           						break;
248C  D040     BRA 0x250E
238:           					case STATE_VIEW_NUM_PAGE_MENU:
239:           						M_Ind_Set_state(STATE_VIEW_PARAMETER_MENU);
248E  0E02     MOVLW 0x2
2490  6EE6     MOVWF POSTINC1, ACCESS
2492  EC98     CALL 0x2B30, 0
2494  F015     NOP
2496  52E5     MOVF POSTDEC1, F, ACCESS
240:           						M_Menu_Set_src_param_menu(M_Mngm_Get_parameters_buffer()->buffer, Menu_Num_Page_Menu);
2498  C10F     MOVFF Menu_Num_Page_Menu, POSTINC1
249A  FFE6     NOP
249C  EC8E     CALL 0x151C, 0
249E  F00A     NOP
24A0  CFF3     MOVFF PROD, FSR0
24A2  FFE9     NOP
24A4  CFF4     MOVFF PRODH, FSR0H
24A6  FFEA     NOP
24A8  CFE9     MOVFF FSR0, __tmp_0
24AA  F032     NOP
24AC  CFEA     MOVFF FSR0H, 0x33
24AE  F033     NOP
24B0  C032     MOVFF __tmp_0, POSTINC1
24B2  FFE6     NOP
24B4  C033     MOVFF 0x33, POSTINC1
24B6  FFE6     NOP
24B8  DE4F     RCALL M_Menu_Set_src_param_menu
24BA  52E5     MOVF POSTDEC1, F, ACCESS
24BC  52E5     MOVF POSTDEC1, F, ACCESS
24BE  52E5     MOVF POSTDEC1, F, ACCESS
241:           						M_Ind_setTimeAutoExit(0);
24C0  6AE6     CLRF POSTINC1, ACCESS
24C2  EC57     CALL 0x30AE, 0
24C4  F018     NOP
24C6  52E5     MOVF POSTDEC1, F, ACCESS
242:           						break;
24C8  D022     BRA 0x250E
243:           					case STATE_VIEW_CLEAN_CHIMNEY:
244:           						if((M_Motor_get_ctrl_shatter() == WAITING_MOVEMENT/*NO_MOVEMENT*/) && M_LI_Get_Limit_Switches()->ls_shatter_start_state && !M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state)
24CA  EC2D     CALL 0x25A, 0
24CC  F001     NOP
24CE  0803     SUBLW 0x3
24D0  E11D     BNZ 0x250C
24D2  ECBD     CALL 0x3B7A, 0
24D4  F01D     NOP
24D6  CFF3     MOVFF PROD, FSR0
24D8  FFE9     NOP
24DA  CFF4     MOVFF PRODH, FSR0H
24DC  FFEA     NOP
24DE  0E02     MOVLW 0x2
24E0  26E9     ADDWF FSR0, F, ACCESS
24E2  0E00     MOVLW 0x0
24E4  22EA     ADDWFC FSR0H, F, ACCESS
24E6  50EF     MOVF INDF0, W, ACCESS
24E8  E011     BZ 0x250C
24EA  ECBD     CALL 0x3B7A, 0
24EC  F01D     NOP
24EE  CFF3     MOVFF PROD, FSR0
24F0  FFE9     NOP
24F2  CFF4     MOVFF PRODH, FSR0H
24F4  FFEA     NOP
24F6  0E04     MOVLW 0x4
24F8  26E9     ADDWF FSR0, F, ACCESS
24FA  0E00     MOVLW 0x0
24FC  22EA     ADDWFC FSR0H, F, ACCESS
24FE  50EF     MOVF INDF0, W, ACCESS
2500  E105     BNZ 0x250C
245:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
2502  0E03     MOVLW 0x3
2504  6EE6     MOVWF POSTINC1, ACCESS
2506  EC98     CALL 0x2B30, 0
2508  F015     NOP
250A  52E5     MOVF POSTDEC1, F, ACCESS
246:           						break;
250C  D000     BRA 0x250E
247:           				}
248:           				switch(M_Mngm_Get_state())
250E  ECA7     CALL 0x154E, 0
2510  F00A     NOP
2512  0A05     XORLW 0x5
2514  E101     BNZ 0x2518
2516  D12A     BRA 0x276C
2518  0A01     XORLW 0x1
251A  E101     BNZ 0x251E
251C  D0F8     BRA 0x270E
251E  0A06     XORLW 0x6
2520  E101     BNZ 0x2524
2522  D091     BRA 0x2646
2524  0A03     XORLW 0x3
2526  E101     BNZ 0x252A
2528  D07B     BRA 0x2620
252A  0A01     XORLW 0x1
252C  E001     BZ 0x2530
252E  D15A     BRA 0x27E4
249:           				{
250:           					case STATE_WAITING:
251:           						if((M_Ind_Get_state() !=  STATE_VIEW_TEMPERATURE_SETUP) && 
2530  ECA3     CALL 0x2B46, 0
2532  F015     NOP
2534  0804     SUBLW 0x4
252:           						(M_Ind_Get_state() !=  STATE_VIEW_SPEED_FAN_SETUP)
2538  ECA3     CALL 0x2B46, 0
253A  F015     NOP
253C  0809     SUBLW 0x9
253:           						&&(M_Ind_Get_state() !=  STATE_VIEW_PARAMETER_MENU) && 
2536  E027     BZ 0x2586
253E  E023     BZ 0x2586
2540  ECA3     CALL 0x2B46, 0
2542  F015     NOP
2544  0802     SUBLW 0x2
2546  E01F     BZ 0x2586
254:           						(M_Ind_Get_state() !=  STATE_VIEW_NUM_PAGE_MENU) && !M_Motor_get_work() /* && (M_Ind_Get_state() != STATE_VIEW_CLEAN_CHIMNEY) */)
2548  ECA3     CALL 0x2B46, 0
254A  F015     NOP
254C  0801     SUBLW 0x1
254E  E01B     BZ 0x2586
2550  EC1A     CALL 0x234, 0
2552  F001     NOP
2554  0900     IORLW 0x0
2556  E117     BNZ 0x2586
255:           						{
256:           								M_Mngm_Set_state(STATE_BURNING);
2558  0E02     MOVLW 0x2
255A  6EE6     MOVWF POSTINC1, ACCESS
255C  EC98     CALL 0x1530, 0
255E  F00A     NOP
2560  52E5     MOVF POSTDEC1, F, ACCESS
257:           								M_Mngm_set_saved_temperature_water(M_AI_Get_ADC_Data(CHN_T_WATER)->param);
2562  0E01     MOVLW 0x1
2564  6EE6     MOVWF POSTINC1, ACCESS
2566  EC3C     CALL 0x3478, 0
2568  F01A     NOP
256A  52E5     MOVF POSTDEC1, F, ACCESS
256C  CFF3     MOVFF PROD, FSR0
256E  FFE9     NOP
2570  CFF4     MOVFF PRODH, FSR0H
2572  FFEA     NOP
2574  0E05     MOVLW 0x5
2576  26E9     ADDWF FSR0, F, ACCESS
2578  0E00     MOVLW 0x0
257A  22EA     ADDWFC FSR0H, F, ACCESS
257C  50EF     MOVF INDF0, W, ACCESS
257E  6EE6     MOVWF POSTINC1, ACCESS
2580  EC66     CALL 0x14CC, 0
2582  F00A     NOP
2584  52E5     MOVF POSTDEC1, F, ACCESS
258:           						}
259:           						if((M_Ind_Get_state() ==  STATE_VIEW_PARAMETER_MENU) ||
2586  ECA3     CALL 0x2B46, 0
2588  F015     NOP
258A  0802     SUBLW 0x2
260:           							(M_Ind_Get_state() ==  STATE_VIEW_NUM_PAGE_MENU))
258C  E004     BZ 0x2596
258E  ECA3     CALL 0x2B46, 0
2590  F015     NOP
2592  0801     SUBLW 0x1
2594  E102     BNZ 0x259A
261:           							break;	
2596  D126     BRA 0x27E4
262:           						else
2598  D042     BRA 0x261E
263:           						{
264:           							if(M_Ind_Get_state() ==  STATE_VIEW_TEMPERATURE_SETUP)
259A  ECA3     CALL 0x2B46, 0
259C  F015     NOP
259E  0804     SUBLW 0x4
25A0  E11B     BNZ 0x25D8
265:           								M_Menu_write_changed_param(INDEX_OF_TEMPER_SETUP, 
25CA  0E23     MOVLW 0x23
25CC  6EE6     MOVWF POSTINC1, ACCESS
266:           								  	DataEERead (INDEX_OF_TEMPER_SETUP), M_Mngm_Get_parameters_buffer()->menu_parameters.temper_setup);
25A2  EC8E     CALL 0x151C, 0
25A4  F00A     NOP
25A6  CFF3     MOVFF PROD, FSR0
25A8  FFE9     NOP
25AA  CFF4     MOVFF PRODH, FSR0H
25AC  FFEA     NOP
25AE  0E27     MOVLW 0x27
25B0  26E9     ADDWF FSR0, F, ACCESS
25B2  0E00     MOVLW 0x0
25B4  22EA     ADDWFC FSR0H, F, ACCESS
25B6  50EF     MOVF INDF0, W, ACCESS
25B8  6EE6     MOVWF POSTINC1, ACCESS
25BA  0E23     MOVLW 0x23
25BC  6EE6     MOVWF POSTINC1, ACCESS
25BE  6AE6     CLRF POSTINC1, ACCESS
25C0  ECD5     CALL 0x3DAA, 0
25C2  F01E     NOP
25C4  52E5     MOVF POSTDEC1, F, ACCESS
25C6  52E5     MOVF POSTDEC1, F, ACCESS
25C8  6EE6     MOVWF POSTINC1, ACCESS
25CE  DDDB     RCALL M_Menu_write_changed_param
25D0  52E5     MOVF POSTDEC1, F, ACCESS
25D2  52E5     MOVF POSTDEC1, F, ACCESS
25D4  52E5     MOVF POSTDEC1, F, ACCESS
267:           							else if (M_Ind_Get_state() ==  STATE_VIEW_SPEED_FAN_SETUP)
25D6  D01E     BRA 0x2614
25D8  ECA3     CALL 0x2B46, 0
25DA  F015     NOP
25DC  0809     SUBLW 0x9
25DE  E11A     BNZ 0x2614
268:           								M_Menu_write_changed_param( INDEX_OF_LEVEL_FAN_ROTATION_SPEED_INCREASE, 
2608  0E2B     MOVLW 0x2B
260A  6EE6     MOVWF POSTINC1, ACCESS
269:           						  		DataEERead ( INDEX_OF_LEVEL_FAN_ROTATION_SPEED_INCREASE), M_Mngm_Get_parameters_buffer()->menu_parameters.rotational_speed_fan);		
25E0  EC8E     CALL 0x151C, 0
25E2  F00A     NOP
25E4  CFF3     MOVFF PROD, FSR0
25E6  FFE9     NOP
25E8  CFF4     MOVFF PRODH, FSR0H
25EA  FFEA     NOP
25EC  0E2F     MOVLW 0x2F
25EE  26E9     ADDWF FSR0, F, ACCESS
25F0  0E00     MOVLW 0x0
25F2  22EA     ADDWFC FSR0H, F, ACCESS
25F4  50EF     MOVF INDF0, W, ACCESS
25F6  6EE6     MOVWF POSTINC1, ACCESS
25F8  0E2B     MOVLW 0x2B
25FA  6EE6     MOVWF POSTINC1, ACCESS
25FC  6AE6     CLRF POSTINC1, ACCESS
25FE  ECD5     CALL 0x3DAA, 0
2600  F01E     NOP
2602  52E5     MOVF POSTDEC1, F, ACCESS
2604  52E5     MOVF POSTDEC1, F, ACCESS
2606  6EE6     MOVWF POSTINC1, ACCESS
260C  DDBC     RCALL M_Menu_write_changed_param
260E  52E5     MOVF POSTDEC1, F, ACCESS
2610  52E5     MOVF POSTDEC1, F, ACCESS
2612  52E5     MOVF POSTDEC1, F, ACCESS
270:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
2614  0E03     MOVLW 0x3
2616  6EE6     MOVWF POSTINC1, ACCESS
2618  EC98     CALL 0x2B30, 0
261A  F015     NOP
261C  52E5     MOVF POSTDEC1, F, ACCESS
271:           						}
272:           						break;
261E  D0E2     BRA 0x27E4
273:           					case STATE_FUEL_SUPPLY:
274:           						if(M_Motor_get_state() == STATE_MODULE_MOTOR_WAITING)  //из рабочего кода
2620  EC1E     CALL 0x23C, 0
2622  F001     NOP
2624  0801     SUBLW 0x1
2626  E10E     BNZ 0x2644
275:           						{
276:           							M_Mngm_Set_state(STATE_BURNING);
2628  0E02     MOVLW 0x2
262A  6EE6     MOVWF POSTINC1, ACCESS
262C  EC98     CALL 0x1530, 0
262E  F00A     NOP
2630  52E5     MOVF POSTDEC1, F, ACCESS
277:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL); //добавил
2632  0E03     MOVLW 0x3
2634  6EE6     MOVWF POSTINC1, ACCESS
2636  EC98     CALL 0x2B30, 0
2638  F015     NOP
263A  52E5     MOVF POSTDEC1, F, ACCESS
278:           							M_Motor_clear_parameters();
263C  EC5D     CALL 0xBA, 0
263E  F000     NOP
279:           							Menu_manual_supply = OFF;
2640  0101     MOVLB 0x1
2642  6B12     CLRF 0x12, BANKED
280:           						}
281:           						break;
2644  D0CF     BRA 0x27E4
282:           					case STATE_BURNING:
283:           						if(M_Ind_Get_state() !=  STATE_VIEW_TEMPERATURE_SETUP && 
2646  ECA3     CALL 0x2B46, 0
2648  F015     NOP
264A  0804     SUBLW 0x4
284:           							M_Ind_Get_state() !=  STATE_VIEW_SPEED_FAN_SETUP && M_Motor_get_state() == STATE_MODULE_MOTOR_WAITING )
264C  E01B     BZ 0x2684
264E  ECA3     CALL 0x2B46, 0
2650  F015     NOP
2652  0809     SUBLW 0x9
2654  E017     BZ 0x2684
2656  EC1E     CALL 0x23C, 0
2658  F001     NOP
265A  0801     SUBLW 0x1
265C  E113     BNZ 0x2684
285:           						{	
286:           							M_fan_set_ctrl_fan(OFF);
265E  6AE6     CLRF POSTINC1, ACCESS
2660  ECE0     CALL 0x41C0, 0
2662  F020     NOP
2664  52E5     MOVF POSTDEC1, F, ACCESS
287:           							M_Mngm_Set_state(STATE_WAITING);
2666  6AE6     CLRF POSTINC1, ACCESS
2668  EC98     CALL 0x1530, 0
266A  F00A     NOP
266C  52E5     MOVF POSTDEC1, F, ACCESS
288:           							M_Mngm_clear_timeouts();
266E  EC71     CALL 0x14E2, 0
2670  F00A     NOP
289:           							M_Mngm_clear_accel_fan();
2672  ECE5     CALL 0x1DCA, 0
2674  F00E     NOP
290:           							M_Mngm_clear_cyclic_mode();
2676  ECEB     CALL 0x1DD6, 0
2678  F00E     NOP
291:           							M_Mngm_set_burning_state(CALC_PARAMS_PERIOD);
267A  6AE6     CLRF POSTINC1, ACCESS
267C  EC83     CALL 0x1506, 0
267E  F00A     NOP
2680  52E5     MOVF POSTDEC1, F, ACCESS
292:           						}
293:           						else
2682  D044     BRA 0x270C
294:           						{
295:           							if(M_Ind_Get_state() ==  STATE_VIEW_TEMPERATURE_SETUP)
2684  ECA3     CALL 0x2B46, 0
2686  F015     NOP
2688  0804     SUBLW 0x4
268A  E11B     BNZ 0x26C2
296:           								M_Menu_write_changed_param(INDEX_OF_TEMPER_SETUP, 
26B4  0E23     MOVLW 0x23
26B6  6EE6     MOVWF POSTINC1, ACCESS
297:           								DataEERead (INDEX_OF_TEMPER_SETUP), M_Mngm_Get_parameters_buffer()->menu_parameters.temper_setup);
268C  EC8E     CALL 0x151C, 0
268E  F00A     NOP
2690  CFF3     MOVFF PROD, FSR0
2692  FFE9     NOP
2694  CFF4     MOVFF PRODH, FSR0H
2696  FFEA     NOP
2698  0E27     MOVLW 0x27
269A  26E9     ADDWF FSR0, F, ACCESS
269C  0E00     MOVLW 0x0
269E  22EA     ADDWFC FSR0H, F, ACCESS
26A0  50EF     MOVF INDF0, W, ACCESS
26A2  6EE6     MOVWF POSTINC1, ACCESS
26A4  0E23     MOVLW 0x23
26A6  6EE6     MOVWF POSTINC1, ACCESS
26A8  6AE6     CLRF POSTINC1, ACCESS
26AA  ECD5     CALL 0x3DAA, 0
26AC  F01E     NOP
26AE  52E5     MOVF POSTDEC1, F, ACCESS
26B0  52E5     MOVF POSTDEC1, F, ACCESS
26B2  6EE6     MOVWF POSTINC1, ACCESS
26B8  DD66     RCALL M_Menu_write_changed_param
26BA  52E5     MOVF POSTDEC1, F, ACCESS
26BC  52E5     MOVF POSTDEC1, F, ACCESS
26BE  52E5     MOVF POSTDEC1, F, ACCESS
298:           							else if (M_Ind_Get_state() ==  STATE_VIEW_SPEED_FAN_SETUP)
26C0  D020     BRA 0x2702
26C2  ECA3     CALL 0x2B46, 0
26C4  F015     NOP
26C6  0809     SUBLW 0x9
26C8  E11C     BNZ 0x2702
299:           							{
300:           								M_Menu_write_changed_param(M_Mngm_get_fanParamOffset() >> 1, 
26F0  EC08     CALL 0x1410, 0
26F2  F00A     NOP
26F4  40E8     RRNCF WREG, W, ACCESS
26F6  0B7F     ANDLW 0x7F
26F8  6EE6     MOVWF POSTINC1, ACCESS
301:           						  		DataEERead (M_Mngm_get_fanParamOffset() >> 1), *M_Mngm_get_pFanLevel());
26CA  EC0C     CALL 0x1418, 0
26CC  F00A     NOP
26CE  CFF3     MOVFF PROD, FSR0
26D0  FFE9     NOP
26D2  CFF4     MOVFF PRODH, FSR0H
26D4  FFEA     NOP
26D6  50EF     MOVF INDF0, W, ACCESS
26D8  6EE6     MOVWF POSTINC1, ACCESS
26DA  EC08     CALL 0x1410, 0
26DC  F00A     NOP
26DE  40E8     RRNCF WREG, W, ACCESS
26E0  0B7F     ANDLW 0x7F
26E2  6EE6     MOVWF POSTINC1, ACCESS
26E4  6AE6     CLRF POSTINC1, ACCESS
26E6  ECD5     CALL 0x3DAA, 0
26E8  F01E     NOP
26EA  52E5     MOVF POSTDEC1, F, ACCESS
26EC  52E5     MOVF POSTDEC1, F, ACCESS
26EE  6EE6     MOVWF POSTINC1, ACCESS
26FA  DD45     RCALL M_Menu_write_changed_param
26FC  52E5     MOVF POSTDEC1, F, ACCESS
26FE  52E5     MOVF POSTDEC1, F, ACCESS
2700  52E5     MOVF POSTDEC1, F, ACCESS
302:           							}
303:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
2702  0E03     MOVLW 0x3
2704  6EE6     MOVWF POSTINC1, ACCESS
2706  EC98     CALL 0x2B30, 0
2708  F015     NOP
270A  52E5     MOVF POSTDEC1, F, ACCESS
304:           						}
305:           						break;
270C  D06B     BRA 0x27E4
306:           					case STATE_CLEAN_CHIMNEY:
307:           						if(M_LI_Get_Limit_Switches()->ls_shatter_start_state && !M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state)  //если заслонка закрыта
270E  ECBD     CALL 0x3B7A, 0
2710  F01D     NOP
2712  CFF3     MOVFF PROD, FSR0
2714  FFE9     NOP
2716  CFF4     MOVFF PRODH, FSR0H
2718  FFEA     NOP
271A  0E02     MOVLW 0x2
271C  26E9     ADDWF FSR0, F, ACCESS
271E  0E00     MOVLW 0x0
2720  22EA     ADDWFC FSR0H, F, ACCESS
2722  50EF     MOVF INDF0, W, ACCESS
2724  E022     BZ 0x276A
2726  ECBD     CALL 0x3B7A, 0
2728  F01D     NOP
272A  CFF3     MOVFF PROD, FSR0
272C  FFE9     NOP
272E  CFF4     MOVFF PRODH, FSR0H
2730  FFEA     NOP
2732  0E04     MOVLW 0x4
2734  26E9     ADDWF FSR0, F, ACCESS
2736  0E00     MOVLW 0x0
2738  22EA     ADDWFC FSR0H, F, ACCESS
273A  50EF     MOVF INDF0, W, ACCESS
273C  E116     BNZ 0x276A
308:           						{
309:           							M_Mngm_Set_state(STATE_WAITING);
273E  6AE6     CLRF POSTINC1, ACCESS
2740  EC98     CALL 0x1530, 0
2742  F00A     NOP
2744  52E5     MOVF POSTDEC1, F, ACCESS
310:           							M_Motor_set_ctrl_shatter(NO_MOVEMENT);
2746  6AE6     CLRF POSTINC1, ACCESS
2748  EC22     CALL 0x244, 0
274A  F001     NOP
274C  52E5     MOVF POSTDEC1, F, ACCESS
311:           							M_Ind_Set_blink_mode(NO_NEED_BLINK);
274E  6AE6     CLRF POSTINC1, ACCESS
2750  EC7E     CALL 0x2AFC, 0
2752  F015     NOP
2754  52E5     MOVF POSTDEC1, F, ACCESS
312:           							M_Motor_set_state(STATE_MODULE_MOTOR_WAITING);
2756  0E01     MOVLW 0x1
2758  6EE6     MOVWF POSTINC1, ACCESS
275A  EC00     CALL 0x200, 0
275C  F001     NOP
275E  52E5     MOVF POSTDEC1, F, ACCESS
313:           							M_Ind_Set_state(STATE_VIEW_TEMPERATURE_REAL);
2760  0E03     MOVLW 0x3
2762  6EE6     MOVWF POSTINC1, ACCESS
2764  EC98     CALL 0x2B30, 0
2766  F015     NOP
2768  52E5     MOVF POSTDEC1, F, ACCESS
314:           						}
315:           						break;
276A  D03C     BRA 0x27E4
316:           					case STATE_FAILURE: 	//при аварии сбросить код аварии
317:           						M_Mngm_Set_Code_Failure(CODE_FAILURE_IS_NO_FAILURE);
276C  6AE6     CLRF POSTINC1, ACCESS
276E  ECAF     CALL 0x155E, 0
2770  F00A     NOP
2772  52E5     MOVF POSTDEC1, F, ACCESS
318:           						M_Mngm_Get_parameters_buffer()->menu_parameters.code_failure = CODE_FAILURE_IS_NO_FAILURE;
2774  EC8E     CALL 0x151C, 0
2776  F00A     NOP
2778  CFF3     MOVFF PROD, FSR0
277A  FFE9     NOP
277C  CFF4     MOVFF PRODH, FSR0H
277E  FFEA     NOP
2780  0E32     MOVLW 0x32
2782  26E9     ADDWF FSR0, F, ACCESS
2784  0E00     MOVLW 0x0
2786  22EA     ADDWFC FSR0H, F, ACCESS
2788  6AEF     CLRF INDF0, ACCESS
319:           						DataEEWrite (CODE_FAILURE_IS_NO_FAILURE, INDEX_OF_CODE_FAILURE );
278A  0E2E     MOVLW 0x2E
278C  6EE6     MOVWF POSTINC1, ACCESS
278E  0E00     MOVLW 0x0
2790  6EE6     MOVWF POSTINC1, ACCESS
2792  6AE6     CLRF POSTINC1, ACCESS
2794  EC0E     CALL 0x3E1C, 0
2796  F01F     NOP
2798  52E5     MOVF POSTDEC1, F, ACCESS
279A  52E5     MOVF POSTDEC1, F, ACCESS
279C  52E5     MOVF POSTDEC1, F, ACCESS
320:           						M_Ind_Set_state( M_Ind_Get_Previous_State());
279E  EC89     CALL 0x2B12, 0
27A0  F015     NOP
27A2  6EE6     MOVWF POSTINC1, ACCESS
27A4  EC98     CALL 0x2B30, 0
27A6  F015     NOP
27A8  52E5     MOVF POSTDEC1, F, ACCESS
321:           						M_Motor_clear_struct_failure_motor();
27AA  EC48     CALL 0x290, 0
27AC  F001     NOP
322:           						M_Motor_clear_false_state_LS(QUANTITY_FALSE_LS);
27AE  0E07     MOVLW 0x7
27B0  6EE6     MOVWF POSTINC1, ACCESS
27B2  ECC6     CALL 0x18C, 0
27B4  F000     NOP
27B6  52E5     MOVF POSTDEC1, F, ACCESS
323:           						M_Mngm_Set_state_draught(IS_DRAUGHT);
27B8  0E01     MOVLW 0x1
27BA  6EE6     MOVWF POSTINC1, ACCESS
27BC  ECBA     CALL 0x1574, 0
27BE  F00A     NOP
27C0  52E5     MOVF POSTDEC1, F, ACCESS
324:           						if(M_Motor_get_prev_state() == STATE_MODULE_MOTOR_CLEAN_CHIMNEY)
27C2  EC7D     CALL 0x2FA, 0
27C4  F001     NOP
27C6  0804     SUBLW 0x4
27C8  E106     BNZ 0x27D6
325:           						{
326:           							M_Motor_set_state(STATE_MODULE_MOTOR_CLEAN_CHIMNEY);
27CA  0E04     MOVLW 0x4
27CC  6EE6     MOVWF POSTINC1, ACCESS
27CE  EC00     CALL 0x200, 0
27D0  F001     NOP
27D2  52E5     MOVF POSTDEC1, F, ACCESS
327:           						}
328:           						else
27D4  D006     BRA 0x27E2
329:           						{
330:           							M_Motor_set_state(M_Motor_get_prev_state());
27D6  EC7D     CALL 0x2FA, 0
27D8  F001     NOP
27DA  6EE6     MOVWF POSTINC1, ACCESS
27DC  EC00     CALL 0x200, 0
27DE  F001     NOP
27E0  52E5     MOVF POSTDEC1, F, ACCESS
331:           						}
332:           						//M_Ind_Set_blink_mode(NO_NEED_BLINK);
333:           						break;
27E2  D000     BRA 0x27E4
334:           				}
335:           			break;
27E4  D16A     BRA 0x2ABA
336:           			case CODE_KEY_INC_PRESSED_AND_FREE:   
337:           				switch(M_Ind_Get_state())
27E6  ECA3     CALL 0x2B46, 0
27E8  F015     NOP
27EA  0A06     XORLW 0x6
27EC  E101     BNZ 0x27F0
27EE  D0A1     BRA 0x2932
27F0  0A0F     XORLW 0xF
27F2  E101     BNZ 0x27F6
27F4  D07F     BRA 0x28F4
27F6  0A0E     XORLW 0xE
27F8  E072     BZ 0x28DE
27FA  0A03     XORLW 0x3
27FC  E051     BZ 0x28A0
27FE  0A06     XORLW 0x6
2800  E033     BZ 0x2868
2802  0A03     XORLW 0x3
2804  E009     BZ 0x2818
2806  0A02     XORLW 0x2
2808  E001     BZ 0x280C
280A  D0B5     BRA 0x2976
338:           				{
339:           					case STATE_VIEW_TEMPERATURE_REAL:  	//просмотр текущей температуры
340:           						M_Ind_Set_state(STATE_VIEW_TEMPERATURE_SETUP);
280C  0E04     MOVLW 0x4
280E  6EE6     MOVWF POSTINC1, ACCESS
2810  EC98     CALL 0x2B30, 0
2812  F015     NOP
2814  52E5     MOVF POSTDEC1, F, ACCESS
341:           						break;
2816  D0AF     BRA 0x2976
342:           					case STATE_VIEW_NUM_PAGE_MENU:  		//увеличение номера страницы сервисного меню
343:           						M_Ind_setTimeAutoExit(0);
2818  6AE6     CLRF POSTINC1, ACCESS
281A  EC57     CALL 0x30AE, 0
281C  F018     NOP
281E  52E5     MOVF POSTDEC1, F, ACCESS
344:           						Menu_inc_param(&Menu_Num_Page_Menu, QUANTITY_OF_MENU_PARAMETERS);
2820  0E7A     MOVLW 0x7A
2822  6EF6     MOVWF TBLPTR, ACCESS
2824  0E4B     MOVLW 0x4B
2826  6EF7     MOVWF TBLPTRH, ACCESS
2828  0008     TBLRD*
282A  50F5     MOVF TABLAT, W, ACCESS
282C  6E34     MOVWF 0x34, ACCESS
282E  6A35     CLRF 0x35, ACCESS
2830  0E64     MOVLW 0x64
2832  6E26     MOVWF 0x26, ACCESS
2834  6A27     CLRF 0x27, ACCESS
2836  C034     MOVFF 0x34, 0x2B
2838  F02B     NOP
283A  C035     MOVFF 0x35, 0x2C
283C  F02C     NOP
283E  ECA2     CALL 0x4D44, 0
2840  F026     NOP
2842  C026     MOVFF 0x26, __tmp_0
2844  F032     NOP
2846  C027     MOVFF 0x27, 0x33
2848  F033     NOP
284A  0632     DECF __tmp_0, F, ACCESS
284C  0E00     MOVLW 0x0
284E  5A33     SUBWFB 0x33, F, ACCESS
2850  5032     MOVF __tmp_0, W, ACCESS
2852  6EE6     MOVWF POSTINC1, ACCESS
2854  0E0F     MOVLW 0xF
2856  6EE6     MOVWF POSTINC1, ACCESS
2858  0E01     MOVLW 0x1
285A  6EE6     MOVWF POSTINC1, ACCESS
285C  EC28     CALL 0x2050, 0
285E  F010     NOP
2860  52E5     MOVF POSTDEC1, F, ACCESS
2862  52E5     MOVF POSTDEC1, F, ACCESS
2864  52E5     MOVF POSTDEC1, F, ACCESS
345:           					break;
2866  D087     BRA 0x2976
346:           					case STATE_VIEW_PARAMETER_MENU: 	 //увеличение параметра сервисного меню
347:           						M_Ind_setTimeAutoExit(0);
2868  6AE6     CLRF POSTINC1, ACCESS
286A  EC57     CALL 0x30AE, 0
286C  F018     NOP
286E  52E5     MOVF POSTDEC1, F, ACCESS
348:           						Menu_item_change(M_Mngm_Get_parameters_buffer()->buffer, Menu_Num_Page_Menu, INCREMENT); 
2870  0E01     MOVLW 0x1
2872  6EE6     MOVWF POSTINC1, ACCESS
2874  C10F     MOVFF Menu_Num_Page_Menu, POSTINC1
2876  FFE6     NOP
2878  EC8E     CALL 0x151C, 0
287A  F00A     NOP
287C  CFF3     MOVFF PROD, FSR0
287E  FFE9     NOP
2880  CFF4     MOVFF PRODH, FSR0H
2882  FFEA     NOP
2884  CFE9     MOVFF FSR0, __tmp_0
2886  F032     NOP
2888  CFEA     MOVFF FSR0H, 0x33
288A  F033     NOP
288C  C032     MOVFF __tmp_0, POSTINC1
288E  FFE6     NOP
2890  C033     MOVFF 0x33, POSTINC1
2892  FFE6     NOP
2894  DC14     RCALL Menu_item_change
2896  52E5     MOVF POSTDEC1, F, ACCESS
2898  52E5     MOVF POSTDEC1, F, ACCESS
289A  52E5     MOVF POSTDEC1, F, ACCESS
289C  52E5     MOVF POSTDEC1, F, ACCESS
349:           					break;
289E  D06B     BRA 0x2976
350:           					case STATE_VIEW_TEMPERATURE_SETUP: 	//установка температуры
351:           						Menu_inc_param(&(M_Mngm_Get_parameters_buffer()->menu_parameters.temper_setup), 
28AE  EC8E     CALL 0x151C, 0
28B0  F00A     NOP
28B2  CFF3     MOVFF PROD, FSR0
28B4  FFE9     NOP
28B6  CFF4     MOVFF PRODH, FSR0H
28B8  FFEA     NOP
28BA  0E27     MOVLW 0x27
28BC  26E9     ADDWF FSR0, F, ACCESS
28BE  0E00     MOVLW 0x0
28C0  22EA     ADDWFC FSR0H, F, ACCESS
28C2  CFE9     MOVFF FSR0, __tmp_0
28C4  F032     NOP
28C6  CFEA     MOVFF FSR0H, 0x33
28C8  F033     NOP
28CA  C032     MOVFF __tmp_0, POSTINC1
28CC  FFE6     NOP
28CE  C033     MOVFF 0x33, POSTINC1
28D0  FFE6     NOP
352:           							Menu_items_thresholds[INDEX_TEMPER_SETUP_MAX]);
28A0  0EC9     MOVLW 0xC9
28A2  6EF6     MOVWF TBLPTR, ACCESS
28A4  0E4B     MOVLW 0x4B
28A6  6EF7     MOVWF TBLPTRH, ACCESS
28A8  0008     TBLRD*
28AA  50F5     MOVF TABLAT, W, ACCESS
28AC  6EE6     MOVWF POSTINC1, ACCESS
28D2  EC28     CALL 0x2050, 0
28D4  F010     NOP
28D6  52E5     MOVF POSTDEC1, F, ACCESS
28D8  52E5     MOVF POSTDEC1, F, ACCESS
28DA  52E5     MOVF POSTDEC1, F, ACCESS
353:           					break;
28DC  D04C     BRA 0x2976
354:           					case STATE_VIEW_SUPPLY_FUEL :
355:           						M_Motor_set_work(ON); 		//включить алгоритм работы дозатора-заслонки-ворошителя
28DE  0E01     MOVLW 0x1
28E0  6EE6     MOVWF POSTINC1, ACCESS
28E2  EC0F     CALL 0x21E, 0
28E4  F001     NOP
28E6  52E5     MOVF POSTDEC1, F, ACCESS
356:           						M_Ind_Set_blink_mode(NEED_BLINK);
28E8  0E01     MOVLW 0x1
28EA  6EE6     MOVWF POSTINC1, ACCESS
28EC  EC7E     CALL 0x2AFC, 0
28EE  F015     NOP
28F0  52E5     MOVF POSTDEC1, F, ACCESS
357:           					break;
28F2  D041     BRA 0x2976
358:           					case STATE_VIEW_SPEED_FAN_SETUP: 	//увеличение уровня оборотов вентилятора
359:           						if(M_Mngm_Get_state() == STATE_BURNING)
28F4  ECA7     CALL 0x154E, 0
28F6  F00A     NOP
28F8  0802     SUBLW 0x2
28FA  E11A     BNZ 0x2930
360:           						{
361:           							Menu_inc_param(M_Mngm_get_pFanLevel(), Menu_items_thresholds[M_Mngm_get_fanParamOffset() + 1]);
28FC  EC08     CALL 0x1410, 0
28FE  F00A     NOP
2900  0F01     ADDLW 0x1
2902  6AF7     CLRF TBLPTRH, ACCESS
2904  0F7A     ADDLW 0x7A
2906  6EF6     MOVWF TBLPTR, ACCESS
2908  0E4B     MOVLW 0x4B
290A  22F7     ADDWFC TBLPTRH, F, ACCESS
290C  0008     TBLRD*
290E  50F5     MOVF TABLAT, W, ACCESS
2910  6EE6     MOVWF POSTINC1, ACCESS
2912  EC0C     CALL 0x1418, 0
2914  F00A     NOP
2916  CFF3     MOVFF PROD, __tmp_0
2918  F032     NOP
291A  CFF4     MOVFF PRODH, 0x33
291C  F033     NOP
291E  C032     MOVFF __tmp_0, POSTINC1
2920  FFE6     NOP
2922  C033     MOVFF 0x33, POSTINC1
2924  FFE6     NOP
2926  EC28     CALL 0x2050, 0
2928  F010     NOP
292A  52E5     MOVF POSTDEC1, F, ACCESS
292C  52E5     MOVF POSTDEC1, F, ACCESS
292E  52E5     MOVF POSTDEC1, F, ACCESS
362:           						}
363:           						break; 	
2930  D022     BRA 0x2976
364:           					case STATE_VIEW_CLEAN_CHIMNEY:
365:           						if(M_Motor_get_ctrl_shatter() == WAITING_MOVEMENT/*NO_MOVEMENT */ && M_LI_Get_Limit_Switches()->ls_shatter_start_state 
2932  EC2D     CALL 0x25A, 0
2934  F001     NOP
2936  0803     SUBLW 0x3
293A  ECBD     CALL 0x3B7A, 0
293C  F01D     NOP
293E  CFF3     MOVFF PROD, FSR0
2940  FFE9     NOP
2942  CFF4     MOVFF PRODH, FSR0H
2944  FFEA     NOP
2946  0E02     MOVLW 0x2
2948  26E9     ADDWF FSR0, F, ACCESS
294A  0E00     MOVLW 0x0
294C  22EA     ADDWFC FSR0H, F, ACCESS
294E  50EF     MOVF INDF0, W, ACCESS
366:           							&& !M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state)
2938  E11D     BNZ 0x2974
2950  E011     BZ 0x2974
2952  ECBD     CALL 0x3B7A, 0
2954  F01D     NOP
2956  CFF3     MOVFF PROD, FSR0
2958  FFE9     NOP
295A  CFF4     MOVFF PRODH, FSR0H
295C  FFEA     NOP
295E  0E04     MOVLW 0x4
2960  26E9     ADDWF FSR0, F, ACCESS
2962  0E00     MOVLW 0x0
2964  22EA     ADDWFC FSR0H, F, ACCESS
2966  50EF     MOVF INDF0, W, ACCESS
2968  E105     BNZ 0x2974
367:           							M_Motor_set_ctrl_shatter(MOVEMENT_FORWARD);
296A  0E01     MOVLW 0x1
296C  6EE6     MOVWF POSTINC1, ACCESS
296E  EC22     CALL 0x244, 0
2970  F001     NOP
2972  52E5     MOVF POSTDEC1, F, ACCESS
368:           						break;
2974  D000     BRA 0x2976
369:           				}
370:           			break;
2976  D0A1     BRA 0x2ABA
371:           			case CODE_KEY_DEC_PRESSED_AND_FREE: 
372:           				switch(M_Ind_Get_state())
2978  ECA3     CALL 0x2B46, 0
297A  F015     NOP
297C  0A06     XORLW 0x6
297E  E101     BNZ 0x2982
2980  D079     BRA 0x2A74
2982  0A0F     XORLW 0xF
2984  E059     BZ 0x2A38
2986  0A0A     XORLW 0xA
2988  E051     BZ 0x2A2C
298A  0A07     XORLW 0x7
298C  E030     BZ 0x29EE
298E  0A06     XORLW 0x6
2990  E012     BZ 0x29B6
2992  0A03     XORLW 0x3
2994  E001     BZ 0x2998
2996  D090     BRA 0x2AB8
373:           				{
374:           					case STATE_VIEW_NUM_PAGE_MENU :
375:           						M_Ind_setTimeAutoExit(0);
2998  6AE6     CLRF POSTINC1, ACCESS
299A  EC57     CALL 0x30AE, 0
299C  F018     NOP
299E  52E5     MOVF POSTDEC1, F, ACCESS
376:           						Menu_dec_param(&Menu_Num_Page_Menu, 0);
29A0  6AE6     CLRF POSTINC1, ACCESS
29A2  0E0F     MOVLW 0xF
29A4  6EE6     MOVWF POSTINC1, ACCESS
29A6  0E01     MOVLW 0x1
29A8  6EE6     MOVWF POSTINC1, ACCESS
29AA  EC43     CALL 0x2086, 0
29AC  F010     NOP
29AE  52E5     MOVF POSTDEC1, F, ACCESS
29B0  52E5     MOVF POSTDEC1, F, ACCESS
29B2  52E5     MOVF POSTDEC1, F, ACCESS
377:           					break;
29B4  D081     BRA 0x2AB8
378:           					case STATE_VIEW_PARAMETER_MENU:
379:           						M_Ind_setTimeAutoExit(0);
29B6  6AE6     CLRF POSTINC1, ACCESS
29B8  EC57     CALL 0x30AE, 0
29BA  F018     NOP
29BC  52E5     MOVF POSTDEC1, F, ACCESS
380:           						Menu_item_change(M_Mngm_Get_parameters_buffer()->buffer, Menu_Num_Page_Menu, DECREMENT);
29BE  6AE6     CLRF POSTINC1, ACCESS
29C0  C10F     MOVFF Menu_Num_Page_Menu, POSTINC1
29C2  FFE6     NOP
29C4  EC8E     CALL 0x151C, 0
29C6  F00A     NOP
29C8  CFF3     MOVFF PROD, FSR0
29CA  FFE9     NOP
29CC  CFF4     MOVFF PRODH, FSR0H
29CE  FFEA     NOP
29D0  CFE9     MOVFF FSR0, __tmp_0
29D2  F032     NOP
29D4  CFEA     MOVFF FSR0H, 0x33
29D6  F033     NOP
29D8  C032     MOVFF __tmp_0, POSTINC1
29DA  FFE6     NOP
29DC  C033     MOVFF 0x33, POSTINC1
29DE  FFE6     NOP
29E0  EC5F     CALL 0x20BE, 0
29E2  F010     NOP
29E4  52E5     MOVF POSTDEC1, F, ACCESS
29E6  52E5     MOVF POSTDEC1, F, ACCESS
29E8  52E5     MOVF POSTDEC1, F, ACCESS
29EA  52E5     MOVF POSTDEC1, F, ACCESS
381:           					break;
29EC  D065     BRA 0x2AB8
382:           					case STATE_VIEW_TEMPERATURE_SETUP:
383:           						Menu_dec_param(&(M_Mngm_Get_parameters_buffer()->menu_parameters.temper_setup), 
29FC  EC8E     CALL 0x151C, 0
29FE  F00A     NOP
2A00  CFF3     MOVFF PROD, FSR0
2A02  FFE9     NOP
2A04  CFF4     MOVFF PRODH, FSR0H
2A06  FFEA     NOP
2A08  0E27     MOVLW 0x27
2A0A  26E9     ADDWF FSR0, F, ACCESS
2A0C  0E00     MOVLW 0x0
2A0E  22EA     ADDWFC FSR0H, F, ACCESS
2A10  CFE9     MOVFF FSR0, __tmp_0
2A12  F032     NOP
2A14  CFEA     MOVFF FSR0H, 0x33
2A16  F033     NOP
2A18  C032     MOVFF __tmp_0, POSTINC1
2A1A  FFE6     NOP
2A1C  C033     MOVFF 0x33, POSTINC1
2A1E  FFE6     NOP
384:           							Menu_items_thresholds[INDEX_TEMPER_SETUP_MIN]);	
29EE  0EC8     MOVLW 0xC8
29F0  6EF6     MOVWF TBLPTR, ACCESS
29F2  0E4B     MOVLW 0x4B
29F4  6EF7     MOVWF TBLPTRH, ACCESS
29F6  0008     TBLRD*
29F8  50F5     MOVF TABLAT, W, ACCESS
29FA  6EE6     MOVWF POSTINC1, ACCESS
2A20  EC43     CALL 0x2086, 0
2A22  F010     NOP
2A24  52E5     MOVF POSTDEC1, F, ACCESS
2A26  52E5     MOVF POSTDEC1, F, ACCESS
2A28  52E5     MOVF POSTDEC1, F, ACCESS
385:           					break;
2A2A  D046     BRA 0x2AB8
386:           					case STATE_VIEW_TEMPERATURE_REAL:  					//просмотр текущей температуры
387:           						M_Ind_Set_state(STATE_VIEW_SPEED_FAN_SETUP);
2A2C  0E09     MOVLW 0x9
2A2E  6EE6     MOVWF POSTINC1, ACCESS
2A30  EC98     CALL 0x2B30, 0
2A32  F015     NOP
2A34  52E5     MOVF POSTDEC1, F, ACCESS
388:           					break;
2A36  D040     BRA 0x2AB8
389:           					case STATE_VIEW_SPEED_FAN_SETUP:		 	//увеличение уровня оборотов вентилятора
390:           
391:           						if(M_Mngm_Get_state() == STATE_BURNING)
2A38  ECA7     CALL 0x154E, 0
2A3A  F00A     NOP
2A3C  0802     SUBLW 0x2
2A3E  E119     BNZ 0x2A72
392:           						{
393:           							Menu_dec_param(M_Mngm_get_pFanLevel(), Menu_items_thresholds[M_Mngm_get_fanParamOffset()]);
2A40  EC08     CALL 0x1410, 0
2A42  F00A     NOP
2A44  6AF7     CLRF TBLPTRH, ACCESS
2A46  0F7A     ADDLW 0x7A
2A48  6EF6     MOVWF TBLPTR, ACCESS
2A4A  0E4B     MOVLW 0x4B
2A4C  22F7     ADDWFC TBLPTRH, F, ACCESS
2A4E  0008     TBLRD*
2A50  50F5     MOVF TABLAT, W, ACCESS
2A52  6EE6     MOVWF POSTINC1, ACCESS
2A54  EC0C     CALL 0x1418, 0
2A56  F00A     NOP
2A58  CFF3     MOVFF PROD, __tmp_0
2A5A  F032     NOP
2A5C  CFF4     MOVFF PRODH, 0x33
2A5E  F033     NOP
2A60  C032     MOVFF __tmp_0, POSTINC1
2A62  FFE6     NOP
2A64  C033     MOVFF 0x33, POSTINC1
2A66  FFE6     NOP
2A68  EC43     CALL 0x2086, 0
2A6A  F010     NOP
2A6C  52E5     MOVF POSTDEC1, F, ACCESS
2A6E  52E5     MOVF POSTDEC1, F, ACCESS
2A70  52E5     MOVF POSTDEC1, F, ACCESS
394:           						}
395:           					break; 
2A72  D022     BRA 0x2AB8
396:           					case STATE_VIEW_CLEAN_CHIMNEY:
397:           						if(M_Motor_get_ctrl_shatter() == WAITING_MOVEMENT && !M_LI_Get_Limit_Switches()->ls_shatter_start_state 
2A74  EC2D     CALL 0x25A, 0
2A76  F001     NOP
2A78  0803     SUBLW 0x3
2A7C  ECBD     CALL 0x3B7A, 0
2A7E  F01D     NOP
2A80  CFF3     MOVFF PROD, FSR0
2A82  FFE9     NOP
2A84  CFF4     MOVFF PRODH, FSR0H
2A86  FFEA     NOP
2A88  0E02     MOVLW 0x2
2A8A  26E9     ADDWF FSR0, F, ACCESS
2A8C  0E00     MOVLW 0x0
2A8E  22EA     ADDWFC FSR0H, F, ACCESS
2A90  50EF     MOVF INDF0, W, ACCESS
398:           							&& M_LI_Get_Limit_Switches()->ls_shatter_after_finish_state)
2A7A  E11D     BNZ 0x2AB6
2A92  E111     BNZ 0x2AB6
2A94  ECBD     CALL 0x3B7A, 0
2A96  F01D     NOP
2A98  CFF3     MOVFF PROD, FSR0
2A9A  FFE9     NOP
2A9C  CFF4     MOVFF PRODH, FSR0H
2A9E  FFEA     NOP
2AA0  0E04     MOVLW 0x4
2AA2  26E9     ADDWF FSR0, F, ACCESS
2AA4  0E00     MOVLW 0x0
2AA6  22EA     ADDWFC FSR0H, F, ACCESS
2AA8  50EF     MOVF INDF0, W, ACCESS
2AAA  E005     BZ 0x2AB6
399:           							M_Motor_set_ctrl_shatter(MOVEMENT_BACKWARD);
2AAC  0E02     MOVLW 0x2
2AAE  6EE6     MOVWF POSTINC1, ACCESS
2AB0  EC22     CALL 0x244, 0
2AB2  F001     NOP
2AB4  52E5     MOVF POSTDEC1, F, ACCESS
400:           					break;
2AB6  D000     BRA 0x2AB8
401:           				}
402:           			break;
2AB8  D000     BRA 0x2ABA
403:           			//default:
404:           		}
405:           		memset(key_str, 0, sizeof *(key_str));
2ABA  0E03     MOVLW 0x3
2ABC  6EE6     MOVWF POSTINC1, ACCESS
2ABE  6AE6     CLRF POSTINC1, ACCESS
2AC0  6AE6     CLRF POSTINC1, ACCESS
2AC2  0EFD     MOVLW 0xFD
2AC4  CFDB     MOVFF PLUSW2, POSTINC1
2AC6  FFE6     NOP
2AC8  0EFE     MOVLW 0xFE
2ACA  CFDB     MOVFF PLUSW2, POSTINC1
2ACC  FFE6     NOP
2ACE  EC59     CALL 0x4CB2, 0
2AD0  F026     NOP
2AD2  6E32     MOVWF __tmp_0, ACCESS
2AD4  0E05     MOVLW 0x5
2AD6  5EE1     SUBWF FSR1, F, ACCESS
2AD8  5032     MOVF __tmp_0, W, ACCESS
406:           	}	
407:           }
2ADA  52E5     MOVF POSTDEC1, F, ACCESS
2ADC  CFE7     MOVFF INDF1, FSR2
2ADE  FFD9     NOP
2AE0  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Main/main.c  -------------------------------------
1:             /* Программа для блока управления твердотопливным котлом с автоподачей топлива
2:             Тип МК - PIC18F87J50
3:             Частота выполнения команд - 12 Мгц (83 нс)
4:             Тип ОС - кооперативная, PICOSA (версия 11.03.06)
5:             Системный тик ОС - 1 мс 
6:             Версия ПО - 2.00
7:             Автор - Кругликов Владислав	
8:             Заказчик - Шумейко Роман
9:             */
10:            
11:            #include <p18cxxx.h>
12:            #include <delays.h>
13:            #include "osa.h"
14:            #include "main.h"
15:            #include "task_logic_inputs.h"
16:            #include "task_analog_inputs.h"
17:            #include "task_outs.h"
18:            #include "task_motors.h"
19:            #include "module_analog_inputs.h"
20:            #include "module_management.h"
21:            #include "task_management.h"
22:            #include "module_fan.h"
23:            #include "module_indication.h"
24:            #include "module_motor.h"
25:            #include "module_sound.h"
26:            #include "logicAnalyzer.h"
27:            #include "eeprom.h"
28:            #include "interrupts.h"
29:            #include "module_logic_inputs.h"
30:            
31:            
32:            // CONFIG1L
33:            #pragma config WDTEN = ON       // Watchdog Timer Enable bit (WDT enabled)
34:            #pragma config PLLDIV = 2       // PLL Prescaler Selection bits (Prescale 2 (8 MHz oscillator input drives PLL directly))
35:            #pragma config STVREN = ON      // Stack Overflow/Underflow Reset Enable bit (Reset on stack overflow/underflow enabled)
36:            #pragma config XINST = OFF      // Extended Instruction Set Enable bit (Instruction set extension and Indexed Addressing mode disabled (Legacy mode))
37:            
38:            // CONFIG1H
39:            #pragma config CPUDIV = OSC1    // /* CPU System Clock Postscaler (No CPU system clock divide) */ CPU System Clock Divide by 2
40:            #pragma config CP0 = OFF        // Code Protection bit (Program memory is not code-protected)
41:            
42:            // CONFIG2L
43:            #pragma config FOSC = HSPLL     // Oscillator Selection bits (HS oscillator, PLL enabled, HSPLL used by USB)
44:            #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor disabled)
45:            #pragma config IESO = OFF       // Two-Speed Start-up (Internal/External Oscillator Switchover) Control bit (Two-Speed Start-up disabled)
46:            
47:            // CONFIG2H
48:            #pragma config WDTPS = 256      // Watchdog Timer Postscaler Select bits (1:256)
49:            
50:            // CONFIG3L
51:            #pragma config EASHFT = OFF     // External Address Bus Shift Enable bit (Address shifting disabled, address on external bus reflects the PC value)
52:            #pragma config MODE = MM        // External Memory Bus Configuration bits (Microcontroller mode - External bus disabled)
53:            #pragma config BW = 16          // Data Bus Width Select bit (16-bit external bus mode)
54:            #pragma config WAIT = OFF       // External Bus Wait Enable bit (Wait states on the external bus are disabled)
55:            
56:            // CONFIG3H
57:            #pragma config CCP2MX = DEFAULT // ECCP2 MUX bit (ECCP2/P2A is multiplexed with RC1)
58:            #pragma config ECCPMX = DEFAULT // ECCPx MUX bit (ECCP1 outputs (P1B/P1C) are multiplexed with RE6 and RE5; ECCP3 outputs (P3B/P3C) are multiplexed with RE4 and RE3)
59:            #pragma config PMPMX = DEFAULT  // PMP Pin Multiplex bit (PMP pins placed on EMB)
60:            #pragma config MSSPMSK = MSK7   // MSSP Address Masking Mode Select bit (7-Bit Address Masking mode enable)
61:            
62:            
63:            
64:            static void Init_PIC(void); //инициализация модулей программы
65:            
66:            
67:            static void Init_PIC(void)
68:            {
69:            	OSCTUNEbits.PLLEN = 1;   //разрешить умножитель частоты 
4636  8C9B     BSF OSCTUNE, 6, ACCESS
70:                M_AI_ctor();
4638  EC54     CALL 0x34A8, 0
463A  F01A     NOP
71:            	M_Fan_ctor();
463C  ECD2     CALL 0x41A4, 0
463E  F020     NOP
72:                M_Ind_ctor();
4640  EC71     CALL 0x2AE2, 0
4642  F015     NOP
73:                M_Motor_ctor();
4644  EC44     CALL 0x88, 0
4646  F000     NOP
74:                M_Sound_ctor();
4648  ECCF     CALL 0x479E, 0
464A  F023     NOP
75:                DebugTools_ctor();
464C  ECE8     CALL 0x49D0, 0
464E  F024     NOP
76:                M_LI_ctor();
4650  EC9D     CALL 0x3B3A, 0
4652  F01D     NOP
77:                Delay10KTCYx(255); //задержка около 212 мс
4654  68E6     SETF POSTINC1, ACCESS
4656  EC8B     CALL 0x4D16, 0
4658  F026     NOP
465A  52E5     MOVF POSTDEC1, F, ACCESS
78:            #ifndef DEBUG_IN_SIMULATOR
79:                EEPROM_ctor();
465C  ECC5     CALL 0x3D8A, 0
465E  F01E     NOP
80:            #endif
81:                Intr_ctor();
4660  EC15     CALL 0x442A, 0
4662  F022     NOP
82:            }
4664  0012     RETURN 0
83:            
84:            void main (void)
85:            {
86:            	Init_PIC();									//инициализация контроллера
4666  DFE7     RCALL Init_PIC
87:            	OS_Init(); 									//инициализация ОСи
4668  EC5C     CALL 0x40B8, 0
466A  F020     NOP
88:            	OS_CreateTask(0, Task_Logic_Inputs);	 	//создание задачи опроса логических входов (кнопки, концевики, отработка кнопок в меню)
466C  0E42     MOVLW 0x42
466E  6EE6     MOVWF POSTINC1, ACCESS
4670  0E4E     MOVLW 0x4E
4672  6EE6     MOVWF POSTINC1, ACCESS
4674  6AE6     CLRF POSTINC1, ACCESS
4676  EC7D     CALL 0x40FA, 0
4678  F020     NOP
467A  52E5     MOVF POSTDEC1, F, ACCESS
467C  52E5     MOVF POSTDEC1, F, ACCESS
467E  52E5     MOVF POSTDEC1, F, ACCESS
89:            	OS_CreateTask(1, Task_Outs);          		//создание задачи управления логическими выходами (индикация, звук, вентилятор с алгоритмом фазового регулирования)		
4680  0E70     MOVLW 0x70
4682  6EE6     MOVWF POSTINC1, ACCESS
4684  0E4D     MOVLW 0x4D
4686  6EE6     MOVWF POSTINC1, ACCESS
4688  0E01     MOVLW 0x1
468A  6EE6     MOVWF POSTINC1, ACCESS
468C  EC7D     CALL 0x40FA, 0
468E  F020     NOP
4690  52E5     MOVF POSTDEC1, F, ACCESS
4692  52E5     MOVF POSTDEC1, F, ACCESS
4694  52E5     MOVF POSTDEC1, F, ACCESS
90:            	OS_CreateTask(1, Task_Management);          //создание задачи управления с высшим приоритетом 
4696  0E28     MOVLW 0x28
4698  6EE6     MOVWF POSTINC1, ACCESS
469A  0E4E     MOVLW 0x4E
469C  6EE6     MOVWF POSTINC1, ACCESS
469E  0E01     MOVLW 0x1
46A0  6EE6     MOVWF POSTINC1, ACCESS
46A2  EC7D     CALL 0x40FA, 0
46A4  F020     NOP
46A6  52E5     MOVF POSTDEC1, F, ACCESS
46A8  52E5     MOVF POSTDEC1, F, ACCESS
46AA  52E5     MOVF POSTDEC1, F, ACCESS
91:            	OS_CreateTask(0, Task_Analog_Inputs);       //создание задачи управления аналоговыми входами
46AC  0E5C     MOVLW 0x5C
46AE  6EE6     MOVWF POSTINC1, ACCESS
46B0  0E4E     MOVLW 0x4E
46B2  6EE6     MOVWF POSTINC1, ACCESS
46B4  6AE6     CLRF POSTINC1, ACCESS
46B6  EC7D     CALL 0x40FA, 0
46B8  F020     NOP
46BA  52E5     MOVF POSTDEC1, F, ACCESS
46BC  52E5     MOVF POSTDEC1, F, ACCESS
46BE  52E5     MOVF POSTDEC1, F, ACCESS
92:            	OS_CreateTask(0, Task_Motors);   			//создание задачи управления двигателями
46C0  0E0E     MOVLW 0xE
46C2  6EE6     MOVWF POSTINC1, ACCESS
46C4  0E4E     MOVLW 0x4E
46C6  6EE6     MOVWF POSTINC1, ACCESS
46C8  6AE6     CLRF POSTINC1, ACCESS
46CA  EC7D     CALL 0x40FA, 0
46CC  F020     NOP
46CE  52E5     MOVF POSTDEC1, F, ACCESS
46D0  52E5     MOVF POSTDEC1, F, ACCESS
46D2  52E5     MOVF POSTDEC1, F, ACCESS
93:            	OS_Run();
46D4  983A     BCF _OS_Flags, 4, ACCESS
46D6  863A     BSF _OS_Flags, 3, ACCESS
46D8  0E08     MOVLW 0x8
46DA  6E04     MOVWF _OS_Best_Priority, ACCESS
46DC  C002     MOVFF _OS_LastTask, _OS_CurTask
46DE  F03D     NOP
46E0  C003     MOVFF 0x3, 0x3E
46E2  F03E     NOP
46E4  0E19     MOVLW 0x19
46E6  5C3D     SUBWF _OS_CurTask, W, ACCESS
46E8  0E00     MOVLW 0x0
46EA  583E     SUBWFB 0x3E, W, ACCESS
46EC  E305     BNC 0x46F8
46EE  0E05     MOVLW 0x5
46F0  6E3D     MOVWF _OS_CurTask, ACCESS
46F2  0E00     MOVLW 0x0
46F4  6E3E     MOVWF 0x3E, ACCESS
46F6  D004     BRA 0x4700
46F8  0E05     MOVLW 0x5
46FA  263D     ADDWF _OS_CurTask, F, ACCESS
46FC  0E00     MOVLW 0x0
46FE  223E     ADDWFC 0x3E, F, ACCESS
4700  EC0A     CALL 0x4014, 0
4702  F020     NOP
4704  50EF     MOVF INDF0, W, ACCESS
4706  0B40     ANDLW 0x40
4708  E003     BZ 0x4710
470A  50EF     MOVF INDF0, W, ACCESS
470C  0B80     ANDLW 0x80
470E  E001     BZ 0x4712
4710  D02A     BRA 0x4766
4712  50EF     MOVF INDF0, W, ACCESS
4714  0B07     ANDLW 0x7
4716  6E3B     MOVWF _OS_Temp, ACCESS
4718  80D8     BSF STATUS, 0, ACCESS
471A  5404     SUBFWB _OS_Best_Priority, W, ACCESS
471C  E301     BNC 0x4720
471E  D023     BRA 0x4766
4720  B6EF     BTFSC INDF0, 3, ACCESS
4722  D00D     BRA 0x473E
4724  ECD3     CALL 0x3FA6, 0
4726  F01F     NOP
4728  503C     MOVF _OS_TempH, W, ACCESS
472A  5CE1     SUBWF FSR1, W, ACCESS
472C  E004     BZ 0x4736
472E  503C     MOVF _OS_TempH, W, ACCESS
4730  6EE1     MOVWF FSR1, ACCESS
4732  50E7     MOVF INDF1, W, ACCESS
4734  6ED9     MOVWF FSR2, ACCESS
4736  A63A     BTFSS _OS_Flags, 3, ACCESS
4738  D030     BRA 0x479A
473A  EC0A     CALL 0x4014, 0
473C  F020     NOP
473E  50EF     MOVF INDF0, W, ACCESS
4740  0B10     ANDLW 0x10
4742  E004     BZ 0x474C
4744  50EF     MOVF INDF0, W, ACCESS
4746  0B20     ANDLW 0x20
4748  E101     BNZ 0x474C
474A  D00D     BRA 0x4766
474C  A6EF     BTFSS INDF0, 3, ACCESS
474E  D00B     BRA 0x4766
4750  883A     BSF _OS_Flags, 4, ACCESS
4752  C03D     MOVFF _OS_CurTask, _OS_BestTask
4754  F000     NOP
4756  C03E     MOVFF 0x3E, 0x1
4758  F001     NOP
475A  50EF     MOVF INDF0, W, ACCESS
475C  0B07     ANDLW 0x7
475E  6E04     MOVWF _OS_Best_Priority, ACCESS
4760  5004     MOVF _OS_Best_Priority, W, ACCESS
4762  E101     BNZ 0x4766
4764  D006     BRA 0x4772
4766  5002     MOVF _OS_LastTask, W, ACCESS
4768  183D     XORWF _OS_CurTask, W, ACCESS
476A  E102     BNZ 0x4770
476C  5003     MOVF 0x3, W, ACCESS
476E  183E     XORWF 0x3E, W, ACCESS
4770  E1B9     BNZ 0x46E4
4772  A83A     BTFSS _OS_Flags, 4, ACCESS
4774  D012     BRA 0x479A
4776  963A     BCF _OS_Flags, 3, ACCESS
4778  C000     MOVFF _OS_BestTask, _OS_CurTask
477A  F03D     NOP
477C  C001     MOVFF 0x1, 0x3E
477E  F03E     NOP
4780  C000     MOVFF _OS_BestTask, _OS_LastTask
4782  F002     NOP
4784  C001     MOVFF 0x1, 0x3
4786  F003     NOP
4788  EC0A     CALL 0x4014, 0
478A  F020     NOP
478C  50EF     MOVF INDF0, W, ACCESS
478E  0B40     ANDLW 0x40
4790  E004     BZ 0x479A
4792  50EF     MOVF INDF0, W, ACCESS
4794  0B80     ANDLW 0x80
4796  E101     BNZ 0x479A
4798  D7C5     BRA 0x4724
479A  D79C     BRA 0x46D4
94:            }
479C  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Interrupts/interrupts.c  -------------------------
1:             
2:             #include "interrupts.h"
3:             #include <p18cxxx.h>
4:             #include "osa.h"
5:             #include "module_motor.h"
6:             #include "logicAnalyzer.h"
7:             #include "main.h"
8:             
9:             #ifdef ENABLE_INT2
10:                #define TRIS_INTR_NULL_SIN  TRISBbits.TRISB2
11:            #endif
12:            
13:            #pragma code InterruptVectorHigh = 0x08
14:            
15:            static uint16_t cnt_zero_crossing = 0;
16:            static BOOL is_zero_cross = FALSE;  				 //признак перехода через нуль сетевого напряжения
17:            static BOOL  is_impulse_agitator_sensor = FALSE; 	 //признак наличия импульса датчика ворошителя
18:            
19:            void InterruptHandlerHigh (void);
20:            void InterruptVectorHigh (void);
21:            
22:            void InterruptVectorHigh (void)
23:            {
24:                _asm
25:                    goto InterruptHandlerHigh //jump to interrupt routine
0008  EF98     GOTO 0x4330
000A  F021     NOP
26:                _endasm
27:            }
000C  0012     RETURN 0
28:            
29:            
30:            #pragma code
31:            #pragma interrupt InterruptHandlerHigh
32:            
33:            /*
34:            Прерывание т/с0 для формирования системного "тика" 1мс
35:            Прерывание т/с3 50мс для формирования временной сетки с шагом 1с 
36:            Прерывание по заднему фронту INT2 (переход через ноль сетевого напряжения 220В)
37:            Прерывание т/с2 215 мкс для формирования программного ШИМа разгона двигателя 
38:            */
39:            void InterruptHandlerHigh (void)
4330  CFDA     MOVFF FSR2H, PREINC1
4332  FFE4     NOP
4334  CFE2     MOVFF FSR1H, FSR2H
4336  FFDA     NOP
4338  CFE9     MOVFF FSR0, PREINC1
433A  FFE4     NOP
433C  CFEA     MOVFF FSR0H, PREINC1
433E  FFE4     NOP
4340  CFF6     MOVFF TBLPTR, PREINC1
4342  FFE4     NOP
4344  CFF7     MOVFF TBLPTRH, PREINC1
4346  FFE4     NOP
4348  CFF5     MOVFF TABLAT, PREINC1
434A  FFE4     NOP
434C  CFF3     MOVFF PROD, PREINC1
434E  FFE4     NOP
4350  CFF4     MOVFF PRODH, PREINC1
4352  FFE4     NOP
4354  CFFA     MOVFF PCLATH, PREINC1
4356  FFE4     NOP
4358  EE00     LFSR 0, 0x1E
435A  F01E     NOP
435C  0E14     MOVLW 0x14
435E  04E8     DECF WREG, W, ACCESS
4360  E303     BNC 0x4368
4362  CFEE     MOVFF POSTINC0, PREINC1
4364  FFE4     NOP
4366  D7FB     BRA 0x435E
4368  EE00     LFSR 0, 0x32
436A  F032     NOP
436C  0E08     MOVLW 0x8
436E  04E8     DECF WREG, W, ACCESS
4370  E303     BNC 0x4378
4372  CFEE     MOVFF POSTINC0, PREINC1
4374  FFE4     NOP
4376  D7FB     BRA 0x436E
4378  52E6     MOVF POSTINC1, F, ACCESS
40:            {
41:             	OS_EnterInt();
42:             	if (INTCONbits.TMR0IF)      //отсчёт системного тика 1 мс
437A  A4F2     BTFSS INTCON, 2, ACCESS
437C  D005     BRA 0x4388
43:                {                           //check for TMR0 overflow
44:                	//DEBUG_PIN_1_TOGGLE;
45:                    TMR0L=0x48;
437E  0E48     MOVLW 0x48
4380  6ED6     MOVWF TMR0, ACCESS
46:                	INTCONbits.TMR0IF = 0;  //clear interrupt flag
4382  94F2     BCF INTCON, 2, ACCESS
47:                   	OS_Timer();
4384  EC67     CALL 0x40CE, 0
4386  F020     NOP
48:            	}
49:                if(INTCON3bits.INT2IF && INTCON3bits.INT2IE) //прерывание по переходу через ноль сетевого напряжения каждые 20 мс
4388  50F0     MOVF INTCON3, W, ACCESS
438A  0B02     ANDLW 0x2
438C  E00B     BZ 0x43A4
438E  50F0     MOVF INTCON3, W, ACCESS
4390  0B10     ANDLW 0x10
4392  E008     BZ 0x43A4
50:            	{
51:            		INTCON3bits.INT2IF = 0;
4394  92F0     BCF INTCON3, 1, ACCESS
52:            		is_zero_cross = TRUE;
4396  0101     MOVLB 0x1
4398  0E01     MOVLW 0x1
439A  6F15     MOVWF 0x15, BANKED
53:            		cnt_zero_crossing++;
439C  0101     MOVLB 0x1
439E  2B13     INCF 0x13, F, BANKED
43A0  0E00     MOVLW 0x0
43A2  2314     ADDWFC 0x14, F, BANKED
54:            	}
55:            	if(INTCON3bits.INT1IF && INTCON3bits.INT1IE) //прерывание по заднему фронту на RB1 для опроса датчика ворошителя
43A4  50F0     MOVF INTCON3, W, ACCESS
43A6  0B01     ANDLW 0x1
43A8  E007     BZ 0x43B8
43AA  50F0     MOVF INTCON3, W, ACCESS
43AC  0B08     ANDLW 0x8
43AE  E004     BZ 0x43B8
56:            	{
57:            		is_impulse_agitator_sensor = TRUE;
43B0  0101     MOVLB 0x1
43B2  0E01     MOVLW 0x1
43B4  6F16     MOVWF 0x16, BANKED
58:            		INTCON3bits.INT1IF = 0;
43B6  90F0     BCF INTCON3, 0, ACCESS
59:            	}
60:            	if(PIR1bits.TMR2IF && PIE1bits.TMR2IE) //период прерывания 205 мкс (для формирования ШИМа разгона двигателя)
43B8  509E     MOVF PIR1, W, ACCESS
43BA  0B02     ANDLW 0x2
43BC  E012     BZ 0x43E2
43BE  509D     MOVF PIE1, W, ACCESS
43C0  0B02     ANDLW 0x2
43C2  E00F     BZ 0x43E2
61:            	{
62:            		PIR1bits.TMR2IF = 0;
43C4  929E     BCF PIR1, 1, ACCESS
63:            		M_Motor_software_PWM_interrrupt(M_Motor_get_ptr_to_motor_pins());
43C6  EC1C     CALL 0x638, 0
43C8  F003     NOP
43CA  CFF3     MOVFF PROD, __tmp_1
43CC  F03F     NOP
43CE  CFF4     MOVFF PRODH, 0x40
43D0  F040     NOP
43D2  C03F     MOVFF __tmp_1, POSTINC1
43D4  FFE6     NOP
43D6  C040     MOVFF 0x40, POSTINC1
43D8  FFE6     NOP
43DA  EC26     CALL 0x124C, 0
43DC  F009     NOP
43DE  52E5     MOVF POSTDEC1, F, ACCESS
43E0  52E5     MOVF POSTDEC1, F, ACCESS
64:            	}	
65:            	OS_LeaveInt();
66:            }
43E2  52E5     MOVF POSTDEC1, F, ACCESS
43E4  EE00     LFSR 0, 0x39
43E6  F039     NOP
43E8  0E08     MOVLW 0x8
43EA  04E8     DECF WREG, W, ACCESS
43EC  E303     BNC 0x43F4
43EE  CFE5     MOVFF POSTDEC1, POSTDEC0
43F0  FFED     NOP
43F2  D7FB     BRA 0x43EA
43F4  EE00     LFSR 0, 0x31
43F6  F031     NOP
43F8  0E14     MOVLW 0x14
43FA  04E8     DECF WREG, W, ACCESS
43FC  E303     BNC 0x4404
43FE  CFE5     MOVFF POSTDEC1, POSTDEC0
4400  FFED     NOP
4402  D7FB     BRA 0x43FA
4404  CFE5     MOVFF POSTDEC1, PCLATH
4406  FFFA     NOP
4408  CFE5     MOVFF POSTDEC1, PRODH
440A  FFF4     NOP
440C  CFE5     MOVFF POSTDEC1, PROD
440E  FFF3     NOP
4410  CFE5     MOVFF POSTDEC1, TABLAT
4412  FFF5     NOP
4414  CFE5     MOVFF POSTDEC1, TBLPTRH
4416  FFF7     NOP
4418  CFE5     MOVFF POSTDEC1, TBLPTR
441A  FFF6     NOP
441C  CFE5     MOVFF POSTDEC1, FSR0H
441E  FFEA     NOP
4420  CFE5     MOVFF POSTDEC1, FSR0
4422  FFE9     NOP
4424  CFE5     MOVFF POSTDEC1, FSR2H
4426  FFDA     NOP
4428  0011     RETFIE 1
67:            
68:            void Intr_ctor( void )
69:            {
70:                INTCON = 0x20;                 //disable global and enable TMR0 interrupt
442A  0E20     MOVLW 0x20
442C  6EF2     MOVWF INTCON, ACCESS
71:            	INTCON2 = 0x84;                //TMR0 high priority
442E  0E84     MOVLW 0x84
4430  6EF1     MOVWF INTCON2, ACCESS
72:            #ifdef ENABLE_INT2
73:                INTCON3 = 0xD8;		//разрешить внешние прерывания INT2 (для детектирования переходов через нуль 
4432  0ED8     MOVLW 0xD8
4434  6EF0     MOVWF INTCON3, ACCESS
74:            #else                   //сетевого напряжения)и INT1 (для опроса датчика ворошителя)
75:            	INTCON3 = 0xC8;
76:            #endif
77:                RCONbits.IPEN = 1;  //enable priority levels
4436  8ED0     BSF RCON, 7, ACCESS
78:            	TMR0H = 0;          //clear timer
4438  6AD7     CLRF TMR0H, ACCESS
79:            	TMR0L = 0;          //clear timer
443A  6AD6     CLRF TMR0, ACCESS
80:            	T0CON = 0xC5;
443C  0EC5     MOVLW 0xC5
443E  6ED5     MOVWF T0CON, ACCESS
81:            	INTCONbits.GIEH = 1; //enable interrupts
4440  8EF2     BSF INTCON, 7, ACCESS
82:                IPR2 = 0x02;        //установить высокий приоритет прерыванию от т/с3
4442  0E02     MOVLW 0x2
4444  6EA2     MOVWF IPR2, ACCESS
83:            	T2CON = 0;
4446  6ACA     CLRF T2CON, ACCESS
84:            	PIE1 = 0;
4448  6A9D     CLRF PIE1, ACCESS
85:            	PIE2 = 0;
444A  6AA0     CLRF PIE2, ACCESS
86:                IPR1 = 0x02;                //установить высокий приоритет прерыванию от т/с2
444C  0E02     MOVLW 0x2
444E  6E9F     MOVWF IPR1, ACCESS
87:            #ifdef ENABLE_INT2    
88:                TRIS_INTR_NULL_SIN = IN;    //установить на вход пин внешнего прерівания INT2 (имрульс перехода через нуль 220В)
4450  8493     BSF TRISB, 2, ACCESS
89:            #endif
90:            }
4452  0012     RETURN 0
91:            
92:            void Intr_set_cnt_zero_crossing(uint8_t value)
4454  CFD9     MOVFF FSR2, POSTINC1
4456  FFE6     NOP
4458  CFE1     MOVFF FSR1, FSR2
445A  FFD9     NOP
93:            {
94:            	cnt_zero_crossing = value;
445C  0EFE     MOVLW 0xFE
445E  50DB     MOVF PLUSW2, W, ACCESS
4460  0101     MOVLB 0x1
4462  6F13     MOVWF 0x13, BANKED
4464  6B14     CLRF 0x14, BANKED
95:            }
4466  52E5     MOVF POSTDEC1, F, ACCESS
4468  CFE7     MOVFF INDF1, FSR2
446A  FFD9     NOP
446C  0012     RETURN 0
96:            
97:            uint16_t Intr_get_cnt_zero_crossing(void)
98:            {
99:            	return cnt_zero_crossing;
446E  C113     MOVFF cnt_zero_crossing, PROD
4470  FFF3     NOP
4472  C114     MOVFF 0x114, PRODH
4474  FFF4     NOP
4476  D000     BRA 0x4478
100:           }
4478  0012     RETURN 0
101:           
102:           void Intr_set_is_zero_cross (BOOL value)
447A  CFD9     MOVFF FSR2, POSTINC1
447C  FFE6     NOP
447E  CFE1     MOVFF FSR1, FSR2
4480  FFD9     NOP
103:           {
104:           	is_zero_cross = value;
4482  0EFE     MOVLW 0xFE
4484  CFDB     MOVFF PLUSW2, is_zero_cross
4486  F115     NOP
105:           }
4488  52E5     MOVF POSTDEC1, F, ACCESS
448A  CFE7     MOVFF INDF1, FSR2
448C  FFD9     NOP
448E  0012     RETURN 0
106:           
107:           BOOL Intr_get_is_zero_cross(void)
108:           {
109:           	return is_zero_cross;
4490  0101     MOVLB 0x1
4492  5115     MOVF 0x15, W, BANKED
4494  D000     BRA 0x4496
110:           }
4496  0012     RETURN 0
111:           
112:           BOOL Intr_get_is_impulse_agitator_sensor(void)
113:           {
114:           	return is_impulse_agitator_sensor;
4498  0101     MOVLB 0x1
449A  5116     MOVF 0x16, W, BANKED
449C  D000     BRA 0x449E
115:           }
449E  0012     RETURN 0
116:           
117:           void Intr_set_is_impulse_agitator_sensor (BOOL value)
44A0  CFD9     MOVFF FSR2, POSTINC1
44A2  FFE6     NOP
44A4  CFE1     MOVFF FSR1, FSR2
44A6  FFD9     NOP
118:           {
119:           	is_impulse_agitator_sensor = value;
44A8  0EFE     MOVLW 0xFE
44AA  CFDB     MOVFF PLUSW2, is_impulse_agitator_sensor
44AC  F116     NOP
120:           }
44AE  52E5     MOVF POSTDEC1, F, ACCESS
44B0  CFE7     MOVFF INDF1, FSR2
44B2  FFD9     NOP
44B4  0012     RETURN 0
121:           
122:           
123:           
124:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/EEPROMmemory/eeprom.c  ---------------------------
1:             //Модуль работы с внешней пакмятью EEPROM
2:             
3:             
4:             #include <p18cxxx.h>
5:             #include <delays.h>
6:             #include "stdint.h"
7:             #include "module_management.h"
8:             #include "i2c.h"
9:             
10:            
11:            //Константа записи параметров меню в энергонезависимой памяти EEPROM
12:            const rom uint8_t start_config[] = 
13:            {
14:            /*P0*/	20, 	//время разгона двигателя (дозатора) в 1/100 с
15:            /*P1*/	3, 		//максимальное время вращения двигателя  (дозатора) в секундах
16:            /*P2*/	72, 	//минимальный процент скважности ШИМа при разгоне двигателя (дозатора)
17:            /*P3*/	3,		//количество повторных попыток вращения двигателя (дозатора) при несрабатывании концевика, после которого появляется признак аварии 
18:            /*P4*/	30,		//время разгона двигателя (ворошителя) в 1/100 с		 
19:            /*P5*/  10,		//максимальное время вращения двигателя  (ворошителя) в секундах 
20:            /*P6*/  100,	//минимальный процент скважности ШИМа при разгоне двигателя (ворошителя)
21:            /*P7*/	0, 		//количество повторных попыток вращения двигателя (ворошителя) при несрабатывании концевика, после которого появляется признак аварии
22:            /*P8*/	20,		//время разгона двигателя (заслонки) в 1/100 с	 
23:            /*P9*/	3,		//максимальное время вращения двигателя  (заслонки) в секундах  
24:            /*P10*/	72, 	//минимальный процент скважности ШИМа при разгоне двигателя (заслонки)
25:            /*P11*/	7, 		//количество повторных попыток вращения двигателя (заслонки) при несрабатывании концевика, после которого появляется признак аварии			
26:            /*P12*/	30,		//время разгона двигателя (чистка золы) в 1/100 с		 
27:            /*P13*/ 30,		//максимальное время вращения двигателя  (чистка золы) в секундах 
28:            /*P14*/ 100,	//минимальный процент скважности ШИМа при разгоне двигателя (чистка золы)
29:            /*P15*/	0,      //количество повторных попыток вращения двигателя (чистка золы)
30:            /*P16*/	2,		//минимальный уровень оборотов вентилятора в режиме поддержания температуры. Диапазон значений 1...3
31:            /*P17*/	3, 		//максимальный процент скорости оборотов вентилятора. Диапазон значений 2...8
32:            /*P18*/	20,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для угля)
33:            /*P19*/	40,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для щепы)	
34:            /*P20*/	40,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для пеллет)
35:            /*P21*/	12, 	//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для угля)
36:            /*P22*/	6,		//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для щепы)
37:            /*P23*/	6,		//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для пеллет)
38:            /*P24*/ 5, 		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для угля)
39:            /*P25*/	2,		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для щепы)
40:            /*P26*/	2,		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для пеллет)
41:            /*P27*/	15, 	//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для угля)
42:            /*P28*/	5,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для щепы)
43:            /*P29*/	5,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для пеллет)
44:            /*P30*/	12,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для угля
45:            /*P31*/	4,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для щепы
46:            /*P32*/	6,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для пеллет
47:            /*P33*/	2,		// уровень оборотов вентилятора в эконом-режиме от 2 до 4 для угля
48:            /*P34*/	3,		// уровень оборотов вентилятора в эконом-режиме от 2 до 4 для щепы
49:            /*P35*/	3,		// уровень оборотов вентилятора в эконом-режиме от 2 до 4 для пеллет
50:            /*P36*/	2,		// уровень оборотов вентилятора в режиме продувки от 2 до 4 для угля
51:            /*P37*/	3,		// уровень оборотов вентилятора в режиме продувки от 2 до 4 для щепы
52:            /*P38*/	3,		// уровень оборотов вентилятора в режиме продувки от 2 до 4 для пеллет
53:            /*P39*/	50, 	//установленная температура
54:            /*P40*/	1, 		//тип топлива
55:            /*P41*/	1,		//флаг разрешения звука. 1 - разрешён, 0 - запрещён	 		
56:            /*P42*/	15,		//время в секундах, по истечении которого, если нет действий пользователя, выходим из меню 
57:            /*P43*/	6,		//период загрузок топлива "Уголь"  (в сотнях секунд)
58:            /*P44*/	3, 		//период загрузок топлива "Брикеты" (в сотнях секунд)
59:            /*P45*/	3, 		//период загрузок топлива "Пеллеты" (в сотнях секунд)
60:            /*P46*/	2, 		//пороговое значение разницы между текущей и установленной температурой, по которой управляется вентилятор
61:            /*P47*/	3,		//уровень оборотов вентилятора для режима горения 2...8 (время в мс, в течение которого симистор открыт в каждом полупериоде синусоиды)
62:            /*P48*/ 10,     //время работы двигателя чистки золы (в секундах)
63:            /*P49*/ 18,     //период между включениями двигателя чистки золы (в сотнях секунд)
64:            /*P50*/ 0, 		//код аварии
65:            /*P51*/ 0, 		//код автомата состояний
66:            /*P52*/ 200		//версия программного обеспечения (2.00)
67:            
68:            
69:            };			
70:            
71:            static void FactorySettingsReadAndWrite( ParametersBuffer* parameters_buffer );
72:            
73:            
74:            void EEPROM_ctor( void )
75:            {
76:                i2c_init();
3D8A  EC41     CALL 0x4882, 0
3D8C  F024     NOP
77:                FactorySettingsReadAndWrite( M_Mngm_Get_parameters_buffer( ) );
3D8E  EC8E     CALL 0x151C, 0
3D90  F00A     NOP
3D92  CFF3     MOVFF PROD, __tmp_0
3D94  F032     NOP
3D96  CFF4     MOVFF PRODH, 0x33
3D98  F033     NOP
3D9A  C032     MOVFF __tmp_0, POSTINC1
3D9C  FFE6     NOP
3D9E  C033     MOVFF 0x33, POSTINC1
3DA0  FFE6     NOP
3DA2  D89D     RCALL FactorySettingsReadAndWrite
3DA4  52E5     MOVF POSTDEC1, F, ACCESS
3DA6  52E5     MOVF POSTDEC1, F, ACCESS
78:            }
3DA8  0012     RETURN 0
79:            
80:            //Чтение байта из ячейки внешней EEPROM
81:            uint8_t DataEERead( uint16_t mem_addr )
3DAA  CFD9     MOVFF FSR2, POSTINC1
3DAC  FFE6     NOP
3DAE  CFE1     MOVFF FSR1, FSR2
3DB0  FFD9     NOP
3DB2  52E6     MOVF POSTINC1, F, ACCESS
82:            {
83:                uint8_t data;
84:            
85:                // Start the I2C Transmission
86:                i2c_start( I2C_START_CMD );
3DB4  6AE6     CLRF POSTINC1, ACCESS
3DB6  EC54     CALL 0x48A8, 0
3DB8  F024     NOP
3DBA  52E5     MOVF POSTDEC1, F, ACCESS
87:                // Write 24LC08B Control Byte - Write
88:                i2c_write( MEMORY_24LC08B_ADDR | I2C_WRITE_CMD );  
3DBC  0EA0     MOVLW 0xA0
3DBE  6EE6     MOVWF POSTINC1, ACCESS
3DC0  EC71     CALL 0x48E2, 0
3DC2  F024     NOP
3DC4  52E5     MOVF POSTDEC1, F, ACCESS
89:                // Sending the 24LC02B 8-Bit Memory Address Pointer
90:                i2c_write( mem_addr & 0x00FF );     
3DC6  0EFF     MOVLW 0xFF
3DC8  6EE7     MOVWF INDF1, ACCESS
3DCA  0EFD     MOVLW 0xFD
3DCC  CFDB     MOVFF PLUSW2, __tmp_0
3DCE  F032     NOP
3DD0  0EFE     MOVLW 0xFE
3DD2  CFDB     MOVFF PLUSW2, 0x33
3DD4  F033     NOP
3DD6  50E7     MOVF INDF1, W, ACCESS
3DD8  1632     ANDWF __tmp_0, F, ACCESS
3DDA  6A33     CLRF 0x33, ACCESS
3DDC  5032     MOVF __tmp_0, W, ACCESS
3DDE  6EE6     MOVWF POSTINC1, ACCESS
3DE0  EC71     CALL 0x48E2, 0
3DE2  F024     NOP
3DE4  52E5     MOVF POSTDEC1, F, ACCESS
91:                // ReStart the I2C Transmission
92:                i2c_start( I2C_REP_START_CMD );
3DE6  0E01     MOVLW 0x1
3DE8  6EE6     MOVWF POSTINC1, ACCESS
3DEA  EC54     CALL 0x48A8, 0
3DEC  F024     NOP
3DEE  52E5     MOVF POSTDEC1, F, ACCESS
93:                // Write 24LC08B Control Byte - Read
94:                i2c_write( MEMORY_24LC08B_ADDR | I2C_READ_CMD); 
3DF0  0EA1     MOVLW 0xA1
3DF2  6EE6     MOVWF POSTINC1, ACCESS
3DF4  EC71     CALL 0x48E2, 0
3DF6  F024     NOP
3DF8  52E5     MOVF POSTDEC1, F, ACCESS
95:                // Read Data from 24LC02B EEPROM
96:                data = i2c_read(); 
3DFA  EC92     CALL 0x4924, 0
3DFC  F024     NOP
3DFE  6EDF     MOVWF INDF2, ACCESS
97:                // Master send No Acknowledge Required to the Slave
98:                i2c_master_ack( I2C_DATA_NOACK );  
3E00  0E01     MOVLW 0x1
3E02  6EE6     MOVWF POSTINC1, ACCESS
3E04  EC81     CALL 0x4902, 0
3E06  F024     NOP
3E08  52E5     MOVF POSTDEC1, F, ACCESS
99:                // Stop the I2C Transmission
100:               i2c_stop();  
3E0A  EC67     CALL 0x48CE, 0
3E0C  F024     NOP
101:               return data;
3E0E  50DF     MOVF INDF2, W, ACCESS
3E10  D000     BRA 0x3E12
102:           }
3E12  52E5     MOVF POSTDEC1, F, ACCESS
3E14  52E5     MOVF POSTDEC1, F, ACCESS
3E16  CFE7     MOVFF INDF1, FSR2
3E18  FFD9     NOP
3E1A  0012     RETURN 0
103:           
104:           //Запись байта данных data в память EEPROM по адресу mem_addr
105:           void DataEEWrite( uint16_t mem_addr, uint8_t data )
3E1C  CFD9     MOVFF FSR2, POSTINC1
3E1E  FFE6     NOP
3E20  CFE1     MOVFF FSR1, FSR2
3E22  FFD9     NOP
106:           {
107:               //Tcy = (1/Fin)*4 = 83,3ns
108:               // Tdelay = 4ms => parameter for Delay1KTCYx = 48001
109:               static const rom uint16_t T_DELAY_4MS = 48000U;
110:               
111:               // Start the I2C Write Transmission
112:               i2c_start( I2C_START_CMD );
3E24  6AE6     CLRF POSTINC1, ACCESS
3E26  EC54     CALL 0x48A8, 0
3E28  F024     NOP
3E2A  52E5     MOVF POSTDEC1, F, ACCESS
113:               // Write I2C OP Code
114:               i2c_write( MEMORY_24LC08B_ADDR | I2C_WRITE_CMD );     
3E2C  0EA0     MOVLW 0xA0
3E2E  6EE6     MOVWF POSTINC1, ACCESS
3E30  EC71     CALL 0x48E2, 0
3E32  F024     NOP
3E34  52E5     MOVF POSTDEC1, F, ACCESS
115:               // Sending the 24LC02B 8-bit Memory Address Pointer
116:               i2c_write( mem_addr & 0x00FF );       
3E36  0EFF     MOVLW 0xFF
3E38  6EE7     MOVWF INDF1, ACCESS
3E3A  0EFD     MOVLW 0xFD
3E3C  CFDB     MOVFF PLUSW2, __tmp_0
3E3E  F032     NOP
3E40  0EFE     MOVLW 0xFE
3E42  CFDB     MOVFF PLUSW2, 0x33
3E44  F033     NOP
3E46  50E7     MOVF INDF1, W, ACCESS
3E48  1632     ANDWF __tmp_0, F, ACCESS
3E4A  6A33     CLRF 0x33, ACCESS
3E4C  5032     MOVF __tmp_0, W, ACCESS
3E4E  6EE6     MOVWF POSTINC1, ACCESS
3E50  EC71     CALL 0x48E2, 0
3E52  F024     NOP
3E54  52E5     MOVF POSTDEC1, F, ACCESS
117:               // Write data to 24LC08B EEPROM
118:               i2c_write( data );   
3E56  0EFC     MOVLW 0xFC
3E58  CFDB     MOVFF PLUSW2, POSTINC1
3E5A  FFE6     NOP
3E5C  EC71     CALL 0x48E2, 0
3E5E  F024     NOP
3E60  52E5     MOVF POSTDEC1, F, ACCESS
119:               // Stop I2C Transmission
120:               i2c_stop();  
3E62  EC67     CALL 0x48CE, 0
3E64  F024     NOP
121:               // Put some delay 4ms here
122:               Delay1KTCYx(T_DELAY_4MS);
3E66  0EAF     MOVLW 0xAF
3E68  6EF6     MOVWF TBLPTR, ACCESS
3E6A  0E4C     MOVLW 0x4C
3E6C  6EF7     MOVWF TBLPTRH, ACCESS
3E6E  0008     TBLRD*
3E70  50F5     MOVF TABLAT, W, ACCESS
3E72  6EE6     MOVWF POSTINC1, ACCESS
3E74  ECC9     CALL 0x4D92, 0
3E76  F026     NOP
3E78  52E5     MOVF POSTDEC1, F, ACCESS
123:           }
3E7A  52E5     MOVF POSTDEC1, F, ACCESS
3E7C  CFE7     MOVFF INDF1, FSR2
3E7E  FFD9     NOP
3E80  0012     RETURN 0
124:           
125:           
126:           /*
127:           Функция чтения массива данных с начального адреса start_addr
128:           с количеством size_buff в массив buffer
129:           */
130:           void Read_buffer_EEPROM (const uint8_t start_addr, ParametersBuffer* parameters_buffer, const uint8_t size_buff)
3E82  CFD9     MOVFF FSR2, POSTINC1
3E84  FFE6     NOP
3E86  CFE1     MOVFF FSR1, FSR2
3E88  FFD9     NOP
3E8A  52E6     MOVF POSTINC1, F, ACCESS
131:           {
132:           	uint8_t count;
133:               
134:                   for ( count = 0; count < size_buff; count++) 
3E8C  6ADF     CLRF INDF2, ACCESS
3E8E  0EFB     MOVLW 0xFB
3E90  50DB     MOVF PLUSW2, W, ACCESS
3E92  5CDF     SUBWF INDF2, W, ACCESS
3E94  E21F     BC 0x3ED4
3ED0  2ADF     INCF INDF2, F, ACCESS
3ED2  D7DD     BRA 0x3E8E
135:                       parameters_buffer->buffer[count] = DataEERead (start_addr + count);
3E96  0EFE     MOVLW 0xFE
3E98  50DB     MOVF PLUSW2, W, ACCESS
3E9A  24DF     ADDWF INDF2, W, ACCESS
3E9C  6EE6     MOVWF POSTINC1, ACCESS
3E9E  6AE6     CLRF POSTINC1, ACCESS
3EA0  DF84     RCALL DataEERead
3EA2  52E5     MOVF POSTDEC1, F, ACCESS
3EA4  52E5     MOVF POSTDEC1, F, ACCESS
3EA6  6EE6     MOVWF POSTINC1, ACCESS
3EA8  0EFC     MOVLW 0xFC
3EAA  CFDB     MOVFF PLUSW2, FSR0
3EAC  FFE9     NOP
3EAE  0EFD     MOVLW 0xFD
3EB0  CFDB     MOVFF PLUSW2, FSR0H
3EB2  FFEA     NOP
3EB4  CFE9     MOVFF FSR0, __tmp_0
3EB6  F032     NOP
3EB8  CFEA     MOVFF FSR0H, 0x33
3EBA  F033     NOP
3EBC  50DF     MOVF INDF2, W, ACCESS
3EBE  010F     MOVLB 0xF
3EC0  2432     ADDWF __tmp_0, W, ACCESS
3EC2  6EE9     MOVWF FSR0, ACCESS
3EC4  0E00     MOVLW 0x0
3EC6  2033     ADDWFC 0x33, W, ACCESS
3EC8  6EEA     MOVWF FSR0H, ACCESS
3ECA  52E5     MOVF POSTDEC1, F, ACCESS
3ECC  50E7     MOVF INDF1, W, ACCESS
3ECE  6EEF     MOVWF INDF0, ACCESS
136:           }  
3ED4  52E5     MOVF POSTDEC1, F, ACCESS
3ED6  52E5     MOVF POSTDEC1, F, ACCESS
3ED8  CFE7     MOVFF INDF1, FSR2
3EDA  FFD9     NOP
3EDC  0012     RETURN 0
137:           
138:           //Чтение конфигурации прибора и запись "заводских установок" в чистую EEPROM
139:           static void FactorySettingsReadAndWrite( ParametersBuffer* parameters_buffer )
3EDE  CFD9     MOVFF FSR2, POSTINC1
3EE0  FFE6     NOP
3EE2  CFE1     MOVFF FSR1, FSR2
3EE4  FFD9     NOP
3EE6  52E6     MOVF POSTINC1, F, ACCESS
140:           {
141:               static const uint8_t SIZE_BUF_AND_ADDR_MAGIC_VAL = sizeof( start_config ) / sizeof( start_config[0] ); 
142:               static const uint8_t MAGIC_VALUE = 0xAA;
143:               static const uint8_t START_ADDR_EEPROM = 0U;
144:               
145:               uint8_t count;
146:               
147:               if( DataEERead( SIZE_BUF_AND_ADDR_MAGIC_VAL ) == MAGIC_VALUE ) //уже есть записанные данные
3EE8  0100     MOVLB 0x0
3EEA  51FD     MOVF 0xFD, W, BANKED
3EEC  6EE6     MOVWF POSTINC1, ACCESS
3EEE  6AE6     CLRF POSTINC1, ACCESS
3EF0  DF5C     RCALL DataEERead
3EF2  52E5     MOVF POSTDEC1, F, ACCESS
3EF4  52E5     MOVF POSTDEC1, F, ACCESS
3EF6  0100     MOVLB 0x0
3EF8  5DFE     SUBWF 0xFE, W, BANKED
3EFA  E110     BNZ 0x3F1C
148:               {
149:                   Read_buffer_EEPROM ( START_ADDR_EEPROM, parameters_buffer, SIZE_BUF_AND_ADDR_MAGIC_VAL );
3EFC  C0FD     MOVFF 0xFD, POSTINC1
3EFE  FFE6     NOP
3F00  0EFD     MOVLW 0xFD
3F02  CFDB     MOVFF PLUSW2, POSTINC1
3F04  FFE6     NOP
3F06  0EFE     MOVLW 0xFE
3F08  CFDB     MOVFF PLUSW2, POSTINC1
3F0A  FFE6     NOP
3F0C  C0FF     MOVFF 0xFF, POSTINC1
3F0E  FFE6     NOP
3F10  DFB8     RCALL Read_buffer_EEPROM
3F12  52E5     MOVF POSTDEC1, F, ACCESS
3F14  52E5     MOVF POSTDEC1, F, ACCESS
3F16  52E5     MOVF POSTDEC1, F, ACCESS
3F18  52E5     MOVF POSTDEC1, F, ACCESS
150:               }
151:               else    //запись "заводских" установок 
3F1A  D040     BRA 0x3F9C
152:               {
153:                   for ( count = 0; count < SIZE_BUF_AND_ADDR_MAGIC_VAL; count++ ) 
3F1C  6ADF     CLRF INDF2, ACCESS
3F1E  0100     MOVLB 0x0
3F20  51FD     MOVF 0xFD, W, BANKED
3F22  5CDF     SUBWF INDF2, W, ACCESS
3F24  E231     BC 0x3F88
3F84  2ADF     INCF INDF2, F, ACCESS
3F86  D7CB     BRA 0x3F1E
154:                   {
155:                       DataEEWrite( START_ADDR_EEPROM + count, start_config[count] );
3F26  50DF     MOVF INDF2, W, ACCESS
3F28  6AF7     CLRF TBLPTRH, ACCESS
3F2A  0F7A     ADDLW 0x7A
3F2C  6EF6     MOVWF TBLPTR, ACCESS
3F2E  0E4C     MOVLW 0x4C
3F30  22F7     ADDWFC TBLPTRH, F, ACCESS
3F32  0008     TBLRD*
3F34  50F5     MOVF TABLAT, W, ACCESS
3F36  6EE6     MOVWF POSTINC1, ACCESS
3F38  50DF     MOVF INDF2, W, ACCESS
3F3A  0100     MOVLB 0x0
3F3C  25FF     ADDWF 0xFF, W, BANKED
3F3E  6EE6     MOVWF POSTINC1, ACCESS
3F40  6AE6     CLRF POSTINC1, ACCESS
3F42  DF6C     RCALL DataEEWrite
3F44  52E5     MOVF POSTDEC1, F, ACCESS
3F46  52E5     MOVF POSTDEC1, F, ACCESS
3F48  52E5     MOVF POSTDEC1, F, ACCESS
156:                       parameters_buffer->buffer[count] = start_config[count];
3F4A  50DF     MOVF INDF2, W, ACCESS
3F4C  6AF7     CLRF TBLPTRH, ACCESS
3F4E  0F7A     ADDLW 0x7A
3F50  6EF6     MOVWF TBLPTR, ACCESS
3F52  0E4C     MOVLW 0x4C
3F54  22F7     ADDWFC TBLPTRH, F, ACCESS
3F56  0008     TBLRD*
3F58  50F5     MOVF TABLAT, W, ACCESS
3F5A  6EE6     MOVWF POSTINC1, ACCESS
3F5C  0EFD     MOVLW 0xFD
3F5E  CFDB     MOVFF PLUSW2, FSR0
3F60  FFE9     NOP
3F62  0EFE     MOVLW 0xFE
3F64  CFDB     MOVFF PLUSW2, FSR0H
3F66  FFEA     NOP
3F68  CFE9     MOVFF FSR0, __tmp_0
3F6A  F032     NOP
3F6C  CFEA     MOVFF FSR0H, 0x33
3F6E  F033     NOP
3F70  50DF     MOVF INDF2, W, ACCESS
3F72  010F     MOVLB 0xF
3F74  2432     ADDWF __tmp_0, W, ACCESS
3F76  6EE9     MOVWF FSR0, ACCESS
3F78  0E00     MOVLW 0x0
3F7A  2033     ADDWFC 0x33, W, ACCESS
3F7C  6EEA     MOVWF FSR0H, ACCESS
3F7E  52E5     MOVF POSTDEC1, F, ACCESS
3F80  50E7     MOVF INDF1, W, ACCESS
3F82  6EEF     MOVWF INDF0, ACCESS
157:                   }
158:                   DataEEWrite( SIZE_BUF_AND_ADDR_MAGIC_VAL, MAGIC_VALUE ); //write magic value to next EEPROM cell (after last element of buffer)
3F88  C0FE     MOVFF 0xFE, POSTINC1
3F8A  FFE6     NOP
3F8C  0100     MOVLB 0x0
3F8E  51FD     MOVF 0xFD, W, BANKED
3F90  6EE6     MOVWF POSTINC1, ACCESS
3F92  6AE6     CLRF POSTINC1, ACCESS
3F94  DF43     RCALL DataEEWrite
3F96  52E5     MOVF POSTDEC1, F, ACCESS
3F98  52E5     MOVF POSTDEC1, F, ACCESS
3F9A  52E5     MOVF POSTDEC1, F, ACCESS
159:               }
160:           }
3F9C  52E5     MOVF POSTDEC1, F, ACCESS
3F9E  52E5     MOVF POSTDEC1, F, ACCESS
3FA0  CFE7     MOVFF INDF1, FSR2
3FA2  FFD9     NOP
3FA4  0012     RETURN 0
161:           
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Drivers/spi.c  -----------------------------------
1:             //Модуль драйвера шины SPI (программного и аппаратного)
2:             
3:             #include <p18f87j50.h>
4:             #include "spi.h"
5:             #include <delays.h>
6:             
7:             #define HW_SPI_SDO_PIN   LATDbits.LATD4    
8:             #define HW_SPI_SDO_TRIS  TRISDbits.TRISD4
9:             #define HW_SPI_SCK_PIN   LATDbits.LATD6
10:            #define HW_SPI_SCK_TRIS  TRISDbits.TRISD6
11:            #define SW_SPI_SDO_PIN   LATJbits.LATJ0
12:            #define SW_SPI_SDO_TRIS  TRISJbits.TRISJ0
13:            #define SW_SPI_SCK_PIN   LATDbits.LATD7
14:            #define SW_SPI_SCK_TRIS  TRISDbits.TRISD7
15:            
16:            
17:            void SPI_init( void )
18:            {
19:                //Инициализация аппаратного модуля SPI2
20:            	SSP2STAT = 0b11000000;
4A64  0EC0     MOVLW 0xC0
4A66  6E6D     MOVWF SSP2STAT, ACCESS
21:            	SSP2CON1 = 0b00100000;
4A68  0E20     MOVLW 0x20
4A6A  6E6C     MOVWF SSP2CON1, ACCESS
22:                HW_SPI_SDO_TRIS = OUT;
4A6C  9895     BCF TRISD, 4, ACCESS
23:                HW_SPI_SCK_TRIS = OUT;
4A6E  9C95     BCF TRISD, 6, ACCESS
24:                
25:                //Инициализация программного модуля SPI2
26:                SW_SPI_SDO_PIN  = 0;
4A70  9091     BCF LATJ, 0, ACCESS
27:                SW_SPI_SDO_TRIS = OUT;
4A72  909A     BCF TRISJ, 0, ACCESS
28:                SW_SPI_SCK_PIN  = 0;
4A74  9E8C     BCF LATD, 7, ACCESS
29:                SW_SPI_SCK_TRIS = OUT;
4A76  9E95     BCF TRISD, 7, ACCESS
30:            }
4A78  0012     RETURN 0
31:            
32:            //Запись байта данных по аппаратному SPI
33:            void HW_SPI_writeByte( uint8_t data )
4A7A  CFD9     MOVFF FSR2, POSTINC1
4A7C  FFE6     NOP
4A7E  CFE1     MOVFF FSR1, FSR2
4A80  FFD9     NOP
4A82  52E6     MOVF POSTINC1, F, ACCESS
34:            {
35:                uint8_t temp;  
36:              	
37:              	temp = SSP2BUF;           // Clears BF
4A84  506F     MOVF SSP2BUF, W, ACCESS
4A86  6EDF     MOVWF INDF2, ACCESS
38:            	PIR1bits.SSPIF = 0;       // Clear interrupt flag
4A88  969E     BCF PIR1, 3, ACCESS
39:            	SSP2BUF = data;           // write byte to SSPBUF register
4A8A  0EFE     MOVLW 0xFE
4A8C  50DB     MOVF PLUSW2, W, ACCESS
4A8E  6E6F     MOVWF SSP2BUF, ACCESS
40:            	while(!PIR1bits.SSPIF);   // wait until bus cycle complete  
4A90  A69E     BTFSS PIR1, 3, ACCESS
4A92  D7FE     BRA 0x4A90
41:            }
4A94  52E5     MOVF POSTDEC1, F, ACCESS
4A96  52E5     MOVF POSTDEC1, F, ACCESS
4A98  CFE7     MOVFF INDF1, FSR2
4A9A  FFD9     NOP
4A9C  0012     RETURN 0
42:            
43:            //Запись байта данных по программному SPI
44:            void SW_SPI_writeByte( uint8_t data )
4A9E  CFD9     MOVFF FSR2, POSTINC1
4AA0  FFE6     NOP
4AA2  CFE1     MOVFF FSR1, FSR2
4AA4  FFD9     NOP
4AA6  52E6     MOVF POSTINC1, F, ACCESS
45:            {
46:                int8_t i;
47:            	
48:                for( i = 0; i < 8; i++ ) 
4AA8  6ADF     CLRF INDF2, ACCESS
4AAA  CFDF     MOVFF INDF2, __tmp_0
4AAC  F032     NOP
4AAE  0E08     MOVLW 0x8
4AB0  6EE7     MOVWF INDF1, ACCESS
4AB2  1832     XORWF __tmp_0, W, ACCESS
4AB4  AEE8     BTFSS WREG, 7, ACCESS
4AB6  D002     BRA 0x4ABC
4AB8  34E7     RLCF INDF1, W, ACCESS
4ABA  D002     BRA 0x4AC0
4ABC  50E7     MOVF INDF1, W, ACCESS
4ABE  5C32     SUBWF __tmp_0, W, ACCESS
4AC0  E212     BC 0x4AE6
4AE2  2ADF     INCF INDF2, F, ACCESS
4AE4  D7E2     BRA 0x4AAA
49:                {
50:            		SW_SPI_SCK_PIN = 0;
4AC2  9E8C     BCF LATD, 7, ACCESS
51:                    if ( data & 0x80 ) 
4AC4  0EFE     MOVLW 0xFE
4AC6  AEDB     BTFSS PLUSW2, 7, ACCESS
4AC8  D002     BRA 0x4ACE
52:                        SW_SPI_SDO_PIN = 1;
4ACA  8091     BSF LATJ, 0, ACCESS
53:            		else 
4ACC  D001     BRA 0x4AD0
54:                        SW_SPI_SDO_PIN = 0;
4ACE  9091     BCF LATJ, 0, ACCESS
55:            		SW_SPI_SCK_PIN = 1;
4AD0  8E8C     BSF LATD, 7, ACCESS
56:                    data <<= 1;
4AD2  0EFE     MOVLW 0xFE
4AD4  CFDB     MOVFF PLUSW2, PROD
4AD6  FFF3     NOP
4AD8  9EF3     BCF PROD, 7, ACCESS
4ADA  46F3     RLNCF PROD, F, ACCESS
4ADC  0EFE     MOVLW 0xFE
4ADE  CFF3     MOVFF PROD, PLUSW2
4AE0  FFDB     NOP
57:                }
58:            }
4AE6  52E5     MOVF POSTDEC1, F, ACCESS
4AE8  52E5     MOVF POSTDEC1, F, ACCESS
4AEA  CFE7     MOVFF INDF1, FSR2
4AEC  FFD9     NOP
4AEE  0012     RETURN 0
59:            
60:            
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/Drivers/i2c.c  -----------------------------------
1:             //Модуль драйвера I2C
2:             
3:             #include "i2c.h"
4:             #include <p18cxxx.h>
5:             
6:             void i2c_init(void) 
7:             {
8:             	// Initial PIC18F87О50 I2C bus Ports: RС4 - SDA and RС3 - SCL, Set as Input
9:             	TRISCbits.TRISC4 = 1;
4882  8894     BSF TRISC, 4, ACCESS
10:            	TRISCbits.TRISC3 = 1;  
4884  8694     BSF TRISC, 3, ACCESS
11:            
12:            	// Initial the PIC18F14K22 MSSP Peripheral I2C Master Mode
13:            	// I2C Master Clock Speed: 16000000 / ((4 * (SSPADD + 1)) = 16000000 / (4 * (39 + 1))
14:            	SSP1STAT = 0x80;      // Slew Rate is disable for 100 kHz mode
4886  0E80     MOVLW 0x80
4888  6EC7     MOVWF SSP1STAT, ACCESS
15:            	SSP1CON1 = 0x28;      // Enable SDA and SCL, I2C Master mode, clock = FOSC/(4 * (SSPADD + 1))
488A  0E28     MOVLW 0x28
488C  6EC6     MOVWF SSP1CON1, ACCESS
16:            	SSP1CON2 = 0x00;      // Reset MSSP Control Register
488E  6AC5     CLRF SSP1CON2, ACCESS
17:            	SSP1ADD = 39;         // Standard I2C Clock speed: 100 kHz  
4890  0E27     MOVLW 0x27
4892  6EC8     MOVWF SSP1ADD, ACCESS
18:            	PIR1bits.SSP1IF=0;    // Clear MSSP Interrupt Flag
4894  969E     BCF PIR1, 3, ACCESS
19:            }
4896  0012     RETURN 0
20:            
21:            void i2c_idle(void)
22:            {
23:            	// Wait I2C Bus and Status Idle (i.e. ACKEN, RCEN, PEN, RSEN, SEN)
24:            	while (( SSP1CON2 & 0x1F ) || ( SSP1STATbits.R_W));
4898  0E1F     MOVLW 0x1F
489A  14C5     ANDWF SSP1CON2, W, ACCESS
489C  E103     BNZ 0x48A4
489E  50C7     MOVF SSP1STAT, W, ACCESS
48A0  0B04     ANDLW 0x4
48A2  E001     BZ 0x48A6
48A4  D7F9     BRA i2c_idle
25:            }
48A6  0012     RETURN 0
26:            
27:            void i2c_start(uint8_t stype)
48A8  CFD9     MOVFF FSR2, POSTINC1
48AA  FFE6     NOP
48AC  CFE1     MOVFF FSR1, FSR2
48AE  FFD9     NOP
28:            {
29:            	i2c_idle();                     // Ensure the I2C module is idle
48B0  DFF3     RCALL i2c_idle
30:            	if (stype == I2C_START_CMD) 
48B2  0EFE     MOVLW 0xFE
48B4  50DB     MOVF PLUSW2, W, ACCESS
48B6  E104     BNZ 0x48C0
31:            	{
32:            		SSP1CON2bits.SEN = 1;          // Start I2C Transmission
48B8  80C5     BSF SSP1CON2, 0, ACCESS
33:            		while(SSP1CON2bits.SEN);
48BA  B0C5     BTFSC SSP1CON2, 0, ACCESS
48BC  D7FE     BRA 0x48BA
34:            	} 
35:            	else 
48BE  D003     BRA 0x48C6
36:            	{
37:            		SSP1CON2bits.RSEN = 1;         // ReStart I2C Transmission
48C0  82C5     BSF SSP1CON2, 1, ACCESS
38:            		while(SSP1CON2bits.RSEN);
48C2  B2C5     BTFSC SSP1CON2, 1, ACCESS
48C4  D7FE     BRA 0x48C2
39:            	}
40:            }
48C6  52E5     MOVF POSTDEC1, F, ACCESS
48C8  CFE7     MOVFF INDF1, FSR2
48CA  FFD9     NOP
48CC  0012     RETURN 0
41:            
42:            void i2c_stop(void)
43:            {
44:            	// Stop I2C Transmission
45:            	SSP1CON2bits.PEN = 1;
48CE  84C5     BSF SSP1CON2, 2, ACCESS
46:            	while(SSP1CON2bits.PEN);
48D0  B4C5     BTFSC SSP1CON2, 2, ACCESS
48D2  D7FE     BRA 0x48D0
47:            }
48D4  0012     RETURN 0
48:            
49:            uint8_t i2c_slave_ack(void)
50:            {
51:            	// Return: 1 = Acknowledge was not received from slave
52:            	//         0 = Acknowledge was received from slave
53:            	return(SSP1CON2bits.ACKSTAT);
48D6  50C5     MOVF SSP1CON2, W, ACCESS
48D8  0B40     ANDLW 0x40
48DA  E001     BZ 0x48DE
48DC  0E01     MOVLW 0x1
48DE  D000     BRA 0x48E0
54:            }
48E0  0012     RETURN 0
55:            
56:            void i2c_write(uint8_t data)
48E2  CFD9     MOVFF FSR2, POSTINC1
48E4  FFE6     NOP
48E6  CFE1     MOVFF FSR1, FSR2
48E8  FFD9     NOP
57:            {
58:              // Send the Data to I2C Bus
59:              SSP1BUF = data;
48EA  0EFE     MOVLW 0xFE
48EC  50DB     MOVF PLUSW2, W, ACCESS
48EE  6EC9     MOVWF SSP1BUF, ACCESS
60:              if (SSP1CON1bits.WCOL)         // Check for write collision
48F0  BEC6     BTFSC SSP1CON1, 7, ACCESS
61:                return;  
48F2  D003     BRA 0x48FA
62:            
63:              while(SSP1STATbits.BF);        // Wait until write cycle is complete
48F4  B0C7     BTFSC SSP1STAT, 0, ACCESS
48F6  D7FE     BRA 0x48F4
64:              i2c_idle();                   // Ensure the I2C module is idle
48F8  DFCF     RCALL i2c_idle
65:            }
48FA  52E5     MOVF POSTDEC1, F, ACCESS
48FC  CFE7     MOVFF INDF1, FSR2
48FE  FFD9     NOP
4900  0012     RETURN 0
66:            
67:            void i2c_master_ack(uint8_t ack_type)
4902  CFD9     MOVFF FSR2, POSTINC1
4904  FFE6     NOP
4906  CFE1     MOVFF FSR1, FSR2
4908  FFD9     NOP
68:            {
69:              SSP1CON2bits.ACKDT = ack_type;   // 1 = Not Acknowledge, 0 = Acknowledge
490A  0EFE     MOVLW 0xFE
490C  50DB     MOVF PLUSW2, W, ACCESS
490E  B0E8     BTFSC WREG, 0, ACCESS
4910  8AC5     BSF SSP1CON2, 5, ACCESS
4912  A0E8     BTFSS WREG, 0, ACCESS
4914  9AC5     BCF SSP1CON2, 5, ACCESS
70:              SSP1CON2bits.ACKEN = 1;          // Enable Acknowledge
4916  88C5     BSF SSP1CON2, 4, ACCESS
71:              while (SSP1CON2bits.ACKEN == 1U);
4918  B8C5     BTFSC SSP1CON2, 4, ACCESS
491A  D7FE     BRA 0x4918
72:            }
491C  52E5     MOVF POSTDEC1, F, ACCESS
491E  CFE7     MOVFF INDF1, FSR2
4920  FFD9     NOP
4922  0012     RETURN 0
73:            
74:            uint8_t i2c_read(void)
75:            {
76:              // Ensure the I2C module is idle
77:              i2c_idle();                         
4924  DFB9     RCALL i2c_idle
78:            
79:              // Enable Receive Mode
80:              SSP1CON2bits.RCEN = 1;           // Enable master for 1 byte reception
4926  86C5     BSF SSP1CON2, 3, ACCESS
81:              while(!SSP1STATbits.BF);         // Wait until buffer is full
4928  A0C7     BTFSS SSP1STAT, 0, ACCESS
492A  D7FE     BRA 0x4928
82:              return SSP1BUF;
492C  50C9     MOVF SSP1BUF, W, ACCESS
492E  D000     BRA 0x4930
83:            }
4930  0012     RETURN 0
---  D:/Vl_prj/Solid_fuel_boiler(rev 2_0)/Software/src/DebugTools/logicAnalyzer.c  ----------------------
1:             #include <p18f87j50.h>
2:             #include <delays.h>
3:             #include "spi.h"
4:             #include "logicAnalyzer.h"
5:             
6:             
7:             #define STROBE_EN_PIN   LATDbits.LATD5
8:             #define STROBE_EN_TRIS  TRISDbits.TRISD5
9:             
10:            
11:            static void DebugTools_setStrobeSPI(void);
12:            
13:            //*****************************************************************************
14:            // Реализация интерфейсных функций
15:            //*****************************************************************************
16:            
17:            //*****************************************************************************
18:            // Инициализация компонента DebugTools
19:            
20:            void DebugTools_ctor(void) 
21:            {
22:                SPI_init();
49D0  EC32     CALL 0x4A64, 0
49D2  F025     NOP
23:                STROBE_EN_TRIS = OUT;
49D4  9A95     BCF TRISD, 5, ACCESS
24:                STROBE_EN_PIN = 1;
49D6  8A8C     BSF LATD, 5, ACCESS
25:            #ifndef ENABLE_SECOND_PUMP 
26:                DEBUG_PIN_1_GPIO = OFF;
49D8  9A90     BCF LATH, 5, ACCESS
27:                DEBUG_PIN_1_TRIS = OUT;
49DA  9A99     BCF TRISH, 5, ACCESS
28:            #endif
29:            #ifndef ENABLE_TRISTATE_VALVE     
30:                DEBUG_PIN_2_GPIO = OFF; 
49DC  968A     BCF LATB, 3, ACCESS
31:                DEBUG_PIN_2_TRIS = OUT; 
49DE  9693     BCF TRISB, 3, ACCESS
32:            #endif    
33:            }
49E0  0012     RETURN 0
34:            
35:            //*****************************************************************************
36:            // Реализация локальных функций
37:            //*****************************************************************************
38:            
39:            //*****************************************************************************
40:            //Формирование строба
41:            
42:            static void DebugTools_setStrobeSPI(void) 
43:            {
44:                STROBE_EN_PIN = 1;
49E2  8A8C     BSF LATD, 5, ACCESS
45:                Delay1TCY();
49E4  0000     NOP
46:                STROBE_EN_PIN = 0;
49E6  9A8C     BCF LATD, 5, ACCESS
47:            }
49E8  0012     RETURN 0
48:            
49:            //*****************************************************************************
50:            // Передача по SPI слова данных
51:            
52:            void DebugTools_trWordSPI(const uint16_t data)
49EA  CFD9     MOVFF FSR2, POSTINC1
49EC  FFE6     NOP
49EE  CFE1     MOVFF FSR1, FSR2
49F0  FFD9     NOP
53:            {
54:                DebugTools_setStrobeSPI();
49F2  DFF7     RCALL DebugTools_setStrobeSPI
55:                HW_SPI_writeByte(data);
49F4  0EFD     MOVLW 0xFD
49F6  CFDB     MOVFF PLUSW2, POSTINC1
49F8  FFE6     NOP
49FA  EC3D     CALL 0x4A7A, 0
49FC  F025     NOP
49FE  52E5     MOVF POSTDEC1, F, ACCESS
56:                Delay10TCYx(3);
4A00  0E03     MOVLW 0x3
4A02  6EE6     MOVWF POSTINC1, ACCESS
4A04  EC3B     CALL 0x4E76, 0
4A06  F027     NOP
4A08  52E5     MOVF POSTDEC1, F, ACCESS
57:            }
4A0A  52E5     MOVF POSTDEC1, F, ACCESS
4A0C  CFE7     MOVFF INDF1, FSR2
4A0E  FFD9     NOP
4A10  0012     RETURN 0
58:            
59:            //*****************************************************************************
60:            // Передача по SPI массива данных data с размерностью size
61:            
62:            void DebugTools_trBuffSPI(const uint16_t *data, const uint8_t size) 
4A12  CFD9     MOVFF FSR2, POSTINC1
4A14  FFE6     NOP
4A16  CFE1     MOVFF FSR1, FSR2
4A18  FFD9     NOP
4A1A  52E6     MOVF POSTINC1, F, ACCESS
63:            {
64:                uint8_t count;
65:            
66:                DebugTools_setStrobeSPI();
4A1C  DFE2     RCALL DebugTools_setStrobeSPI
67:                for (count = 0; count < size; count++) {
4A1E  6ADF     CLRF INDF2, ACCESS
4A20  0EFC     MOVLW 0xFC
4A22  50DB     MOVF PLUSW2, W, ACCESS
4A24  5CDF     SUBWF INDF2, W, ACCESS
4A26  E219     BC 0x4A5A
4A56  2ADF     INCF INDF2, F, ACCESS
4A58  D7E3     BRA 0x4A20
68:                    HW_SPI_writeByte(data[ count ]);
4A28  6A33     CLRF 0x33, ACCESS
4A2A  34DF     RLCF INDF2, W, ACCESS
4A2C  0BFE     ANDLW 0xFE
4A2E  3633     RLCF 0x33, F, ACCESS
4A30  6E32     MOVWF __tmp_0, ACCESS
4A32  0EFD     MOVLW 0xFD
4A34  50DB     MOVF PLUSW2, W, ACCESS
4A36  2432     ADDWF __tmp_0, W, ACCESS
4A38  6EE9     MOVWF FSR0, ACCESS
4A3A  0EFE     MOVLW 0xFE
4A3C  50DB     MOVF PLUSW2, W, ACCESS
4A3E  2033     ADDWFC 0x33, W, ACCESS
4A40  6EEA     MOVWF FSR0H, ACCESS
4A42  50EF     MOVF INDF0, W, ACCESS
4A44  6EE6     MOVWF POSTINC1, ACCESS
4A46  EC3D     CALL 0x4A7A, 0
4A48  F025     NOP
4A4A  52E5     MOVF POSTDEC1, F, ACCESS
69:                    Delay10TCYx(3);
4A4C  0E03     MOVLW 0x3
4A4E  6EE6     MOVWF POSTINC1, ACCESS
4A50  EC3B     CALL 0x4E76, 0
4A52  F027     NOP
4A54  52E5     MOVF POSTDEC1, F, ACCESS
70:                }
71:            }
4A5A  52E5     MOVF POSTDEC1, F, ACCESS
4A5C  52E5     MOVF POSTDEC1, F, ACCESS
4A5E  CFE7     MOVFF INDF1, FSR2
4A60  FFD9     NOP
4A62  0012     RETURN 0
