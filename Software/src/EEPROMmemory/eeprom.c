//Модуль работы с внешней пакмятью EEPROM


#include <p18cxxx.h>
#include <delays.h>
#include "stdint.h"
#include "module_management.h"
#include "i2c.h"
#include "crc8.h"


//Константа записи параметров меню в энергонезависимой памяти EEPROM
const uint8_t start_config[] = 
{
/*P0*/	20, 	//время разгона двигателя (дозатора) в 1/100 с
/*P1*/	3, 		//максимальное время вращения двигателя  (дозатора) в секундах
/*P2*/	72, 	//минимальный процент скважности ШИМа при разгоне двигателя (дозатора)
/*P3*/	3,		//количество повторных попыток вращения двигателя (дозатора) при несрабатывании концевика, после которого появляется признак аварии 
/*P4*/	30,		//время разгона двигателя (ворошителя) в 1/100 с		 
/*P5*/  10,		//максимальное время вращения двигателя  (ворошителя) в секундах 
/*P6*/  100,	//минимальный процент скважности ШИМа при разгоне двигателя (ворошителя)
/*P7*/	0, 		//количество повторных попыток вращения двигателя (ворошителя) при несрабатывании концевика, после которого появляется признак аварии
/*P8*/	20,		//время разгона двигателя (заслонки) в 1/100 с	 
/*P9*/	3,		//максимальное время вращения двигателя  (заслонки) в секундах  
/*P10*/	72, 	//минимальный процент скважности ШИМа при разгоне двигателя (заслонки)
/*P11*/	7, 		//количество повторных попыток вращения двигателя (заслонки) при несрабатывании концевика, после которого появляется признак аварии			
/*P12*/	30,		//время разгона двигателя (чистка золы) в 1/100 с		 
/*P13*/ 30,		//максимальное время вращения двигателя  (чистка золы) в секундах 
/*P14*/ 100,	//минимальный процент скважности ШИМа при разгоне двигателя (чистка золы)
/*P15*/	0,      //количество повторных попыток вращения двигателя (чистка золы)
/*P16*/	2,		//минимальный уровень оборотов вентилятора в режиме поддержания температуры. Диапазон значений 1...3
/*P17*/	3, 		//максимальный процент скорости оборотов вентилятора. Диапазон значений 2...8
/*P18*/	20,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для угля)
/*P19*/	40,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для щепы)	
/*P20*/	40,		//время работы вентилятора в цикле работа-пауза режима продувки в секундах (для пеллет)
/*P21*/	12, 	//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для угля)
/*P22*/	6,		//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для щепы)
/*P23*/	6,		//время простоя вентилятора в цикле работа-пауза режима продувки в сотнях секунд (для пеллет)
/*P24*/ 5, 		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для угля)
/*P25*/	2,		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для щепы)
/*P26*/	2,		//разница между текущей и установленной температурами, при которой отключается режим продувки при остывании котла (для пеллет)
/*P27*/	15, 	//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для угля)
/*P28*/	5,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для щепы)
/*P29*/	5,		//время разгона вентилятора от мин до макс оборотов при входе в режим горения в десятках секунд от 6 до 42 (для пеллет)
/*P30*/	12,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для угля
/*P31*/	4,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для щепы
/*P32*/	6,		//разница между установленной и текущей температурой, по которой  вентилятор переходит на минимальные обороты (для экономного сжигания топлива) для пеллет
/*P33*/	2,		// уровень оборотов вентилятора в эконом-режиме от 2 до 4 для угля
/*P34*/	3,		// уровень оборотов вентилятора в эконом-режиме от 2 до 4 для щепы
/*P35*/	3,		// уровень оборотов вентилятора в эконом-режиме от 2 до 4 для пеллет
/*P36*/	2,		// уровень оборотов вентилятора в режиме продувки от 2 до 4 для угля
/*P37*/	3,		// уровень оборотов вентилятора в режиме продувки от 2 до 4 для щепы
/*P38*/	3,		// уровень оборотов вентилятора в режиме продувки от 2 до 4 для пеллет
/*P39*/	50, 	//установленная температура
/*P40*/	1, 		//тип топлива
/*P41*/	1,		//флаг разрешения звука. 1 - разрешён, 0 - запрещён	 		
/*P42*/	15,		//время в секундах, по истечении которого, если нет действий пользователя, выходим из меню 
/*P43*/	6,		//период загрузок топлива "Уголь"  (в сотнях секунд)
/*P44*/	3, 		//период загрузок топлива "Брикеты" (в сотнях секунд)
/*P45*/	3, 		//период загрузок топлива "Пеллеты" (в сотнях секунд)
/*P46*/	2, 		//пороговое значение разницы между текущей и установленной температурой, по которой управляется вентилятор
/*P47*/	3,		//уровень оборотов вентилятора для режима горения 2...8 (время в мс, в течение которого симистор открыт в каждом полупериоде синусоиды)
/*P48*/ 10,     //время работы двигателя чистки золы (в секундах)
/*P49*/ 18,     //период между включениями двигателя чистки золы (в сотнях секунд)
/*P50*/ 0, 		//код аварии
/*P51*/ 0, 		//код автомата состояний
/*P52*/ 200		//версия программного обеспечения (2.00)
};			

static void FactorySettingsReadAndWrite( ParametersBuffer* parameters_buffer );


void EEPROM_ctor( void )
{
    i2c_init();
    FactorySettingsReadAndWrite( M_Mngm_Get_parameters_buffer( ) );
}

//Чтение байта из ячейки внешней EEPROM
uint8_t DataEERead( uint16_t mem_addr )
{
    uint8_t data;

    // Start the I2C Transmission
    i2c_start( I2C_START_CMD );
    // Write 24LC08B Control Byte - Write
    i2c_write( MEMORY_24LC08B_ADDR | I2C_WRITE_CMD );  
    // Sending the 24LC02B 8-Bit Memory Address Pointer
    i2c_write( mem_addr & 0x00FF );     
    // ReStart the I2C Transmission
    i2c_start( I2C_REP_START_CMD );
    // Write 24LC08B Control Byte - Read
    i2c_write( MEMORY_24LC08B_ADDR | I2C_READ_CMD); 
    // Read Data from 24LC02B EEPROM
    data = i2c_read(); 
    // Master send No Acknowledge Required to the Slave
    i2c_master_ack( I2C_DATA_NOACK );  
    // Stop the I2C Transmission
    i2c_stop();  
    return data;
}

//Запись байта данных data в память EEPROM по адресу mem_addr
void DataEEWrite( uint8_t data, uint16_t mem_addr )
{
    //Tcy = (1/Fin)*4 = 83,3ns
    // Tdelay = 4ms => parameter for Delay1KTCYx = 48001
    static const rom uint16_t T_DELAY_4MS = 48000U;
    
    // Start the I2C Write Transmission
    i2c_start( I2C_START_CMD );
    // Write I2C OP Code
    i2c_write( MEMORY_24LC08B_ADDR | I2C_WRITE_CMD );     
    // Sending the 24LC02B 8-bit Memory Address Pointer
    i2c_write( mem_addr & 0x00FF );       
    // Write data to 24LC08B EEPROM
    i2c_write( data );   
    // Stop I2C Transmission
    i2c_stop();  
    // Put some delay 4ms here
    Delay1KTCYx(T_DELAY_4MS);
}


/*
Функция чтения массива данных с начального адреса start_addr
с количеством size_buff в массив buffer
*/
void Read_buffer_EEPROM (const uint8_t start_addr, ParametersBuffer* parameters_buffer, const uint8_t size_buff)
{
	uint8_t count;
    
        for ( count = 0; count < size_buff; count++) 
            parameters_buffer->buffer[count] = DataEERead (start_addr + count);
}  

//Чтение конфигурации прибора и запись "заводских установок" в чистую EEPROM
static void FactorySettingsReadAndWrite( ParametersBuffer* parameters_buffer )
{
    static const rom uint8_t START_ADDR_EEPROM = 0U, MAGIC_VAL = 0xBB;
    uint8_t SIZE_BUF_DATA = sizeof( start_config ) / sizeof( start_config[0] ); 
    uint8_t count, crcEEPROM;
    
    if(DataEERead(SIZE_BUF_DATA + 1 ) != MAGIC_VAL ) //память пустая, записываем данные и crc
    {
        crcEEPROM = crc8_update( 0xFF, start_config, SIZE_BUF_DATA );
        for ( count = 0; count < SIZE_BUF_DATA; count++ ) 
        {    
            DataEEWrite( start_config[count], START_ADDR_EEPROM + count );
            parameters_buffer->buffer[count] = start_config[count];
        }
        DataEEWrite( crcEEPROM, SIZE_BUF_DATA );
        DataEEWrite( MAGIC_VAL, SIZE_BUF_DATA + 1 );
    }
    else    //читаем память в буфер меню параметров
    {
        Read_buffer_EEPROM ( START_ADDR_EEPROM, parameters_buffer, SIZE_BUF_DATA );
        //сюда дописываем проверку CRC всего буфера с тем значеием, что лежит в памяти
        //и в случае несоответствия падаем с ошибкой Exx
    }
}

